<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Moondark]]></title>
  <subtitle><![CDATA[你必须非常努力，才能看起来毫不费力]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liaoxl.github.io/"/>
  <updated>2014-07-15T15:00:46.866Z</updated>
  <id>http://liaoxl.github.io/</id>
  
  <author>
    <name><![CDATA[Xiangli Liao]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[我的第一篇paper]]></title>
    <link href="http://liaoxl.github.io/blog/20140522/first-paper/"/>
    <id>http://liaoxl.github.io/blog/20140522/first-paper/</id>
    <published>2014-05-22T02:34:52.000Z</published>
    <updated>2014-07-15T15:00:02.000Z</updated>
    <content type="html"><![CDATA[<p>找实习虽然只为自己争取到一个秋季的绿色通道，但可喜的是，我投的几篇paper，终于中了一篇。</p>
<p>现在可以在英文数据库或google scholar上面搜索到自己名字，感觉很nice，研究生的心愿算是完成了一部分，至于剩下的中不中，都不那么重要了，已经留下了自己在科研道路上的足迹。</p>
<p>投递的杂志是<strong>Signal Processing</strong>，是一个很不错的杂志，从<strong>ACCEPT</strong>到文章上线速度很快，在我校的评级是<strong>B类</strong>期刊，发表一篇达到学校博士毕业的基本要求（一篇B或者2篇C），审稿周期算是中等吧，这篇文章的周期大约是<strong>7个月</strong>。</p>
<a id="more"></a>

<p><a href="http://www.sciencedirect.com/science/article/pii/S0165168414002163" target="_blank">Science Direct</a></p>
<p><a href="http://scholar.google.com.hk/scholar?q=Xiangli+Liao&amp;btnG=&amp;hl=zh-CN&amp;as_sdt=0%2C5&amp;as_ylo=2014" target="_blank">Google Scholar</a></p>
<h2 id="Automatic_image_segmentation_using_salient_key_point_extraction_and_star_shape_prior">Automatic image segmentation using salient key point extraction and star shape prior</h2>
<blockquote>
<p><strong>Xiangli Liao</strong>, Hongbo Xu, Yicong Zhou, Kunqian Li, Wenbing Tao, Qiuju Guo, Liman Liu</p>
</blockquote>
<h3 id="<strong>ARTICLE_INFO</strong>"><strong>ARTICLE INFO</strong></h3>
<div class="cnblogs_code"><br><pre><br>Article history:<br>Received 27 September 2013<br>Received in revised form<br>28 March 2014<br>Accepted 29 April 2014<br></pre><br></div>

<blockquote>
<p>Please cite this article as: X. Liao, et al., Automatic image segmentation using salient key point extraction and star<br>shape prior, Signal Processing (2014)</p>
</blockquote>
<h3 id="<strong>ABSTRACT</strong>"><strong>ABSTRACT</strong></h3>
<blockquote>
<p>In this paper, a new unsupervised segmentation method is proposed. The method integrates the star shape prior of the image object with salient point detection algorithm. In the proposed method, the Harris salient point detection is first applied to the color image to obtain the initial salient points. A regional contrast based saliency extraction method is then used to select rough object regions in the image. To restrict the distribution of salient points, an adaptive threshold segmentation is applied to the saliency map to get the saliency mask. And then the salient region points can be obtained by placing the saliency mask on the initial Harris salient points. In order to make sure the salient points which we get are inside the image object thus the star shape constraint can be applied to the graph cuts segmentation, the Affinity Propagation (AP) clustering is employed to find the salient key points among the salient region points. Finally, these salient key points are regarded as foreground seeds and the star shape prior is introduced to graph cuts segmentation framework to extract the foreground object. Extensive experiments and comparisons on public database are provided to demonstrate the good performance of the proposed method.</p>
<p>&amp;2014 Published by Elsevier B.V.</p>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<p>找实习虽然只为自己争取到一个秋季的绿色通道，但可喜的是，我投的几篇paper，终于中了一篇。</p>
<p>现在可以在英文数据库或google scholar上面搜索到自己名字，感觉很nice，研究生的心愿算是完成了一部分，至于剩下的中不中，都不那么重要了，已经留下了自己在科研道路上的足迹。</p>
<p>投递的杂志是<strong>Signal Processing</strong>，是一个很不错的杂志，从<strong>ACCEPT</strong>到文章上线速度很快，在我校的评级是<strong>B类</strong>期刊，发表一篇达到学校博士毕业的基本要求（一篇B或者2篇C），审稿周期算是中等吧，这篇文章的周期大约是<strong>7个月</strong>。</p>
]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="图像处理" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[转载 技巧: Vim 的纵向编辑模式]]></title>
    <link href="http://liaoxl.github.io/blog/20140520/vim-ctrl-v/"/>
    <id>http://liaoxl.github.io/blog/20140520/vim-ctrl-v/</id>
    <published>2014-05-20T03:26:51.000Z</published>
    <updated>2014-05-28T15:34:02.000Z</updated>
    <content type="html"><![CDATA[<p>如果要我选一个Vim中让我觉得<strong>Life Changing</strong>功能的话，我一定会选<strong>Vim的块编辑功能</strong>，也就是<strong>Ctrl+V</strong>，虽然还有些别的编辑器也有这功能，但目前为止，我从中受益颇大</p>
<p>原文地址：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vimcolumn/" target="_blank">技巧：Vim 的纵向编辑模式</a></p>
<p>Vim 的纵向编辑模式功能强大。本文介绍了 Vim 纵向编辑模式并结合 VisIncr 这个插件在开发测试场景中的应用，让读者更直观了解 Vim 的纵向编辑模式这一功能。</p>
<a id="more"></a>

<h2 id="开始之前">开始之前</h2>
<p>人类大脑对文字的处理是平面式的，所以我们浏览文章、查找资料或者重构代码，要么是横向读，要么是纵向读，要么使用搜索功能，将文字作为一个平面整体。而在编辑文字、编写代码的时候则不是横向就是纵向。常规文本编辑器都是横向编辑，而纵向编辑也常被作为特色功能。比如 Vim、EditPlus、UltraEdit 这些编辑器都有纵向编辑模式，或者称为列模式。像日常文字处理工具 MicroSoft Word、OpenOffice Writer 也可以通过按下功能键 ALT，实现纵向选中文本，然后对文本进行操作。纵向编辑不仅是编辑器的一种功能，更是人们思考问题的一种方式，项目符号、段落编号，都是纵向编辑的体现。</p>
<p>Vim 的纵向编辑模式启动方便，使用灵活，还可以配合上插件实现很实用的高级功能。</p>
<h2 id="启动方法">启动方法</h2>
<p>在 Vim 命令模式下，移动游标定位于某一个位置，键入 ctrl-v后状态栏上出现 VISUAL BLOCK 字样，即进入纵向编辑模式。移动游标以按需选择待编辑的区域。注意：在 Windows 版本的 Vim 中，键组合 ctrl-v通常被映射为文本粘贴，所以 Window 版的 Vim 的纵向编辑模式由 ctrl-q启动。当然灵活的 Vim 也可以由用户自行定义组合键。</p>
<h3 id="<strong>示例_1：纵向编辑在批量修改代码的应用演示</strong>"><strong>示例 1：纵向编辑在批量修改代码的应用演示</strong></h3>
<p>将数列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="number">10.1</span><span class="number">.5</span><span class="number">.214</span> 
    <span class="number">10.1</span><span class="number">.5</span><span class="number">.212</span> 
    <span class="number">10.1</span><span class="number">.5</span><span class="number">.210</span>
</pre></td></tr></table></figure>

<p>编辑成序列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>   ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> &gt;&gt; result0 
   ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> &gt;&gt; result0 
   ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span> &gt;&gt; result0
</pre></td></tr></table></figure>

<p>这是一个将 IP 数列修改成可执行的 ping 命令序列的过程。</p>
<h3 id="<strong>第一步：修改</strong>"><strong>第一步：修改</strong></h3>
<p>将 IP 数列中第二段所有数字“1” 修改为“5”：</p>
<p>将游标定位第一个行 IP 地址第二段的“1”</p>
<p>ctrl-v 进入纵向编辑模式</p>
<p>G 移动游标到最后一行，可视块覆盖所要修改的列</p>
<p>r 进入修改模式</p>
<p>5 输入数字“5”</p>
<p>ESC 退出纵向编辑模式，同时所有被选中的数字都被改成了“5”，并回到命令模式</p>
<p>结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>   <span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> 
   <span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> 
   <span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span>
</pre></td></tr></table></figure>

<h3 id="<strong>第二步：前添加</strong>"><strong>第二步：前添加</strong></h3>
<p>在所有行之前添加“ping – c 4 ”：</p>
<p>将游标定位到第一行第一列</p>
<p>ctrl-v 进入纵向编辑模式</p>
<p>G 移动游标到最后一行第一列，可视块覆盖了第一列</p>
<p>I 进入行首插入模式</p>
<p>ping -c 4 输入所要求字符“ping – c 4 ”</p>
<p>ESC 退出纵向编辑模式的同时所有选中的字符前都添加了“ping – c 4 ”，回到命令模式</p>
<p>结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>   ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> 
   ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> 
   ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span>
</pre></td></tr></table></figure>

<h3 id="<strong>第三步：后添加</strong>"><strong>第三步：后添加</strong></h3>
<p>在所有行之后添加“&gt;&gt; result0”：</p>
<p>将游标定位到第一行最后一列</p>
<p>ctrl-v 进入纵向编辑模式</p>
<p>G 移动游标到最后一行最后一列，VISUAL 　 BLOCK 　覆盖了最后一列</p>
<p>A 进入行尾插入模式</p>
<p>>> result    输入所要求字符“>> result0”</p>
<p>ESC 退出纵向编辑模式的同时所有选中的字符后都添加了“ &gt;&gt; result0”，回到命令模式</p>
<p>结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>   ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> &gt;&gt; result0 
   ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> &gt;&gt; result0 
   ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span> &gt;&gt; result0
</pre></td></tr></table></figure>

<p>以上三个步骤有一个共同特点，就是都纵向为编辑方向。以上由三行代码为例的方法同样也可以适用于更多的行。</p>
<h2 id="VisIncr_安装与操作">VisIncr 安装与操作</h2>
<p>以上例子中所演示的对代码的纵向编辑，通过一般的代码重构功能或者结合正则表达式的查找替换也可以实现。然而 Vim 的纵向编辑模式还可以通过插件 VisIncr 的扩展，实现更丰富的功能，如纵向的生成数列。</p>
<p>从 Vim 的官方网站上搜索找到 VisIncr 插件的安装文件，并下载到 Vim 工作目录。执行以下命令即可安装该插件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>   vim visincr.vba.gz 
   :so % 
   :q
</pre></td></tr></table></figure>

<p>操作方法以示例 1 的代码为例：</p>
<p>使用 ctrl-v和移动光标选择最后都为数字“0”的一列</p>
<p>:键入冒号触发 Vim 进入命令行模式</p>
<p>:I以第一个数字为出发点，纵向生成增量数列，幅度为 1</p>
<p>ENTER    键入驾车键执行命令</p>
<p>结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>  ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> &gt;&gt; result0 
  ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> &gt;&gt; result1 
  ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span> &gt;&gt; result2
</pre></td></tr></table></figure>

<h3 id="<strong>示例_2：VisIncr_在生成测试数据的应用演示</strong>"><strong>示例 2：VisIncr 在生成测试数据的应用演示</strong></h3>
<p>在应用程序开发过程中经常要生成一个简单有规律的测试数据。比如对一张表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>  testTable (”ipaddr” ,”filename”, ”owner”)
</pre></td></tr></table></figure>

<p>生成如下 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="string">"10.5.5.214”,”result0”,”testa”); 
  insert into test values(”10.5.5.212”,”result1”,”testb”); 
  insert into test values(”10.5.5.210”,”result2”,”testc”);</span></span>
</pre></td></tr></table></figure>

<p>这个纵向有规律的语句序列，可以借助 VinIncr 应用纵向编辑功能来构造。</p>
<h3 id="<strong>第一步：准备</strong>"><strong>第一步：准备</strong></h3>
<p>打开一个新的 Vim 编辑页面，在命令模式下先输入一个“3”，然后键入“i”进入编辑模式。数字“3”代表本次输入的内容会重复输 3 遍。</p>
<p>在 VIM 中先输入第一行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span>
</pre></td></tr></table></figure>

<p>以回车结束行输入并新开一行，按 ESC 键退出编辑模式。</p>
<p>如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> 
  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> 
  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span>
</pre></td></tr></table></figure>

<h3 id="<strong>第二步：构造递减数列</strong>"><strong>第二步：构造递减数列</strong></h3>
<p>对于 ipaddr 列，使用 ctrl-v和移动光标选择 IP 地址最后一段以 2 为幅度递减的部分：</p>
<p>: 键入冒号触发 Vim 进入命令行模式\</p>
<p>:I -2 以第一个数字为出发点，纵向生成递减数列，幅度为 2</p>
<p>ENTER 键入驾车键执行命令</p>
<p>结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> 
  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span>”,”result0”,”testa”);</span> 
  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span>”,”result0”,”testa”);</span>
</pre></td></tr></table></figure>

<h3 id="<strong>第三步：构造递增数列</strong>"><strong>第三步：构造递增数列</strong></h3>
<p>对于 filename 列，使用上一节介绍的方式，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> 
  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span>”,”result1”,”testa”);</span> 
  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span>”,”result2”,”testa”);</span>
</pre></td></tr></table></figure>

<h3 id="<strong>第四步：构造字母递增数列</strong>"><strong>第四步：构造字母递增数列</strong></h3>
<p>对于 owner 列，使用 ctrl-v和移动光标选择英文字母将要递增的部分。</p>
<p>: 键入冒号触发 Vim 进入命令行模式</p>
<p>:IA 以第一个字母为出发点，纵向生成按字母表排序的序列</p>
<p>ENTER 键入回车键执行命令</p>
<p>结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> 
  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span>”,”result1”,”testb”);</span> 
  <span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span>”,”result2”,”testc”);</span>
</pre></td></tr></table></figure>

<p>以上步骤即演示了借助 Vim 插件 VisIncr 对代码的纵向编辑，生成在纵向有逻辑规律的数列。</p>
<h2 id="总结">总结</h2>
<p>Vim 不仅是一个编辑工具还是一套思考方法，Vim 有很多引导思维方向的技巧，让 Vim 在这个各种编辑器层出不穷的时候历久弥新。本文从纵向编辑为切入点，结合 VisIncr 演示了开发、测试过程中可以使用的实例</p>
]]></content>
    <summary type="html"><![CDATA[<p>如果要我选一个Vim中让我觉得<strong>Life Changing</strong>功能的话，我一定会选<strong>Vim的块编辑功能</strong>，也就是<strong>Ctrl+V</strong>，虽然还有些别的编辑器也有这功能，但目前为止，我从中受益颇大</p>
<p>原文地址：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vimcolumn/" target="_blank">技巧：Vim 的纵向编辑模式</a></p>
<p>Vim 的纵向编辑模式功能强大。本文介绍了 Vim 纵向编辑模式并结合 VisIncr 这个插件在开发测试场景中的应用，让读者更直观了解 Vim 的纵向编辑模式这一功能。</p>
]]></summary>
    
      <category term="Vim" scheme="http://liaoxl.github.io/tags/Vim/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实习求职小结]]></title>
    <link href="http://liaoxl.github.io/blog/20140515/intern/"/>
    <id>http://liaoxl.github.io/blog/20140515/intern/</id>
    <published>2014-05-15T08:20:02.000Z</published>
    <updated>2014-07-15T14:59:44.000Z</updated>
    <content type="html"><![CDATA[<p>今年找实习不够顺利，以过去为镜，总结一下自己的一些不足</p>
<p>在简历投递中，我主要是考虑BAT这三家，AT都有熟人可以内推，但A家号称可以实习一个月，而T家一向都是3个月左右，Baidu需要的实习时间就更长了，我只能保证一个月的实习。去年听闻有些师兄乱拿实习offer，然后秋招进入一些公司的黑名单，故我慎之又慎，宁可错过实习，只投了A家。</p>
<a id="more"></a>

<h2 id="阿里巴巴">阿里巴巴</h2>
<p>我对阿里巴巴的期待很大，<a href="#">吴总</a>也知道这点，2月份HR跟他说可以内推的时候，他就第一时间跟我说，然后我赶紧把简历做好，并发给了他。</p>
<p>3.2号 我在阿里巴巴实习校招官网注册了简历，简历状态处于“新投递”一段时间</p>
<p>3月中旬，我听闻很多内推的被电话面试了，但自己并没有，也有些忐忑，以为简历太搓，被看不上。</p>
<p>3.26号，距离阿里巴巴正式笔试还有三天，那段时间可能已经快通知笔试了。那天下午正在调试一个项目的bug，苦苦思索中，一个电话过来，我看是杭州的，以为是通知我笔试的。<br>聊了几句后，发现这是个面试电话，我当时就感觉很紧张了，大脑还处于调bug状态正在切换。</p>
<p>面试官还是很nice的，叫我简单介绍一下我研究生阶段的主要工作，我说，在研究生阶段，我一方面是从事图像分割领域的研究工作，目前已经有两篇成果投递在业内顶级期刊，另一方面是负责实验室一个手绘识别项目的开发。</p>
<p>面试官应该是并不了解图像分割，而是对另外一个手绘识别项目比较感兴趣，然后就问我，“主要是识别什么图形”，我回答说“是对规则几何图形的识别，如矩形、三角形及圆，同时在识别这些基本图形的基础上，对由这些基本图形组成的复杂图形进行识别”。</p>
<p>然后他就问我，“如何识别矩形、三角形及圆”，我说，“对于这些基本图形的识别，我们通过阅读文献知道一个点集的最小凸包、最大内接三角形、最大内接四边形、最小外接矩形可以用来识别规则的几何图形，比如对于直线，其最小外接矩形的长比宽会趋于无限大，三角形的最大内接三角形与最小凸包的面积比趋于1等等，在以前的文献中，是用一种叫做FuzzyLogic的理论进行识别，在编程实现中即类似与if…else…的语句。但我们为了灵活方便，将SVM分类器训练结合起来，对于每一个点集，我们将这些比例特征提取出来，并构成一个向量，并送入到分类器进行训练，从而得到一个识别分类器，对于要识别的每一个点集，提取相应的特征，并将其送入到分类器中即可得到识别结果”</p>
<p>面试官说“OK，那你对技术有没什么倾向，比如对偏业务的技术与纯技术，对哪种更感兴趣？”我问，“怎么界定哪些叫做偏业务的技术与纯技术”，面试官“比如google的搜索就是纯技术，而像淘宝这样属于偏业务的技术”，我当时第一反应就是对后者有兴趣——前者像是研究，像我现在做的事，我研究生几年做研究，觉得研究过程中，将准确率提升几个百分点，实在不够cool，之前看到网上有人评价百度的搜索，“将搜索准确率提高几个百分点，用户基本感觉不到，但在技术上却需要很大的改善”，我很同意这种观点，我希望以后能做一些别人能够直接感受到的事——所以我跟面试官说，与业务相关的技术，是非常cool的。</p>
<p>接下来面试官问我，“以后有没有读博打算，以及工作地点选择”，我回答说，我不打算读博，工作地点主要以杭州、深圳为主，杭州想去阿里，深圳想去腾讯，并表示阿里是我的第一选择，他很有兴趣问“为什么”，我说一个是阿里的文化很吸引我，生活上的武侠文化，以及技术上对开源的态度，顺便提到了自己也喜欢开源，有github项目并贡献了一些代码（面试官说已提前看过我的github），二是阿里通过技术改变了行业，做的事比较cool，面试官听着也很开心。然后就基本上结束了，结尾面试官跟我说，“后续还会有一到两次面试，具体看HR安排”，后来叫我问问题，我问了一个是实习生能否选择部门，面试官说可以，然后我对阿里云感兴趣，就问了一下阿里云的情况，面试官也给我介绍了一下。这里我居然忘记问面试官的花名以及联系方式，真是经验欠缺呀。</p>
<p>电话完回去看简历状态是“应聘中”，到了晚上变为“应聘通过”，当时感觉还是挺不错的。</p>
<p>后来3.29号的笔试就不用参加，然后等消息。</p>
<p>没想到这一等就要等到4.24号</p>
<p>4.24号，现场面试</p>
<p>技术面试官+HR，通知我9:45面试，但我前面的一个人似乎面试了好久，我在外头等了有近1个小时吧，与现场工作人员（前程无忧）聊了一会。</p>
<p>进去之后，感觉2对1压力还是很大，首先自我介绍，然后面试官依旧对手绘识别项目感兴趣，然后我就重新再画框图加讲解，面试官看起来很累，不怎么多说话，只是用“嗯哼”来回应我，但听得还比较认真，对一些关键问题问得很到位——这一点不得不说，我很喜欢与这样能把握重点的人交流，可以少废话，说出自己在核心问题上的处理方式——但后来出现一些分歧，他问我在这些问题上的核心创新，我一一讲出来。</p>
<p>后来就聊到我的研究成果——两篇paper，他要我用一句简洁的话来介绍我的研究，说实在话，我的确没想过这个问题，我是做图像分割的，我不知道他对这个领域了解有多少，沉默了一会，我问他说，“不知道你用过美图秀秀或PhotoShop的抠图没有，就是需要自己稍微标注一下要分割的前景与背景”，他沉默，我不知他用过没，然后我继续说，“我的方法就是将这种交互式的分割转化为自动分割，通过预测目标所在的位置，自动完成图像的分割”，然后他就问，“怎么预测目标所在的位置呢？”我就说，“近年来图像方面有个比较热门的，叫做显著性，不知道在其它领域可有类似的术语，大概就是指人眼看一幅图像，眼睛容易注意的一些目标位置，人眼注意图像都是有规律的，比如图像中心比图像边缘更吸引注意，对比度高的地方比对比度低的地方更吸引注意，当把这些东西量化之后，就能得到每一点的显著性值，这样整幅图像显著性高的地方可以作为是目标所在的地方，而低的地方可以认为是背景，这样就完成了自动标记，然后再通过图割模型分割”，至于我文章中所用的“星形先验”的形状约束，我就没提了，我想他未必能懂——我经常有这样的想法，或许是我的一个大缺点</p>
<p>然后他问我经常逛哪些论坛或社区，我说“我主要在github、stackoverflow、v2ex以及知乎还有些开源社区”，他似乎不太满意，“我想问，你如何获取一些研究信息，比如你做研究会不会关注哪些大牛或者实验室”，说实话，我并未关注，“我主要是通过最新的会议文章了解到最新的研究动向，很少关注具体某个人，真正要说常看的可能是伯克利大学的计算机视觉组，还有牛津大学的机器学习组，至于具体的人，我没有怎么关注，而且国外人的名字我也记不太住，这里也不好列举”，他似乎有点失望——事实上，我的确是这样做的，我主要看的是看每年计算机视觉最顶级的会议文章，从www.cvpapers.com上面看，每一届的CVPR、ICCV、ECCV以及其它的我都以地毯式搜索的方式进行阅读，第一遍从标题找到自己感兴趣的文章，然后进行深入阅读，会议文章往往代表这当前领域最新的方向、最好的成果以及最天马行空的idea——每个人的学习研究方式都不一样，所以孰优孰劣不能一概而论，我知道很多大牛都有相互follow的习惯，尤其是工作人士或者已成名的大牛，在某些领域某些社交网络高谈阔论，但我不是这种，我更像是以一个程序员的角度，对研究问题慢慢琢磨。</p>
<p>后来他问我，“堆和栈的区别？”，我愣了一下，觉得这问的特别突兀，然后回答说“栈是系统分配、释放的内存，堆是程序员动态分配释放的内存”，然后他问我，“还有呢？”我几乎重复了一遍，然后实在想不出，然后说我不知道了——应该还有堆内存以栈内存分配方式的区别——然后叫我写一个二分查找，很简单，但很可惜我当时并未写好，我想以一种很新颖的方式写出来——不需要除法、比较次数最少、找寻不到时候返回插入位置——当时心理就这个想法，写出新颖的解法，然后最快速提交给他——我真的写的很快——但边界问题出现，我回过头后想了一下有点问题，不知他当场看出来了没</p>
<p>接下来就是HR的问话时间——忘了先后顺序了，总之觉得我不擅长在这类问题上表现——“你能说说目前图像处理在哪些公司有较好的应用，或者说哪些公司在用？”，我回答说“图像搜索是一个大公司会用的领域，google的图片搜索做的已经很不错了，百度的做了好几年好像没什么起色，另外有一家最近比较有名的小公司叫face++，在做人脸识别API比较有名，其它的都是一些小公司在做”</p>
<p>“看到你简历上有提高班，能简单的介绍一下吗？”这绝对是我第一次碰到对“提高班”三个字感兴趣的HR，“提高班是我们在刚入学的时候，通过考试在全校进行选拔，总共选拔出60位同学组成这样一个提高班”——我轻描淡写其实是不对滴，我该说前身是华科少年班，全英文教学，以前出过一个理工科榜样式的牛人——<a href="#">李一男</a>，然后再吹嘘一下——“你觉得哪个项目你最有成就感？”我是说的我发paper的那个，“因为在时间较短的情况下，我完成了很多工作量，是非常有挑战的”——“你觉得哪个项目最牛？”，我依然说是那篇paper的——从编程还是从它的地位，的确是它，我就是这么实在——HR觉得不太好问这些了，就问“看你简历，本科在提高班，研究生是保研，请问你觉得最大的挫折是什么？”——这里我很诚实的回答，近些年来，让我念念不忘的失败，大约就是本科面试BAT均以失败告终——我不知道我这么回答会不会有问题，但后来觉得还是有些不妥，有些失败该隐藏起来的，三年前的学习主要以课程为主，现在你可以通过博客看到我的技术发展历程，可以访问我的github看到我的开源项目，甚至不久的将来，可以通过google scholar搜索到我的出版物，这些，都是三年前未曾有的，我想这就是我的提高吧。</p>
<p>“你觉得你读研这几年可有哪些进步？”，我说，“在我读研之后，甚至说从我大四的时候保研开始，我就一直很努力的在改变，一直坚持增加阅读量增加代码量，使得自己有更大的提高，我很相信‘坚持’这种态度，很多事只要坚持下去一定能有所收获”，HR“那你觉得现在有多大的提高？”我“我想已经有了很大的提高吧”，HR“你学的技术中，有没有哪种是你自己自发性的去学习的？”，我“有很多呀，我很喜欢折腾，而且喜欢一些cool的东西”，“举个例子”，“我与一些工作的同学交流，他们说工作环境中文本编辑是用vim，然后我就努力把vim学好，然后我知道很多公司用git作为版本管理工具，我自己也用github，我就对git进行了学习，然后自己写博客，觉得用markdown很效率，我又去熟悉markdown的写作方式，同时我尝试很多脚本语言如ruby/python/nodejs等的开发，但平时不常用，所以并不熟悉，但我对新技术经常都很感兴趣，平时关注热门的开源项目，比如hadoop，spark之类的”——这时候技术官问我，“你关注hadoop，那你能不能说一下它的优缺点？”——其实我并不太了解，只是关注哪些公司在用——我回答说，“它的优点是将大数据处理转化为一种可以用mapreduce模型进行处理，为大数据的处理提供了一种有效可行的方式，它的缺点是速度慢，因为我知道spark是号称100倍快于hadoop，所以速度应该是hadoop处理的一个大问题”，面试官继续说，“还有呢？”我就回答说不知道了。HR对我前面的一句话很感兴趣，说“你经常与工作的同学交流，你这些同学都在哪些公司工作？”，我说“在阿里和腾讯”，然后她又问我“在阿里是在哪个部门？”我回答说，“在阿里云部门”。</p>
<p>接下来就是问他们问题，我大概就问了与电话面试类似的问题。</p>
<p>总结起来，感觉现场面试中，尤其是HR面试部分，我回答的比较乱，没有章理，有很多问题事先我都没有好好准备，没有展现自己的能力，没有亮点，遂后面沦为备胎。</p>
<p>然后就一直在等，阿里的招聘效率实在很渣，等过了五一，等到了5.9号，好像很有一部分人有了offer通知，但那天收到一条“继续等待”的短信。</p>
<p>5.14号，收到电话拒信，告知“部门协调原因，不能安排实习，秋季保留绿色通道，直接终面”，这里得提一下，我在第一次电话面试表达想去阿里云，在主观题上明确写了最想去阿里云部门，却不知居然是给我分配的是菜鸟网络部门。</p>
<p>很失望，真的很失望，很多时候努力的动力，无非是让自己变得更牛逼，去一个想去的公司，以及想要我的公司，二者缺一不可。</p>
<p>后来<a href="#">吴总</a>说再给我推，推阿里云或者一淘，我想了想，觉得阿里流程太乱，很拖+实习最终留下的因素不可控，而且我只能实习一个月，不如好好准备笔试面试，秋季多投几家，不能把鸡蛋放在一个篮子里，跟吴总说，算了吧。</p>
<h2 id="百度">百度</h2>
<p>本科大三时候，百度几乎算是最巅峰的时候，迄今为止，去百度的同学也很牛。</p>
<p>在等阿里的时候投了百度，岗位是“实习计算机视觉算法研发工程师”，申请后一段时间，简历变为“筛选未通过”，我当时觉得很奇怪，后来不久又变成“筛选中”</p>
<p>不久后，百度HR给我打电话，确认我是否能有三个月及以上的实习时间保证，我说不能，然后就没然后了。。也是那个电话，发现我投的居然是百度深度学习研究院。</p>
<p>能通过百度深度学习研究院的简历筛选，感觉还是不错的，谢谢百度。</p>
<h2 id="腾讯">腾讯</h2>
<p>简历未投</p>
<p>本科时候最想去的公司，小斌今年入职，说老大找他要简历，我考虑到实习时间不够，而且当时阿里面试是“应聘通过”，所以没投，现在想来，甚是后悔。</p>
]]></content>
    <summary type="html"><![CDATA[<p>今年找实习不够顺利，以过去为镜，总结一下自己的一些不足</p>
<p>在简历投递中，我主要是考虑BAT这三家，AT都有熟人可以内推，但A家号称可以实习一个月，而T家一向都是3个月左右，Baidu需要的实习时间就更长了，我只能保证一个月的实习。去年听闻有些师兄乱拿实习offer，然后秋招进入一些公司的黑名单，故我慎之又慎，宁可错过实习，只投了A家。</p>
]]></summary>
    
      <category term="胡言乱语" scheme="http://liaoxl.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
      <category term="求职面试" scheme="http://liaoxl.github.io/tags/%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95/"/>
    
      <category term="生活" scheme="http://liaoxl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello, Hexo! Goodbye, Octopress!]]></title>
    <link href="http://liaoxl.github.io/blog/20140315/hello-world/"/>
    <id>http://liaoxl.github.io/blog/20140315/hello-world/</id>
    <published>2014-03-15T07:45:08.000Z</published>
    <updated>2014-07-15T14:59:12.000Z</updated>
    <content type="html"><![CDATA[<p>最终，从<a href="http://octopress.org/" target="_blank">Octopress</a>迁移到<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a></p>
<p><a href="http://octopress.org/" target="_blank">Octopress</a>有些缺点，让我一直很难以忍受，虽然感觉很<code>Geek</code>，但内心里一直想找个可以代替它的，这些所谓的缺点，事实上大部分都是由于前端引起的，我不是个前端程序员，我不会设计漂亮的前端页面，但我也有自己的品味，不想将就。</p>
<p>先说说我对<a href="http://octopress.org/" target="_blank">Octopress</a>的不满：</p>
<ul>
<li><p>字体太大，仿佛所有用<a href="http://octopress.org/" target="_blank">Octopress</a>框架的，字体都不小，虽然可以调，但调完后在这个框架里又没那么好看了</p>
</li>
<li><p>Tags或Tag Cloud都太丑，我只能勉强看懂这些CSS，这是从<code>github</code>上面用的其它开源插件</p>
</li>
<li><p>所有第三方<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes" target="_blank">主题</a>，我都认真看了一遍，我居然没有找到一款符合我口味的。</p>
</li>
<li><p>右边的<code>SideBar</code>太难看</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><code>code</code>的CSS不好看，超链接不好看……</p>
</li>
<li><p>以上综合，就是看着不舒服</p>
</li>
<li><p>排在最后的，才是为人诟病的生成速度，我并不怎么在乎这点，完全可以泡壶茶慢慢等</p>
</li>
</ul>
<p>如果我是一个优秀的前端程序员，可能我就直接大刀阔斧的往上面修改了，然后继续沿用<a href="http://octopress.org/" target="_blank">Octopress</a>，可惜我不是。<br>我曾在这上面改过，经常的问题就是：好不容易某部分好看了，结果发现与整体的框架不符，显得特别突兀。最终我放弃了修改。</p>
<p>很久之前，我就看到了<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>，那个时候我再看网易开源公开课，正在尝试用用<code>Nodejs</code>，当时不换的原因就是还是没有哪个样式让我觉得特别舒服，直到前一阵子看到<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>的<a href="http://hexo.io/docs/" target="_blank">官网</a>，我觉得官网是很好看的，后来再仔细看了下<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>的<a href="#">github</a>，发现这个博客框架发展很快，居然多了这么多的主题样式，而且看着让我觉得很舒服。</p>
<p>于是抽个周末，就迁移博客了。</p>
<p>从<a href="http://octopress.org/" target="_blank">Octopress</a>迁移到<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>是很容易的事，<a href="http://hexo.io/docs/migration.html" target="_blank">官网</a>就有相应的介绍，事实上，<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>本来就是很简单实用的博客框架，非常值得称赞。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最终，从<a href="http://octopress.org/" target="_blank">Octopress</a>迁移到<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a></p>
<p><a href="http://octopress.org/" target="_blank">Octopress</a>有些缺点，让我一直很难以忍受，虽然感觉很<code>Geek</code>，但内心里一直想找个可以代替它的，这些所谓的缺点，事实上大部分都是由于前端引起的，我不是个前端程序员，我不会设计漂亮的前端页面，但我也有自己的品味，不想将就。</p>
<p>先说说我对<a href="http://octopress.org/" target="_blank">Octopress</a>的不满：</p>
<ul>
<li><p>字体太大，仿佛所有用<a href="http://octopress.org/" target="_blank">Octopress</a>框架的，字体都不小，虽然可以调，但调完后在这个框架里又没那么好看了</p>
</li>
<li><p>Tags或Tag Cloud都太丑，我只能勉强看懂这些CSS，这是从<code>github</code>上面用的其它开源插件</p>
</li>
<li><p>所有第三方<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes" target="_blank">主题</a>，我都认真看了一遍，我居然没有找到一款符合我口味的。</p>
</li>
<li><p>右边的<code>SideBar</code>太难看</p>
</li>
</ul>
]]></summary>
    
      <category term="Hexo" scheme="http://liaoxl.github.io/tags/Hexo/"/>
    
      <category term="Octopress" scheme="http://liaoxl.github.io/tags/Octopress/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二分查找]]></title>
    <link href="http://liaoxl.github.io/blog/20140220/binary-search/"/>
    <id>http://liaoxl.github.io/blog/20140220/binary-search/</id>
    <published>2014-02-20T15:09:00.000Z</published>
    <updated>2014-03-16T06:05:10.000Z</updated>
    <content type="html"><![CDATA[<p>在微博上看到一篇文章，关于二分查找：<a href="http://my.oschina.net/fullofbull/blog/199693" target="_blank">当我写二分查找时，我想些什么</a></p>
<p>于是想到刚看过的《编程珠玑》上的一句话，“90%的人无法正确写出二分查找”</p>
<p>自己动手：</p>
<pre><code><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> n, <span class="built_in">int</span> target)
{
    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>, <span class="built_in">right</span>=n-<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[<span class="built_in">mid</span>] == target) return <span class="built_in">mid</span>;
        <span class="keyword">if</span>(target &gt; A[<span class="built_in">mid</span>]) <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><p>写完了后，去看这篇文章的答案，发现有很多问题，果然也属于那“90%”。<br><a id="more"></a></p>
<p>问题1, 需要对n进行判断，这个属于编程严谨性的问题；第二个问题，程序可以“优化”。</p>
<blockquote><p>我们先来考虑循环的执行步骤。假设我们有一个有着 n 个元素的数组（此处n是一个很大的数值），那么从该数组中第一次找到目标的概率为 1/n（一个很小的数值），下一次（经过一次二分）的概率则是 1/(n/2)——仍然不是很大——以此类推下去。事实上，只有当元素的个数减少到了 10 到 20 的时候，一次找到目标的概率才变得有意义，而对于10 到 20 个元素进行查找需要的只是大概 4 次循环。当查找失败时（在大多数的应用中很普遍），那些额外的测试就将变成纯粹的额外开销。</p>
<p>我们也可以来计算一下，在什么时候找到目标值的概率能接近 50%，但请你扪心自问：在一个复杂度为 O(log2N) 的算法中，对于它的每一步都增添一个额外的复杂计算，而目的仅仅是为了减少最后的几次计算，这样做有意义吗？</p>
</blockquote>


<p>这段话什么意思呢？归根到底就一个意思，如果一个很大的数组中没有我们想要的目标，那么条件判断 if (A[mid] == target) 完全是一个不必要的开销（分支跳转）。实际上，这种条件只要一次就够了，那就是循环终止并判断最终目标的时候。</p>
<p>代码可以改为： </p>
<pre><code><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> n, <span class="built_in">int</span> target)
{
    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>, <span class="built_in">right</span>=n-<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(target &gt; A[<span class="built_in">mid</span>]) <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;
    }
    <span class="keyword">if</span>(<span class="built_in">left</span>&gt;=n || A[<span class="built_in">left</span>]!=target) return -<span class="built_in">left</span>-<span class="number">1</span>;
    return <span class="built_in">left</span>;
}
</code></pre><p>这里注意上面的<code>return -left-1</code>，这行代码在找不到目标时，将目标合适的插入位置输出了，可谓一举两得。</p>
]]></content>
    <summary type="html"><![CDATA[<p>在微博上看到一篇文章，关于二分查找：<a href="http://my.oschina.net/fullofbull/blog/199693" target="_blank">当我写二分查找时，我想些什么</a></p>
<p>于是想到刚看过的《编程珠玑》上的一句话，“90%的人无法正确写出二分查找”</p>
<p>自己动手：</p>
<pre><code><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> n, <span class="built_in">int</span> target)
{
    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>, <span class="built_in">right</span>=n-<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[<span class="built_in">mid</span>] == target) return <span class="built_in">mid</span>;
        <span class="keyword">if</span>(target &gt; A[<span class="built_in">mid</span>]) <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><p>写完了后，去看这篇文章的答案，发现有很多问题，果然也属于那“90%”。<br>]]></summary>
    
      <category term="算法/数据结构" scheme="http://liaoxl.github.io/tags/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[点集的一些几何特征]]></title>
    <link href="http://liaoxl.github.io/blog/20140219/dian-ji/"/>
    <id>http://liaoxl.github.io/blog/20140219/dian-ji/</id>
    <published>2014-02-18T16:10:00.000Z</published>
    <updated>2014-03-16T06:04:56.000Z</updated>
    <content type="html"><![CDATA[<p>点集有很多特征，这里提到的有：最小凸包，最小外接矩形，最大内接三角形，最大内接四边形。</p>
<p>编程里面，如何求取点集的这些特征呢？</p>
<h3 id="预处理知识">预处理知识</h3>
<ul>
<li>对于三个点，p0,p1,p2，如何判断以p0为中心，p0p1到p0p2是顺时针还是逆时针？</li>
</ul>
<p>求向量p0p2与p0p1的叉积，若大于0,则说明是p0p2在p0p1的顺时针方向，若小于0，则说明p0p2在p0p1的逆时针方向。</p>
<a id="more"></a>


<h3 id="最小凸包">最小凸包</h3>
<h4 id="Graham栈扫描法。">Graham栈扫描法。</h4>
<p>这里有一篇<a href="http://blog.csdn.net/suwei19870312/article/details/5422818" target="_blank">博客</a>对此有比较详细的讨论，并给出比较好的伪代码，这里借鉴一下。</p>
<p>平面上有n个点p0,p1,p2,p3,…,pn，求其最小凸包</p>
<pre><code>GRAHAM-SCAN(Q)
{
     <span class="number">1</span>. 取出所有点钟<span class="keyword">y</span>坐标最小的点作为初始点p<span class="number">0</span>（如果有<span class="keyword">y</span>坐标相同的，选择<span class="keyword">x</span>坐标最小的）
     <span class="number">2</span>. 之后对于所有其他点，以p<span class="number">0</span>为中心，点集中的所有点按关于p<span class="number">0</span>的极角逆时针排序,形成p1,p2,..pn-<span class="number">1</span>（如果有极角重合，保存最远的点）
     <span class="number">3</span>. <span class="keyword">push</span>(p<span class="number">0</span>,S) 
     <span class="number">4</span>. <span class="keyword">push</span>(p1,S)
     <span class="number">5</span>. <span class="keyword">push</span>(P2.S)
     <span class="keyword">for</span>(i: <span class="number">3</span>-&gt;<span class="keyword">m</span>)
     {     
           px = nexttoTop(S)
           py = Top(S) 
           <span class="keyword">do</span> <span class="keyword">while</span> (如果(py-&gt;pi向量)相对于(px-&gt;py向量)是顺时针的)
                     <span class="keyword">pop</span>(S)
                     px = nextotTop(S)
                     py = Top(S)
           <span class="keyword">push</span>(pi, S);
     }
     <span class="keyword">return</span> S;
}
</code></pre><h3 id="最小外接矩形">最小外接矩形</h3>
<p>在上述最小凸包的基础上，进行求取，最小外接矩形</p>
<p>这里就是开始<em>旋转卡壳</em>思想的应用。</p>
<p>首先有一个前提，也是可以证明的，<em>凸包的最小外接矩形，至少有一条边与凸包的一条边重合</em>，这点是可以证明的，但过程比较复杂。</p>
<p>在这个前提下，就可以通过下列为代码进行求解了：</p>
<pre><code><span class="constant">MinRec</span>(<span class="constant">Q</span>)
{
    <span class="constant">Rec</span>=<span class="constant">MAXINT</span>
    <span class="keyword">for</span> i=<span class="number">0</span><span class="symbol">:n</span>
        <span class="constant">Pick</span> pipi+<span class="number">1</span> 作为矩形的一条边
        依次找投影在这条边上最左边/最右边以及距此边最远的点，作出矩形
        计算面积<span class="constant">Si_i</span>+<span class="number">1</span>,如果<span class="constant">Si_i</span>+<span class="number">1</span>&lt;<span class="constant">Rec</span>，则 <span class="constant">Rec</span>=<span class="constant">Si_i</span>+<span class="number">1</span>，并记录该边与另外三点
    <span class="keyword">end</span>
}
</code></pre><p>上述求解过程，还可以优化。</p>
<p>在找 最左边/最右边/最远 的三点时，对于固定一条边pipi+1而言，从点pi+2逆时针一直找到pi-1，点到边的距离都是先增大，再减小，在该边上最左边/最右边的投影也是先增大后减小的。所以，保存这三点后，下一次计算，找最左边/最右边/最远 的三点时，就可以分别以上次找到的三点为起点，进行寻找。这里可以减去很多计算。</p>
<h3 id="最大内接三角形">最大内接三角形</h3>
<p>最大内接三角形 同样应用 <em>旋转卡壳</em> 的思想</p>
<pre><code>MaxTrangle(Q)
{
    选p0,p1,p2三点，构成三角形；
    <span class="number">1</span>, 固定p0,p1，移动p2，找到能构成的最大三角形p0p1p2<span class="string">'；
    2, 固定p0p2'</span>，移动p1，找到能构成的最大三角形p0p1<span class="string">'p2'</span>；
    <span class="number">3</span>, 固定p1<span class="string">'p2'</span>，移动p0,找到能构成的最大三角形p0<span class="string">'p1'</span>p2<span class="string">'；
    重复1～3，直至三角形面积不再增大
}</span>
</code></pre><h3 id="最大内接四边形">最大内接四边形</h3>
<p>最大内接四边形， 同样应用 <em>旋转卡壳</em> 的思想</p>
<pre><code>MaxSquare(Q)
<span class="cell">{
    选p0,p1,p2,p3三点，构成三角形；
    <span class="number">1</span>, 固定p0,p1,p2，移动p3，找到能构成的最大四边形p0p1p2p3<span class="string">'；
    2, 固定p0,p1,p3'</span>，移动p2，找到能构成的最大四边形p0p1p2<span class="string">'p3'</span>；
    <span class="number">3</span>, 固定p0,p2<span class="string">',p3'</span>，移动p1,找到能构成的最大四边形p0p1<span class="string">'p2'</span>p3<span class="string">'；
    4, 固定p1'</span>,p2<span class="string">',p3'</span>，移动p0,找到能构成的最大四边形p0<span class="string">'p1'</span>p2<span class="string">'p3'</span>；
    重复<span class="number">1</span>～<span class="number">4</span>，直至四边形面积不再增大
}</span>
</code></pre><p>旋转卡壳的思想在求点集的集合特征上有较为广泛的应用，在求得凸包的基础上，可以方便的求取最小外接矩形/最大内接三角形/最大内接四边形。</p>
<p>当然，以上都是伪代码，具体实现，还有一些边界条件得注意。</p>
]]></content>
    <summary type="html"><![CDATA[<p>点集有很多特征，这里提到的有：最小凸包，最小外接矩形，最大内接三角形，最大内接四边形。</p>
<p>编程里面，如何求取点集的这些特征呢？</p>
<h3 id="预处理知识">预处理知识</h3>
<ul>
<li>对于三个点，p0,p1,p2，如何判断以p0为中心，p0p1到p0p2是顺时针还是逆时针？</li>
</ul>
<p>求向量p0p2与p0p1的叉积，若大于0,则说明是p0p2在p0p1的顺时针方向，若小于0，则说明p0p2在p0p1的逆时针方向。</p>
]]></summary>
    
      <category term="算法/数据结构" scheme="http://liaoxl.github.io/tags/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[马年——祝自己顺利]]></title>
    <link href="http://liaoxl.github.io/blog/20140201/ma-nian/"/>
    <id>http://liaoxl.github.io/blog/20140201/ma-nian/</id>
    <published>2014-01-31T21:58:00.000Z</published>
    <updated>2014-03-16T06:04:47.000Z</updated>
    <content type="html"><![CDATA[<p>我是个拖延症患者，原本想在除夕晚上写点什么，后来拖到初一，再后来到了今天</p>
<p>今天起得很早，向来年初二都是要早起，然后去 <a href="#">敬神</a>，也就是祭拜祖宗</p>
<p>今年是重要的一年，我常用的邮箱<a href="#">liaoxl2012@gmail.com</a>后面加的2012，本意就是想指我2012年毕业，那是我大三找实习时候开始用的一个邮箱。没想到后来读研了，今年又是这样的一年，我应该换成2015了。</p>
<p>昨儿出去，见了<a href="#">小斌</a>, <a href="#">水哥</a>, <a href="#">黄鹏</a>,<a href="#">国平</a>, 水哥是多年挚交，但所学是医学，专业方面交集倒是并不多，小斌，黄鹏，国平分别签了腾讯，网易游戏，阿里云，都是国内一等一的工作offer了，着实让人佩服。</p>
<a id="more"></a>

<p>今年是我找工作的一年，虽然去年看到他们找工作或者学习上的一些难熬时刻，但毕竟都已经过去了。而我，正在等待这些的来临，我向来运气不太好，往往越想实现的，哪怕自己很努力，但终归会缺点运气，以至最终失之交臂，或需曲折蜿蜒才能得到。</p>
<p>时间过得真快，蛇年转眼即过。我特地看了一下日历，大约2.10号是蛇年的初一，现在是1.31号是马年的初一，而羊年的初一将是2.19号。算是过了一个相对短一点的一年，迎来了一个长的年。</p>
<p>研究生的两个目标，一个是发文章，另一个是找个好工作，都看今年了</p>
<p>祝自己马年顺利吧！</p>
]]></content>
    <summary type="html"><![CDATA[<p>我是个拖延症患者，原本想在除夕晚上写点什么，后来拖到初一，再后来到了今天</p>
<p>今天起得很早，向来年初二都是要早起，然后去 <a href="#">敬神</a>，也就是祭拜祖宗</p>
<p>今年是重要的一年，我常用的邮箱<a href="#">liaoxl2012@gmail.com</a>后面加的2012，本意就是想指我2012年毕业，那是我大三找实习时候开始用的一个邮箱。没想到后来读研了，今年又是这样的一年，我应该换成2015了。</p>
<p>昨儿出去，见了<a href="#">小斌</a>, <a href="#">水哥</a>, <a href="#">黄鹏</a>,<a href="#">国平</a>, 水哥是多年挚交，但所学是医学，专业方面交集倒是并不多，小斌，黄鹏，国平分别签了腾讯，网易游戏，阿里云，都是国内一等一的工作offer了，着实让人佩服。</p>
]]></summary>
    
      <category term="胡言乱语" scheme="http://liaoxl.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
      <category term="生活" scheme="http://liaoxl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++的虚析构函数]]></title>
    <link href="http://liaoxl.github.io/blog/20131205/virtual-destructor/"/>
    <id>http://liaoxl.github.io/blog/20131205/virtual-destructor/</id>
    <published>2013-12-05T11:16:00.000Z</published>
    <updated>2014-03-16T06:04:30.000Z</updated>
    <content type="html"><![CDATA[<p>C++是门神奇的语言，总是有一些不能以我们“程序员”编写它的角度去理解的问题，究其根本，大多都是C++编译器在“适当”的时候，会自动为我们的程序增加或删除一些东西，如果其编译器所做的改动，与我们预期的结果并不相关，自然我们也能得到较好理解的运行结果，然而，深入学习C++之后，就会发现，其中很多特性，必须要掌握，必须要知道编译器做了哪些东西，才能保证程序的正确执行。</p>
<p>C++类的构造，析构函数是C++编译器在编译的过程中，所作“适当”修改的主要场所</p>
<a id="more"></a>

<p>不扯远，在类继承中，一般类的析构函数都要被定义成虚函数，或者必须要定义成虚函数，这是为什么呢？</p>
<p>看如下两个类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>class Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2) {}
        ~Point2d(){}

        <span class="keyword">int</span> x;
        <span class="keyword">int</span> y;
};

class Point3d : <span class="keyword">public</span> Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point3d</span>():<span class="title">z</span>(3){}
        ~Point3d(){}

        <span class="keyword">int</span> z;
};
</pre></td></tr></table></figure>

<p>这上面<code>Point3d</code>是由基类<code>Point2d</code>派生出来的，C++有个特点，可以用基类的指针指向派生类，即派生类可以用基类指针<code>new</code>出来</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">Point2d* pt2d</span>=<span class="string">new Point3d();</span>
</pre></td></tr></table></figure>

<p>至于为什么能这样<code>new</code>，我想应该是<code>new</code>出来的空间比基类指针所能访问到的空间更大，所以认为是“安全”的，基于这个理念，派生类指针是不能<code>new</code>基类的，因为会产生“不安全”的访问。</p>
<p>通过看了《深度探索C++对象模型》，来解释一下上述一行式子中，编译器究竟做了什么事：</p>
<p>1,产生一个指向<code>Point2d</code>的指针，<code>pt2d</code>;<br>2,生成一个<code>Point3d</code>的类；<br>3,将<code>Point3d</code>产生的地址赋值给一个指向<code>Point2d</code>的指针</p>
<p>以上的解释比较直白，甚至可以说是“无用”的</p>
<p>将它们细化，第一步没什么好说的，第二步中，生成一个<code>Point3d</code>的类，派生类中的构造函数是如何执行呢？分为以下几步：</p>
<p>1）先调用基类的构造函数，其实在编译器中，是将基类的构造函数嵌入到派生类的构造函数中；</p>
<p>2）如果有虚函数表，将虚函数表重新绑定；</p>
<p>3）执行当前的构造函数，产生一个派生类。</p>
<p>为了验证这一过程，可以在构造函数写出输出函数，看是否这样，如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="comment">/*
 * con_des.cpp
 * Copyright (C) 2013 moondark &lt;liaoxl2012@gmail.com&gt;
 *
 * Distributed under terms of the MIT license.
 */</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using</span> namespace std;

class Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2)
        {
            cout &lt;&lt; <span class="string">"Point2d Constructor!"</span> &lt;&lt; endl;
        }
        
        ~Point2d(){}

        <span class="keyword">int</span> x;
        <span class="keyword">int</span> y;
};

class Point3d : <span class="keyword">public</span> Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point3d</span>():<span class="title">z</span>(3)
        {
            cout &lt;&lt; <span class="string">"Point3d Constructor!"</span> &lt;&lt; endl;
        }
        ~Point3d(){}

        <span class="keyword">int</span> z;
}; 

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])
{
    
    Point2d* pt2d=<span class="keyword">new</span> Point3d();
    delete pt2d;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>可见，输出是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Point2d <span class="function"><span class="keyword">Constructor</span>!
<span class="title">Point3d</span> <span class="title">Constructor</span>!</span>
</pre></td></tr></table></figure>

<p>将第二步分解了，那么它又是如何执行第三步呢？</p>
<p>由第二步知道，在派生类中，包含着一个已经构造出来的基类，这个基类在原来的基础上，只是虚函数表做了更改，重新绑定了派生类的函数。而这个<code>Point2d</code>的指针，就是指向派生类的基类实体。</p>
<p>如本文标题所写，要讨论的是为什么是虚析构函数？</p>
<p>在上文中的那段完整可执行代码中，如果你在析构函数也添加打印信息，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>class Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2)
        {
            cout &lt;&lt; <span class="string">"Point2d Constructor!"</span> &lt;&lt; endl;
        }
        
        ~Point2d()
        {
            cout &lt;&lt; <span class="string">"Point2d Destructor!"</span> &lt;&lt; endl;
        }

        <span class="keyword">int</span> x;
        <span class="keyword">int</span> y;
};

class Point3d : <span class="keyword">public</span> Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point3d</span>():<span class="title">z</span>(3)
        {
            cout &lt;&lt; <span class="string">"Point3d Constructor!"</span> &lt;&lt; endl;
        }
        ~Point3d()
        {
            cout &lt;&lt; <span class="string">"Point3d Destructor!"</span> &lt;&lt; endl;
        }

        <span class="keyword">int</span> z;
};
</pre></td></tr></table></figure>

<p>重新运行上述代码，则发现<code>delete</code>操作只促发了基类的的析构函数，并未调用派生类的析构函数，于是就产生了问题！</p>
<p>众所周知，析构函数的作用，就是在销毁对象时“合适”的处理一些信息，其实说白了就是擦屁股。</p>
<p>而虚函数的作用，就是可以动态绑定，比如我在基类定义了一个虚函数<code>virtual show()</code>，那么如果我在派生类重写了这个函数，则这时用上述基类指针<code>new</code>出派生类来之后，<code>pt2d</code>访问<code>show</code>函数，实际是派生类的，为何？因为在构造的时候进行重新绑定，按照这个思想，我们应该对基类的析构函数定义为虚函数，这样<code>delete</code>的时候，就是调用派生类的析构函数了。</p>
<p>于是，理所当然，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>class Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2)
        {
            cout &lt;&lt; <span class="string">"Point2d Constructor!"</span> &lt;&lt; endl;
        }
        
        <span class="keyword">virtual</span> ~Point2d()
        {
            cout &lt;&lt; <span class="string">"Point2d Destructor!"</span> &lt;&lt; endl;
        }

        <span class="keyword">int</span> x;
        <span class="keyword">int</span> y;
};

class Point3d : <span class="keyword">public</span> Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point3d</span>():<span class="title">z</span>(3)
        {
            cout &lt;&lt; <span class="string">"Point3d Constructor!"</span> &lt;&lt; endl;
        }
        ~Point3d()
        {
            cout &lt;&lt; <span class="string">"Point3d Destructor!"</span> &lt;&lt; endl;
        }

        <span class="keyword">int</span> z;
};
</pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Point2d <span class="function"><span class="keyword">Constructor</span>!
<span class="title">Point3d</span> <span class="title">Constructor</span>!
<span class="title">Point3d</span> <span class="title">Destructor</span>!
<span class="title">Point2d</span> <span class="title">Destructor</span>!</span>
</pre></td></tr></table></figure>

<p>哇，它正常先调用了派生类的析构函数，再调用基类的析构函数，完全销毁了对象，没有内存泄漏之类的问题诶！</p>
<p>但是，我当时就思考一个问题，如果是虚函数，一般情况下，派生类重写了虚函数，则它只调用派生类的虚函数，而不调用基类的虚函数，但这里却调用了基类的虚函数，这是为什么呢？</p>
<p>记得前面讲了构造函数的生成对象的3个主要步骤，通过阅读《深度探索C++对象模型》就能够了解到，析构函数的行为，在顺序上，是与构造函数相反的，即：</p>
<p>1）执行当前析构函数;</p>
<p>2）重新解绑定虚函数表；</p>
<p>3）调用基类的析构函数</p>
<p>这里最重要的是2，它重新解绑定了虚函数表，这样派生类的析构函数才能找到基类的析构函数，从而能够正确完成程序的功能！</p>
<p>听起来很奇妙！</p>
<p>实际中，基类（如果有派生类）的析构函数往往都定义成虚函数。</p>
<p>接下来就还有个小问题：为何构造函数不能定义为虚函数呢？</p>
<p>前面提到过，构造函数有个过程是绑定虚函数表，如果构造函数定义为虚函数，这个虚函数表该如何生成？如何绑定？对象还没完成构造，如何动态绑定虚函数表！</p>
<p>以上是个人觉得对虚析构函数机制的深入了解。</p>
]]></content>
    <summary type="html"><![CDATA[<p>C++是门神奇的语言，总是有一些不能以我们“程序员”编写它的角度去理解的问题，究其根本，大多都是C++编译器在“适当”的时候，会自动为我们的程序增加或删除一些东西，如果其编译器所做的改动，与我们预期的结果并不相关，自然我们也能得到较好理解的运行结果，然而，深入学习C++之后，就会发现，其中很多特性，必须要掌握，必须要知道编译器做了哪些东西，才能保证程序的正确执行。</p>
<p>C++类的构造，析构函数是C++编译器在编译的过程中，所作“适当”修改的主要场所</p>
]]></summary>
    
      <category term="C/C++" scheme="http://liaoxl.github.io/tags/C/C++/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Image Cosegmentation by Co-Diffusion]]></title>
    <link href="http://liaoxl.github.io/blog/20131204/coseg/"/>
    <id>http://liaoxl.github.io/blog/20131204/coseg/</id>
    <published>2013-12-04T15:51:00.000Z</published>
    <updated>2014-03-16T06:04:18.000Z</updated>
    <content type="html"><![CDATA[<p>这算是大半年来的结果吧，从今年4月份一直做到10月份，有很多很多的尝试，虽然最终在理论上并未有很大的创新，实验结果却比较给力。</p>
<p>协同分割，即不仅要完成分割，而且要将不同图像的分割结果进行“归类”行为</p>
<p>写出了一篇像模像样的paper，正在赶投各种Journal，不知终归何处</p>
<p>看看实验的效果图吧，最好的肯定是我做出来的，哈哈</p>
<a id="more"></a>

<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_co-contra1_%e5%89%af%e6%9c%ac.png" alt="co-contra1"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_co-contrao2-4_%e5%89%af%e6%9c%ac.png" alt="co-contra2"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_co-contraw2-4_%e5%89%af%e6%9c%ac.png" alt="co-contra3"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_cows_%e5%89%af%e6%9c%ac.jpg" alt="cows"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_flowers_%e5%89%af%e6%9c%ac.png" alt="flowers"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_Kendo-EKC4_%e5%89%af%e6%9c%ac.png" alt="kendo-ekc"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_skating1_%e5%89%af%e6%9c%ac.png" alt="skating"></p>
<p>当然，所得到的方法还有很多短板，需要改进，不过暂时没有太多的思路。</p>
]]></content>
    <summary type="html"><![CDATA[<p>这算是大半年来的结果吧，从今年4月份一直做到10月份，有很多很多的尝试，虽然最终在理论上并未有很大的创新，实验结果却比较给力。</p>
<p>协同分割，即不仅要完成分割，而且要将不同图像的分割结果进行“归类”行为</p>
<p>写出了一篇像模像样的paper，正在赶投各种Journal，不知终归何处</p>
<p>看看实验的效果图吧，最好的肯定是我做出来的，哈哈</p>
]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="图像处理" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Cosegmentation" scheme="http://liaoxl.github.io/tags/Cosegmentation/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[尝试hadoop的单机环境搭建]]></title>
    <link href="http://liaoxl.github.io/blog/20131201/hadoop/"/>
    <id>http://liaoxl.github.io/blog/20131201/hadoop/</id>
    <published>2013-12-01T11:34:00.000Z</published>
    <updated>2014-03-16T06:03:50.000Z</updated>
    <content type="html"><![CDATA[<p>近来关注大数据，云计算等相关技术，把Google的三大论文看了一遍，作为非计算机科班的同学，看得有点云里雾里，看了不少书才略微理清楚现在这些流行的大数据框架之间的关系。</p>
<p>Hadoop便是其中一个非常吸引我的框架，打算对其环境进行配置，其中走了不少弯路，想写点记录一下。</p>
<a id="more"></a>

<p>首先，要讨论的是OpenJDK与SunJDK，网上的大堆教程基本都是清一色的要安装SunJDK，为何呢？因为JDK的开源版在1.6.0版本之前，与SunJDK还有一些不同，不能很好的支持hadoop，但在1.6.0版本之后，就可以很好的支持了。</p>
<p>为何要提到这个呢？因为很多系统默认装的就是OpenJDK，如果换成SunJDK，可能会麻烦很多，当然，你可以在有OpenJDK的情况下依旧装上SunJDK，用<a href="#">alternative</a>命令来设置版本，显然这样麻烦许多。比如我对我的linux分盘不够大，我不希望资源被浪费，所以我只愿意安装其中一种。</p>
<p>这里提一下我所走的弯路，我首先卸载了OpenJDK（用不考虑依赖关系的命令），装上SunJDK之后，我又知道了其实OpenJDK不影响，于是我删了SunJDK，重新装了OpenJDK （我是不是太折腾了）</p>
<p>其次，要设置好Java的环境变量，<code>vim /etc/profile</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment"># SET JAVA Environment OpenJDK</span>
<span class="constant">JAVA_HOME</span>=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">1.7</span>.<span class="number">0</span>-openjdk/
<span class="constant">JRE_HOME</span>=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">1.7</span>.<span class="number">0</span>-openjdk/
<span class="constant">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:</span><span class="variable">$JAVA_HOME</span>/<span class="symbol">bin:</span><span class="variable">$JRE_HOME</span>/bin
<span class="constant">CLASSPATH</span>=.<span class="symbol">:</span><span class="variable">$JAVA_HOME</span>/lib/dt.<span class="symbol">jar:</span><span class="variable">$JAVA_HOME</span>/lib/tools.<span class="symbol">jar:</span><span class="variable">$JRE_HOME</span>/lib
export <span class="constant">JAVA_HOME</span> <span class="constant">JRE_HOME</span> <span class="constant">PATH</span> <span class="constant">CLASSPATH</span>
</pre></td></tr></table></figure>

<p>然后，ssh，其实这个我早就安装了。SSH有什么作用呢？一般我们相互访问，都需要输入口令，而SSH则产生一个钥匙，这个钥匙可以自动作为具有访问权限的标识，我们就不需要再去手动的输入命令了，然程序自动调用这个钥匙去开锁吧（这样解释应该是对的吧）</p>
<p>最后，就是hadoop了，可分为几个步骤来讲解</p>
<p>1）添加组和用户：其实这个步骤未必一定需要，但为了计算产生的各种数据不要“污染”你自个的用户区，就建一个账户专门来处理吧。而且，如果是集群的，为了更好编号什么的，一般创建一个易于管理识别的账户。</p>
<p>账户和组的创建可以自己探索了，ubuntu和fedora是不一样的，但都比较容易，注意要添加sudo权限</p>
<p>2）解压hadoop的包，假设创建的用户为<code>hadoop</code>，解压至<code>/home/hadoop/hadoop</code>文件夹下，然后设置hadoop的环境变量，同样<code>vim /etc/profile</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment"># SET For HADOOP</span>
<span class="keyword">export</span> HADOOP_DEV_HOME=/home/hadoop/hadoop
<span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_DEV_HOME</span>/bin
<span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_DEV_HOME</span>/sbin
<span class="keyword">export</span> HADOOP_MAPARED_HOME=<span class="variable">${HADOOP_DEV_HOME}</span>
<span class="keyword">export</span> HADOOP_COMMON_HOME=<span class="variable">${HADOOP_DEV_HOME}</span>
<span class="keyword">export</span> HADOOP_HDFS_HOME=<span class="variable">${HADOOP_DEV_HOME}</span>
<span class="keyword">export</span> YARN_HOME=<span class="variable">${HADOOP_DEV_HOME}</span>
<span class="keyword">export</span> HADOOP_CONF_DIR=<span class="variable">${HADOOP_DEV_HOME}</span>/etc/hadoop
</pre></td></tr></table></figure>

<p>记住这里改完，应该以hadoop用户身份，进行source，才会生效</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">source</span> /etc/profile
</pre></td></tr></table></figure>

<p>3）配置xml文件<br>需要配置的xml文件包括：<code>core-site.xml</code>, <code>hdfs-site.xml</code>, <code>mapred-site.xml</code>(这个好似没有这个文件，有个文件叫做mapred-site.xml.template吧，拷贝一个并命名为mapred-site.xml), <code>yarn-site.xml</code><br>这四个xml的作用目前我还不是特别清楚，看起来像是部署数据存取的位置以及node的命名，如下配置：（注：上面类似：file:/home/hadoop/dfs/name的目录我都手动创建了，不知运行时它会否自动创建）</p>
<p>core-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://localhost:8020<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;<span class="title">description</span>&gt;</span> The name of the default file system<span class="tag">&lt;/<span class="title">description</span>&gt;</span>
        <span class="tag">&lt;<span class="title">final</span>&gt;</span>true<span class="tag">&lt;/<span class="title">final</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>hdfs-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>&lt;configuration&gt;
    &lt;<span class="keyword">property</span>&gt;
        &lt;<span class="property">name</span>&gt;dfs.namenode.<span class="property">name</span>.dir&lt;/<span class="property">name</span>&gt;
        &lt;value&gt;<span class="type">file</span>:/home/hadoop/dfs/<span class="property">name</span>&lt;/value&gt;
        &lt;description&gt;Determines <span class="keyword">where</span> <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> <span class="keyword">local</span> filesystem <span class="keyword">the</span> DFS <span class="property">name</span> node should store <span class="keyword">the</span> <span class="property">name</span> table. If this <span class="keyword">is</span> a comma-delimited <span class="type">list</span> <span class="keyword">of</span> directories <span class="keyword">then</span> <span class="keyword">the</span> <span class="property">name</span> table <span class="keyword">is</span> replicated <span class="keyword">in</span> all <span class="keyword">of</span> <span class="keyword">the</span> directories, <span class="keyword">for</span> redundancy. &lt;/description&gt;
        &lt;final&gt;<span class="constant">true</span>&lt;/final&gt;
    &lt;/<span class="keyword">property</span>&gt;

    &lt;<span class="keyword">property</span>&gt;
        &lt;<span class="property">name</span>&gt;dfs.datanode.data.dir&lt;/<span class="property">name</span>&gt;
        &lt;value&gt;<span class="type">file</span>:/home/hadoop/dfs/data&lt;/value&gt;
        &lt;description&gt;Determines <span class="keyword">where</span> <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> <span class="keyword">local</span> filesystem an DFS data node should store <span class="keyword">its</span> blocks. If this <span class="keyword">is</span> a comma-delimited <span class="type">list</span> <span class="keyword">of</span> directories, <span class="keyword">then</span> data will be stored <span class="keyword">in</span> all named directories, typically <span class="function_start"><span class="keyword">on</span></span> different devices.Directories <span class="keyword">that</span> do <span class="keyword">not</span> exist are ignored
        &lt;/description&gt;
        &lt;final&gt;<span class="constant">true</span>&lt;/final&gt;
    &lt;/<span class="keyword">property</span>&gt;

    &lt;<span class="keyword">property</span>&gt;
        &lt;<span class="property">name</span>&gt;dfs.replication&lt;/<span class="property">name</span>&gt;
        &lt;value&gt;<span class="number">1</span>&lt;/value&gt;
    &lt;/<span class="keyword">property</span>&gt;

    &lt;<span class="keyword">property</span>&gt;
        &lt;<span class="property">name</span>&gt;dfs.permissions&lt;/<span class="property">name</span>&gt;
        &lt;value&gt;<span class="constant">false</span>&lt;/value&gt;
    &lt;/<span class="keyword">property</span>&gt;
&lt;/configuration&gt;
</pre></td></tr></table></figure>

<p>mapred-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.system.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:/home/hadoop/mapred/system<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;<span class="title">final</span>&gt;</span>true<span class="tag">&lt;/<span class="title">final</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.local.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:/home/hadoop/mapred/local<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;<span class="title">final</span>&gt;</span>true<span class="tag">&lt;/<span class="title">final</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>yarn-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>

<span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>org.apache.hadoop.mapred ShuffleHandler<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>4）修改hadoop-env.sh, <code>vim /home/hadoop/hadoop/etc/hadoop/hadoop-env.sh</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment"># export JAVA_HOME=${JAVA_HOME}</span>
export <span class="constant">JAVA_HOME</span>=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">1.7</span>.<span class="number">0</span>-openjdk/
</pre></td></tr></table></figure>

<p>5）测试</p>
<p>格式化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>hdfs namenode -<span class="built_in">format</span>
</pre></td></tr></table></figure>

<p>如果出现<code>EXIT 0</code>，说明（应该）成功了</p>
<p>启动DFS</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>hadoop-daemon.sh <span class="operator"><span class="keyword">start</span> namenode
hadoop-daemon.sh <span class="keyword">start</span> datanode</span>
</pre></td></tr></table></figure>

<p>使用jps查看进程是否启动（会显示namenode和datanode）<br>jps类似于一个进程查看器，即查看JVM中的当前进程，这些进程的启动都会有log，可以直接去看log看有否启动成功。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>jps
</pre></td></tr></table></figure>

<p>可以访问这个网页</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="label">http:</span>//localhost:<span class="number">50070</span>/dfshealth<span class="preprocessor">.jsp</span>
</pre></td></tr></table></figure>

<p>关闭DFS</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>hadoop-daemon.sh <span class="keyword">stop</span> namenode
hadoop-daemon.sh <span class="keyword">stop</span> datanode
</pre></td></tr></table></figure>

<hr>
<h3 id="EOF">EOF</h3>
<p>关于对hadoop的尝试先就到这吧</p>
]]></content>
    <summary type="html"><![CDATA[<p>近来关注大数据，云计算等相关技术，把Google的三大论文看了一遍，作为非计算机科班的同学，看得有点云里雾里，看了不少书才略微理清楚现在这些流行的大数据框架之间的关系。</p>
<p>Hadoop便是其中一个非常吸引我的框架，打算对其环境进行配置，其中走了不少弯路，想写点记录一下。</p>
]]></summary>
    
      <category term="hadoop" scheme="http://liaoxl.github.io/tags/hadoop/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 与 系统剪贴板clipboard]]></title>
    <link href="http://liaoxl.github.io/blog/20131117/vim-clipboard/"/>
    <id>http://liaoxl.github.io/blog/20131117/vim-clipboard/</id>
    <published>2013-11-17T06:41:00.000Z</published>
    <updated>2014-03-16T06:03:38.000Z</updated>
    <content type="html"><![CDATA[<p>在fedora 17下，刚开始不太习惯vim的时候，也没发现默认装的vim不能使用系统剪贴板这个问题，后来用多了，发现居然不能从vim复制到系统剪贴板，刚开始我还以为我快捷键使用的不对，但试过多次，均不成功。于是乎，在vim中想复制就必须用gedit打开，然后用鼠标类似windows的操作来完成复制操作，对于常用文件夹可能还不觉得有多么烦，但有些路径深的，那就实在是非常不爽！！</p>
<p>命令那么简单，怎么会搞错呢？后来我才发现，原来系统自带的（我的要么是一安装就有，要么就是我用yum安装的）是不具备这个功能的，即<code>&quot;+y</code>不适应。怎样查看自己的vim版本是否支持系统剪贴板呢？通过以下命令，如果<code>clipboard</code>前面是个减号，则说明系统编译时候未加入clipboard这个选项</p>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>[moondark@Moondark ~]$ vim --version|grep <span class="built_in"><span class="keyword">clipboard</span></span>
-<span class="built_in"><span class="keyword">clipboard</span></span>       +iconv           +path_extra      -toolbar
+eval            +mouse_dec       +startuptime     -xterm_clipboard
</pre></td></tr></table></figure>

<p>很显然解决这个问题有个很直接的方法：<strong>重编译支持系统剪贴板的Vim</strong></p>
<p>然而我就觉得很不爽，想找个不重新编译就能解决的方法，这个时候我想到了我之前试过的一个命令行复制工具<code>xclip</code>，用它配合vim就能够实现使用系统剪贴板了。在网上看到有人说<code>xclip</code>会因为<code>detach</code>在关闭vim后失效，用<code>xsel</code>会更好，我目前还没接触到，所以就先使用这个先吧，具体命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>" \c                  复制至公共剪贴板
vmap <span class="tag">&lt;<span class="title">leader</span>&gt;</span>c :!xclip -selection clipboard<span class="tag">&lt;<span class="title">CR</span>&gt;</span>u
</pre></td></tr></table></figure>

<p>我是将复制命令映射到<code>\c</code>上了，这个可以自定义，目前用着还觉得挺方便的。</p>
<p>更多关于我的vim配置，可见我的<a href="https://github.com/liaoxl/dotfiles" target="_blank">dotfiles</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>在fedora 17下，刚开始不太习惯vim的时候，也没发现默认装的vim不能使用系统剪贴板这个问题，后来用多了，发现居然不能从vim复制到系统剪贴板，刚开始我还以为我快捷键使用的不对，但试过多次，均不成功。于是乎，在vim中想复制就必须用gedit打开，然后用鼠标类似windows的操作来完成复制操作，对于常用文件夹可能还不觉得有多么烦，但有些路径深的，那就实在是非常不爽！！</p>
<p>命令那么简单，怎么会搞错呢？后来我才发现，原来系统自带的（我的要么是一安装就有，要么就是我用yum安装的）是不具备这个功能的，即<code>&quot;+y</code>不适应。怎样查看自己的vim版本是否支持系统剪贴板呢？通过以下命令，如果<code>clipboard</code>前面是个减号，则说明系统编译时候未加入clipboard这个选项</p>
]]></summary>
    
      <category term="Vim" scheme="http://liaoxl.github.io/tags/Vim/"/>
    
      <category term="Xclip" scheme="http://liaoxl.github.io/tags/Xclip/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Graphcuts 与 Kmeans]]></title>
    <link href="http://liaoxl.github.io/blog/20131116/graphcuts-kmeans/"/>
    <id>http://liaoxl.github.io/blog/20131116/graphcuts-kmeans/</id>
    <published>2013-11-16T10:30:00.000Z</published>
    <updated>2014-03-16T06:03:18.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    
    
      <category term="最大流" scheme="http://liaoxl.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="Kmeans" scheme="http://liaoxl.github.io/tags/Kmeans/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Frequency Tuned Saliency]]></title>
    <link href="http://liaoxl.github.io/blog/20131109/frequency-tuned-saliency/"/>
    <id>http://liaoxl.github.io/blog/20131109/frequency-tuned-saliency/</id>
    <published>2013-11-09T12:03:00.000Z</published>
    <updated>2014-03-16T06:02:57.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ivrgwww.epfl.ch/supplementary_material/RK_CVPR09/Images/SaliencyIntro.jpg" alt="Introduction"></p>
<p>在近年来，图像相关的会议或者杂志中，炒的比较热的一个词是：<strong>显著性</strong>！</p>
<h3 id="何谓显著性？">何谓显著性？</h3>
<p>顾名思义，显著性就是指不同于一般性质的一种表现，通常它都是不好量化衡量的。</p>
]]></content>
    
    
      <category term="Saliency" scheme="http://liaoxl.github.io/tags/Saliency/"/>
    
      <category term="图像处理" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[刷完leetcode的一点感想]]></title>
    <link href="http://liaoxl.github.io/blog/20131102/shua-wan-leetcode/"/>
    <id>http://liaoxl.github.io/blog/20131102/shua-wan-leetcode/</id>
    <published>2013-11-02T10:47:00.000Z</published>
    <updated>2014-03-16T06:02:25.000Z</updated>
    <content type="html"><![CDATA[<p>两年前，在实习生笔试的时候，笔试百度，对试卷上很多问题感到不知所云，毫无悬念的挂了</p>
<p>读研两年，今年代笔百度，发现算法题都见过，或者有思路，但一时之间居然都想不到很好的解法，而且很少手写思路，手写代码，有点仓皇失措；概念题却是很难答好，大多我都知道，但却难以描述清楚；最后一题大题，是设计分布式缓存系统，需要考虑负载均衡以及增删设备，我知识面比较窄，居然不知有一致性哈希，于是又跪了</p>
<p>痛定思痛，虽然我明年找工作，若以这样的状态和水平去笔试，面试，难以有什么好结果。</p>
<a id="more"></a>

<p>从笔试回来之后怒刷leetcode，约摸一个月有余，今天终于刷完142题（最后一题word ladder2是看答案copy的），纪念一下，并总结下这段时间狂刷题的感觉：</p>
<p><img src="http://images.cnitblog.com/blog/286484/201311/01214116-d82ca8508af049e290529faedbc8fc38.png" alt="leetcode-welcome"></p>
<ul>
<li><p>从做上面的题，我发现我更擅长一些数学技巧不高的程序题，习惯靠直觉立马书写代码，而非严格推理之后，再书写代码</p>
</li>
<li><p>对于链表的题比较擅长，链表可以在纸上画画，关键要考虑的问题，就是链表指针在运算中会改变，如何保存需要保存的链表指针值是难点，除了那题拷贝具有random指针的链表题，其他链表题我都比较快速的AC掉</p>
</li>
<li><p>对于树的题，常见的方法有：BFS和递归（可以看作是DFS），整体来说，难度也不大，其中递归应该是最常用的，递归的方法需要注意的就是边界判定；当然另一个问题，就是很多情况下，会被要求写非递归的解法，比如说树的遍历，或者知先序中序构建树，这些问题我得好好研究</p>
</li>
<li><p>对于求解题的BFS和DFS得到了比较大的锻炼，之前一直感觉模糊的掌握了DFS和BFS这两种搜索方法，事实上，直到现在才算是掌握的比较不错，对于leetcode上面的很多题，如果不限时的话，我都能以DFS搞定（起码能有20题以上），BFS往往在求解最先到达或者最短时间的时候用到，用起来感觉还不错</p>
</li>
<li><p>对于DP还是不算很熟悉，除了LCS，LIS还有编辑距离这样的经典DP题，其他我都很少往DP想，为什么我总觉得DP有点难理解呢？</p>
</li>
<li><p>关于DP和BFS，DFS求解的选择问题：一般来说，需要记录解（由哪些组成）优先选择BFS和DFS，它们在运算的时候能够很好的保存中间结果；对于DP，适合求解最终结果是怎么的情况，比如求值（最长公共子序列），或者判断是否存在（bool），DP如果要输出最优路径的话，是个比较麻烦的问题，一般还需要设置一个观测DP在选择表中如何移动的数组，关于DP我要好好训练下。</p>
</li>
<li><p>对STL熟悉了很多，用过很多之前都没用过的容器，几乎都用遍了吧：set,map,hash_set(unordered_set),hash_map(unordered_map),multimap,multiset(?好像这个我没用过),vector,string,pair,stack,queue等等，以及algorithm的函数，比如sort, unique,这些STL提供的，真是极大的方便了生活，以前经常得自己写一些基本数据结构，然而，自己写的再好哪有STL的好用啊！</p>
</li>
<li><p>对于在电脑面前写一些简单的算法程序应该是没很大问题了，但接下来的问题是：1,手写我要跪，虽然现在用vim，但我思路经常很跳，经常想起来就在前面插入，纸上可没这条件；2,一些基本的算法还不够熟练，比如快排，堆排，归并，KMP，等等，要立马写出一个bug free并且efficient&amp;&amp;elegant的代码是件不容易的时，我以后得专门在github上面建一个repo好好练习，自己写给自己看</p>
</li>
<li><p>leetcode上的大部分题都有不止一种解法，得好好看看其他人的解法，并且总结总结自己的解法</p>
</li>
</ul>
<p>对做leetcode的总结大致如此了。</p>
<p> 看了一些大公司的笔试面试题，尤其是笔试题，都特别广泛特别杂，要想在笔试拿高分，我还需要看很多很多书籍，一般数据结构题占试卷的分数也就30%的样子，如果其它题了解不够深的话，基本也难拿多高的分，所以一大波书在等待着我；另一方面，由于我是C/C++系，其实很多C++的高级机制都不知道，有些知道了由于不常用，后来也忘了，这个必须得好好总结。</p>
]]></content>
    <summary type="html"><![CDATA[<p>两年前，在实习生笔试的时候，笔试百度，对试卷上很多问题感到不知所云，毫无悬念的挂了</p>
<p>读研两年，今年代笔百度，发现算法题都见过，或者有思路，但一时之间居然都想不到很好的解法，而且很少手写思路，手写代码，有点仓皇失措；概念题却是很难答好，大多我都知道，但却难以描述清楚；最后一题大题，是设计分布式缓存系统，需要考虑负载均衡以及增删设备，我知识面比较窄，居然不知有一致性哈希，于是又跪了</p>
<p>痛定思痛，虽然我明年找工作，若以这样的状态和水平去笔试，面试，难以有什么好结果。</p>
]]></summary>
    
      <category term="leetcode" scheme="http://liaoxl.github.io/tags/leetcode/"/>
    
      <category term="求职面试" scheme="http://liaoxl.github.io/tags/%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从图割到图像分割（三）——多层图图割]]></title>
    <link href="http://liaoxl.github.io/blog/20131021/duo-ceng-tu/"/>
    <id>http://liaoxl.github.io/blog/20131021/duo-ceng-tu/</id>
    <published>2013-10-21T11:42:00.000Z</published>
    <updated>2014-03-16T06:02:01.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_MultiGraph.jpg" height="300px" width="30%" align="right" /></p>
<p>完整的了解了图割方法处理图像分割之后，在已有的<a href="#">graphcuts</a>开源代码的情况下，接下来就是自己创作的时间了。</p>
<p>如前面所说，图的构建是很有讲究的，何时采用四邻域，何时采用八邻域，何时采用K近邻，再何时采用全邻域？</p>
<p>这些都是很有讲究的，很多人就是在这上面稍加改动，就能发一些顶级文章。不过确实，通过$Maxflow/Mincut$处理图像时，对图的构造是非常敏感的，哪怕是你改动$Tlink$与$Nlink$的比例，都能产生很大的影响。但敏感归敏感，$Maxflow/Mincut$求取的全局最优解，恰是许多研究或能量优化函数中所梦寐以求的。</p>
<a id="more"></a>

<hr>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_natural_image1.jpg" width="30%" align="right" /></p>
<p>图论方法在交互式分割中，总是将图像分割成前景和背景两类，即用户选定前景，或用户选定前景/背景，或用户选定背景。然而，很明显，在自然图像中，很多情况下并非只有两类，需要选定多类才能达到较好的分割效果。</p>
<p>由两类扩展成多类，是我<a href="http://grid.hust.edu.cn/wenbingtao/" target="_blank">导师</a>提出来的想法，并完善，通过多层图方法完成图像中多类的交互式分割。</p>
<p>其中，多类分割的实现方法，也是在最初<code>Graphcuts</code>源码上进行改进，具体可见我的github，<a href="https://github.com/liaoxl/MultiLayerGraph" target="_blank">MulitLayerGraph</a>。这份代码的主要思想是源自我<a href="#">导师</a>，主要工作是我素未谋面的师兄<a href="#">常峰</a>写的，师兄写的代码比较乱，有些小bug，并且不是用模板来实现的，鉴于我在研究此类问题，并且算是对这类问题非常熟悉了，所以将代码全部重构一下，用模板写了并放在github上面。</p>
<p>从别人的源代码我学到了很多东西，而自己却没有什么贡献，一直感到很惭愧，这份代码应该是我github上面算法含金量最高的了。</p>
<hr>
<h3 id="多层图的构建">多层图的构建</h3>
<p>首先，要了解经典<code>Graphcuts</code>是多少层，它是多少层？是两层，即将目标分为两类；</p>
<p>然后，要明白<code>Tlink</code>的含义，<code>Tlink</code>一般都是通过已观测的信息，所以将目标分为两类时，其<code>Tlink</code>都是通过已观测信息得到的；</p>
<p>其次，将以上的两类变成多类，则通过多类观测的信息，构建多类图（这个多类最初在Boykov的文章中乘坐MultiGraph），长得类似这个形状，可以通俗的认为是有多个源点的图，其对<code>Multi-Label</code>问题的优化可具体看<a href="http://scholar.google.com.hk/scholar?q=Fast+Approximate+Energy+Minimization+via+Graph+Cuts&amp;hl=zh-CN&amp;as_sdt=0&amp;as_vis=1&amp;oi=scholart&amp;sa=X&amp;ei=THmkUv-YKqjpiAeNs4CADQ&amp;ved=0CCkQgQMwAA" target="_blank">Fast Approximate Energy Minimization via Graph Cuts</a>；</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_mg.jpg" align="center" /></p>
<p>我们提出的是<code>MultiLayerGraph</code>，如文章最开始的图所示。每一层（红，蓝，绿）内部的构建都是相同的，如之前的博文所述<code>Nlink</code>，那么上图认为是几层图呢？直观上要么是三层（s，t不算）或五层（s，t各算一层）。<em>然而实际是四层！</em></p>
<hr>
<h3 id="Graphcuts类方法分割得到的类数，取决于<code>Tlink</code>的层数">Graphcuts类方法分割得到的类数，取决于<code>Tlink</code>的层数</h3>
<hr>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_cuts.jpg" align="right" /></p>
<p>我们假定，<code>Tlink</code>表示的都是相似性的倒数，即越相似，<code>Tlink</code>越小，考虑到最大流最小割算法切断的是最小权值，所以最相似的肯定越可能被切断！</p>
<p>于是乎，我们就采取这样的策略：构建N层图，比如上述的四层图；然后根据观测信息设置每层的<code>Tlink</code>；最后，执行最大流算法，并观测当前节点的<code>Tlink</code>是在哪一层被切断！</p>
<p>多层图一个标准的割应该如右图左边的，右边是不对的，并且通过算法是不能得到的。</p>
<hr>
<h3 id="如何判断<code>Tlink</code>是在哪里切断的呢？">如何判断<code>Tlink</code>是在哪里切断的呢？</h3>
<p>这就源自最初的<a href="#">Graphcuts</a>算法了</p>
<p>在开源的<a href="#">Graphcuts</a>算法中，在计算最大流时，一直维护着两颗“树”，一棵是由<code>S</code>延伸出来的；一棵是由<code>T</code>延伸出来的。在最后时刻，由这两棵树交界的部分形成最小割。</p>
<p>那么就有这样一个特点，假设当前<code>Tlink</code>被割断，则上面一个点肯定来自<code>S</code>树，下面一个点肯定属于<code>T</code>树。所以通过这个特点，可以判断在哪切断的 :)</p>
<hr>
<p>这实际上是一种近似的方法，为什么这么说呢？</p>
<p>上面的网络流图中，每一层的节点实际上都是相同的，不同的是<code>Tlink</code>有多层，所以完成一次分类，产生了一些额外的“边”需要计算进来并考虑切断。</p>
<p>不过这个误差不太好估计。</p>
<p>总的来说，图割的结果很取决于参数，一般来说，所有<code>Tlink</code>会统一权值的计算方法，所有<code>Nlink</code>也会统一权值的计算方法；然而<code>Tlink</code>与<code>Nlink</code>的比例该如何设定？</p>
<p>一般只有实验中来知道吧。</p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_MultiGraph.jpg" height="300px" width="30%" align="right" /></p>
<p>完整的了解了图割方法处理图像分割之后，在已有的<a href="#">graphcuts</a>开源代码的情况下，接下来就是自己创作的时间了。</p>
<p>如前面所说，图的构建是很有讲究的，何时采用四邻域，何时采用八邻域，何时采用K近邻，再何时采用全邻域？</p>
<p>这些都是很有讲究的，很多人就是在这上面稍加改动，就能发一些顶级文章。不过确实，通过$Maxflow/Mincut$处理图像时，对图的构造是非常敏感的，哪怕是你改动$Tlink$与$Nlink$的比例，都能产生很大的影响。但敏感归敏感，$Maxflow/Mincut$求取的全局最优解，恰是许多研究或能量优化函数中所梦寐以求的。</p>
]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="最大流" scheme="http://liaoxl.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="多层图" scheme="http://liaoxl.github.io/tags/%E5%A4%9A%E5%B1%82%E5%9B%BE/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从图割到图像分割（二）——图的构造]]></title>
    <link href="http://liaoxl.github.io/blog/20131020/tu-de-gou-zao/"/>
    <id>http://liaoxl.github.io/blog/20131020/tu-de-gou-zao/</id>
    <published>2013-10-20T15:28:00.000Z</published>
    <updated>2014-03-16T05:57:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_graph.png" width="30%" height="200px" align="right" /></p>
<p>之前解释了为什么能用最大流最小割算法来做图像分割，其实更为正式的引用，即为众多paper所写的那样，图割其实是用来优化能量函数的，我是从自己的一些体会来写的，因为“能量函数”这东西，太过虚无飘渺，不够直观，不便于理解。</p>
<p>在我了解了为什么能够用过做图像分割后，又有问题困扰我：为什么我们所见到的图构建都是四邻域或八邻域的？为什么不是一个全域图（两两相连）？</p>
<p>这个问题似乎也有很多搞图像分割的大牛注意到了，他们最初或许是在实验中发现四邻域和八邻域已经很好了，但后来他们还是给为什么这样做提供了理论依据</p>
<a id="more"></a>

<hr>
<h3 id="<a_href="http://en-wikipedia-org/wiki/Markov_random_field" target="_blank">Markov_Random_Field</a>"><a href="http://en.wikipedia.org/wiki/Markov_random_field" target="_blank">Markov Random Field</a></h3>
<p><a href="http://baike.baidu.com/view/2313875.htm" target="_blank">马尔克夫随机场</a>是解释这个问题的最有力理论依据，先看马尔克夫随机场定义：它包含两层意思：一是什么是马尔可夫，二是什么是随机场。</p>
<p>马尔可夫一般是马尔可夫性质的简称。它指的是一个随机变量序列按时间先后关系依次排开的时候，第N+1时刻的分布特性，与N时刻以前的随机变量的取值无关。拿天气来打个比方。如果我们假定天气是马尔可夫的，其意思就是我们假设今天的天气仅仅与昨天的天气存在概率上的关联，而与前天及前天以前的天气没有关系。其它如传染病和谣言的传播规律，就是马尔可夫的。</p>
<p>随机场包含两个要素：位置（site），相空间（phase space）。当给每一个位置中按照某种分布随机赋予相空间的一个值之后，其全体就叫做随机场。我们不妨拿种地来打个比方。“位置”好比是一亩亩农田；“相空间”好比是种的各种庄稼。我们可以给不同的地种上不同的庄稼，这就好比给随机场的每个“位置”，赋予相空间里不同的值。所以，俗气点说，随机场就是在哪块地里种什么庄稼的事情。</p>
<p>好了，明白了上面两点，就可以讲马尔可夫随机场了。还是拿种地打比方，如果任何一块地里种的庄稼的种类仅仅与它邻近的地里种的庄稼的种类有关，与其它地方的庄稼的种类无关，那么这些地里种的庄稼的集合，就是一个马尔可夫随机场。</p>
<p><strong>在图割的图构造里面，其实就是：当前节点只与邻近的四邻域或八邻域节点相关，故可以只构建四邻域或八邻域图</strong></p>
<hr>
<h3 id="图构造的数学模型">图构造的数学模型</h3>
<p>说到这里，先看看典型的能量函数模型：</p>
<p>$E(L)=\sum<em>{p\in{P}}D_p(L_p) + \sum</em>{(p,q)\in{N}}V_{p,q}(L_p,L_q)$</p>
<p>这里有$L=\lbrace L_p \mid p\in{P} \rbrace$</p>
<p>以上两项都叫做惩罚项，意味着突袭那个分割的每一次“割断”，都会带来惩罚，如何使得总惩罚最小，即可看作是最优的完成了图像分割的任务。</p>
<p>然而，假使要使得能量函数最优时即为最好的分割结果，上式每项就必须赋予相应的含义，否则构建一个与分割无关的能量函数模型，即使将能量函数最小化，也无任何意义。</p>
<p>我们知道基于图割的图像分割大多都是交互式分割，什么叫做交互式分割？就是用户提供一些先验知识，然后根据这些先验知识对原有的数学模型进行量化，得到一个可优化的数学表达式。例如，用户可以通过认定一张图像上的一个苹果是他所要的目标，则他在图像上圈定苹果，我们程序知道了用户圈定的点是属于前景点，则可以将所有类似苹果的像素点都归类为前景点，这就是交互式的一种方法。</p>
<p>在此也是，前面一项$D_p(L_p)$表示根据观测信息（用户提供）判断当前点是否归类为前景点，并且设定，如果归类错误，其付出的代价是多少。</p>
<p>也许由前面的信息就可以大致判断当前像素的归类了，那后面一项有什么意义呢？</p>
<p>后面一项表示相邻像素点间的约束信息，举个例子：如果当前像素属于前景点，那么它左边一个点或者右边一个点与当前点相似，那么它属于前景的概率是不是也很大？在前面一项不能准确判断的时候，这时候这个约束关系就作用明显了。</p>
<hr>
<h3 id="Tlink的构建">Tlink的构建</h3>
<p><code>Tlink</code>，在能量函数中一般称为数据项，即上式左半部分：$D_p(L_p)$，在图的构建中为与源点，汇点相连的边的权值，<code>T</code>在这里表示<code>Terminal</code>，一般而言，源点表示的是前景，汇点表示的是背景。</p>
<p>如前面所说，<code>Tlink</code>的构建与所给信息相关，考虑到$Maxflow/Mincut$切断的是权值最小的点，假设用相似性作为<code>Tlink</code>的权值的话，则如果当前像素属于前景，切断的应该是与汇点连接的<code>Tlink</code>，反之则切断与源点相连接的<code>Tlink</code>。</p>
<p>假设，将相似性归一化，则相似性可看作是属于某一类的概率值，如根据已有信息，得到某个归一化的相似性权值<code>p</code>，则可以说它属于前景的概率为<code>p</code>，这样属于背景的概率就是<code>1-p</code>了。</p>
<p>当然很多情况下，为了公平起见，还是会提供一些背景点，用类似前景<code>Tlink</code>的方法构建背景<code>Tlink</code>。</p>
<p>然而，这里就有个问题：在我有一堆点作为前景点的前提下，我如何算一个点与给定点的相似度？</p>
<p>事实上，这本身就是一个值得探讨的问题，我只是说说我见过的一些方法：</p>
<p>1）算距离平均值/得到中心点算距离;</p>
<p>2）算与最近/最远点的距离；</p>
<p>3）用已有点构建单高斯模型，用所构建的单高斯模型算相似性；</p>
<p>4）用已有点构建多高斯模型(GMM)，用所构建的GMM来算相似性；</p>
<p>这些都是比较常用的方法，在所发表的文章中看，用的最多的是4,我想一来是效果好，而来是有更好的理论可以些（原来我这么揣测）</p>
<hr>
<h3 id="Nlink的构建">Nlink的构建</h3>
<p>对比来说，<code>Nlink</code>的构建是比较简单的。这里<code>N</code>可以解释为<code>Neighbor</code>，在图的构造上即为相互邻接的像素点相连，<code>Nlink</code>表示“邻接”像素点之间的约束关系，即切断“邻接”像素点（换句话说，将邻接的像素点分为不同类）所需花费的惩罚，所以简单来说，就只需要弄清两个问题：</p>
<p>1）怎样算是“邻接”？</p>
<p>2）作为邻接的像素点，其权值如何设定？</p>
<p>一般来说，“邻接”都是采用四邻域或八领域，理由如前面所述，权值的设定，一般都采用高斯权值：</p>
<p>$$ w_{ij}=\left{<br>\begin{aligned}<br>&amp; exp(-\beta\parallel{f(i)-f(j)}^2) &amp;  如果(i,j)相邻\<br>&amp; 0 &amp;  其他 \<br>\end{aligned}<br>\right.<br>$$</p>
<p>$\beta$是用来控制权值比重的，$f(i), f(j)$分别表示像素<code>i</code>与像素<code>j</code>的特征，这里的特征既可以指颜色特征，也可以指其它特征。</p>
<hr>
<h3 id="简略总结<code>Tlink</code>与<code>Nlink</code>的作用">简略总结<code>Tlink</code>与<code>Nlink</code>的作用</h3>
<p><code>Tlink</code>作为数据项，尽可能的将像素归类为正确的类别，保证像素分类的正确性；</p>
<p><code>Nlink</code>作为平滑项，尽可能的约束相邻像素不被切断，保持数据的平滑，在图像上，表现为边界平滑；</p>
<p>最终结果在以上两者的共同影响下得到！</p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_graph.png" width="30%" height="200px" align="right" /></p>
<p>之前解释了为什么能用最大流最小割算法来做图像分割，其实更为正式的引用，即为众多paper所写的那样，图割其实是用来优化能量函数的，我是从自己的一些体会来写的，因为“能量函数”这东西，太过虚无飘渺，不够直观，不便于理解。</p>
<p>在我了解了为什么能够用过做图像分割后，又有问题困扰我：为什么我们所见到的图构建都是四邻域或八邻域的？为什么不是一个全域图（两两相连）？</p>
<p>这个问题似乎也有很多搞图像分割的大牛注意到了，他们最初或许是在实验中发现四邻域和八邻域已经很好了，但后来他们还是给为什么这样做提供了理论依据</p>
]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="最大流" scheme="http://liaoxl.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从图割到图像分割（一）——最大流算法]]></title>
    <link href="http://liaoxl.github.io/blog/20131013/tu-ge/"/>
    <id>http://liaoxl.github.io/blog/20131013/tu-ge/</id>
    <published>2013-10-13T13:42:00.000Z</published>
    <updated>2014-03-16T06:01:29.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://vision.csd.uwo.ca/wiki/vision/upload/8/85/Maxflow_mincut.png" height="300px" width="30%" align="right" /></p>
<p>《算法导论》对最大流的介绍是：最大流问题是关于流网络的最简单的问题，它提出这样的问题：在不违背容量限制的条件下，把物质从源点传输到汇点的最大速率是多少？</p>
<p>更多关于网络流的介绍请看<a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81" target="_blank">网络流wiki</a></p>
<p>我最初接触最大流问题是在2011年，那时候我大四，刚保研完，去问导师我需要看哪些方面的书，老板说去把《算法导论》图论相关，以及把最大流最小割算法仔细看一遍。</p>
<p>图论算法在众多算法中算是比较复杂的了，首先读入数据需要构建邻接矩阵，然后再进行求解，求解过程显得并不是很直观。当时我对最大流最小割算法本身就不是很明了，更不明白如何可以应用到图像分割中，现在终于有些体会。<br><a id="more"></a></p>
<hr>
<h3 id="最大流算法">最大流算法</h3>
<p>从算法导论书中，最大流算法分为两种：</p>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm" target="_blank">Ford-Fulkerson方法</a>：书上对该“方法”进行了解释，之所以称作“方法”而不是“算法”，是因为Ford-Fulkerson方法是一种思想，而对这思想的实现，有不同的优化方法</li>
</ol>
<p>以<a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm" target="_blank">Ford-Fulkerson方法</a>为思想的最快算法为：</p>
<p><a href="http://www.nocow.cn/index.php/Dinic%E7%AE%97%E6%B3%95" target="_blank">Dinic算法</a>时间复杂度为：$O(n^2m)$，其中n为顶点数，m为边数</p>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm" target="_blank">压入重标记方法(push-relabel)</a>：这同样也是一种思想，具体实现也有不同的优化实现方法。</li>
</ol>
<p>基于<a href="http://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm" target="_blank">压入重标记方法(push-relabel)</a>方法的最快的方法有两种：</p>
<p><a href="#">H_PRF</a>时间复杂度为（最坏）$O(n^2\sqrt{m})$</p>
<p><a href="#">Q_PRF</a>时间复杂度为（最坏）$O(n^3)$</p>
<hr>
<h3 id="最大流=&gt;最小割">最大流=&gt;最小割</h3>
<p>决定最大流算法能够应用在图像分割的原因，就在于这条定理了</p>
<p>割的定义：</p>
<p>流网络$G=(V,E)$的<em>割</em>$(S,T)$将$V$划分为$S$和$T=V-S$两部分，使得$ s\in{S},t\in{T} $。如果$f$是一个流，则穿过割$(S,T)$的净流被定义为$f(S,T)$，割$(S,T)$的容量为$c(S,T)$。一个网络的<strong>最小割</strong>也就是网络中所有割中具有最小容量的割。</p>
<p><strong>最大流最小割</strong>定理<br>如果$f$是具有源点$s$和汇点$t$的流网络$G=(V,E)$中的一个流，则下列条件是等价的：</p>
<ul>
<li>$f$是$G$的一个最大流</li>
<li>残留网络$G<em>f$不包含增广路径</em></li>
<li>对于$G$的某个割$(S,T)$，有$f=c(S,T)$</li>
</ul>
<p>其中第三条，说明最大流的值实际上等于某一最小割的容量，即可以用最大流来求取最小割：<br>$$|f|=f(S,T)=\sum<em>{u\in{S}}\sum</em>{v\in{T}}f(u,v)\leq\sum<em>{u\in{S}}\sum</em>{v\in{T}}c(u,v)$$</p>
<hr>
<h3 id="为何可以用最小割算法来分割图像？">为何可以用最小割算法来分割图像？</h3>
<p>这个问题我刚接触图割的时候，就想了很久，刚开始我在直观上比较难理解</p>
<p>首先，要理解，最大流算法得到的最小割有什么意义？如果写过最大流算法，或者看明白最大流算法的都知道，在一个增广路径中，限制流容量增加的，就是其中具有最小流量的路径，如果将流从$S$向$T$推送，最终将形成由“最小容量”的一个割，这个割就是最小割，由这些“最小容量”的容量加起来即为最大流（实际上称作最大净流好些）</p>
<p>其次，图像是可以看作由一个个像素组成的巨大图，假设我将像素一一用边连接起来，则这些像素点会成为这个巨大图网络的顶点，如果能利用最大流算法，求取其最小割，通过最小割分开的顶点就是边权值相对较小的点，假设我边的权值与顶点间的相似度成正比，那么最小割分开的顶点就是相似度最小的点，即，通过最大流算法，我们将图像分成了一块块相似的像素区，这不就是图像分割吗？</p>
<p>最后，那么从源点能流出多少流呢？从汇点又能接收多少流呢？如果都是无穷大，那还会形成分割吗？显然这是需要限制的。如果从像素点中选出两个点，一个作为源点，一个作为汇点，图像中其它点与源点的相似度作为流入的流量，与汇点的相似度作为流出的流量，则应用最大流算法得到的结果，即将点分为两部分，一部分属于“相似于”源点，一部分“相似于”汇点，而又由于像素点两两相连，为保证像素间的光滑性，会产生相对光滑的分界。</p>
<p>实际中，像素点连接源点或汇点的边叫做T-Link、像素点相互连接的边叫做N-Link、T-link的构造当然要比上述我说的要复杂，而N-Link也不要求要两两相连，T-Link约束了像素点与给顶点的相似性，而N-Link约束了像素点之间的光滑性。</p>
<p>在Paper中，对构图的描述方式不一样，一般描述为目标函数为一个能量函数，而这个能量函数的优化，可以转化为一个最小割方法来求解。</p>
<hr>
<h3 id="Min-Cut/Max-Flow">Min-Cut/Max-Flow</h3>
<p>讲到最大流最小割算法，不得不提到大名鼎鼎的<a href="http://www.csd.uwo.ca/~yuri/" target="_blank">Boykov</a>和<a href="http://pub.ist.ac.at/~vnk/" target="_blank">Kolmogorov</a>，这两位牛人在2004年图像领域最顶级杂志TPAMI的一篇文章：<a href="http://www.csd.uwo.ca/~yuri/Papers/pami04.pdf" target="_blank">An Experimental Comparison of Min-Cut/Max-Flow Algorithms for Energy Minimization in Vision</a>，讲述了如何将图像分割转化为一个能量函数优化问题，并且如何用最大流最小割算法对其进行优化，此外，他们提供了开源的<a href="http://vision.csd.uwo.ca/code/maxflow-v3.01.zip" target="_blank">代码库</a>，提供了非常友好的接口给相关研究者调用，从而使得基于图割的图像分割思想广泛应用，其中包括后来大名鼎鼎的<a href="#">Lazy Snapping</a>和<a href="#">Grab Cut</a>。像Photoshop，美图秀秀等基于交互式分割得到目标的功能基本源于图割方法。</p>
<p>图割方法在之前的图像分割领域并非没有用过，之所以后来应用广泛，我认为很大一部分原因得益于开源代码库：实现一个最大流算法并非特别难的事，但如何高效实现，以及由于图像像素点很多，如何有效管理实现过程中的内存分配，及如何提供一个简单易用的接口，恐怕是绝大部分之前的人研究遇到的难点。</p>
<p><a href="http://www.csd.uwo.ca/~yuri/" target="_blank">Boykov</a>和<a href="http://pub.ist.ac.at/~vnk/" target="_blank">Kolmogorov</a>在文章中提出的maxflow算法是一种增广路径算法，其方法的时间复杂度为$O(n^2m|C|)$。从理论上讲，其时间复杂度大于以上三种，但实际的表现效果，优于以上所有（我猜应该是与图像所构成的图的特殊结构有关）。</p>
<p>算法可分为三个步骤：</p>
<ul>
<li>“growth” stage: search trees S and T grow until they touch giving an s → t path</li>
<li>“augmentation” stage: the found path is augmented, search tree(s) break into forest(s)</li>
<li>“adoption” stage: trees S and T are restored.</li>
</ul>
<p>伪代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>initialize: S = {s}, T = {t}, A = {s, t}, O = ∅
<span class="keyword">while</span> <span class="constant">true</span>
	grow S <span class="operator">or</span> T <span class="built_in">to</span> find <span class="operator">an</span> augmenting path P <span class="built_in">from</span> s <span class="built_in">to</span> t
	<span class="keyword">if</span> P = ∅ terminate
	augment <span class="command"><span class="keyword">on</span> <span class="title">P</span></span>
	adopt orphans
<span class="function"><span class="keyword">end</span> <span class="title">while</span></span>
</pre></td></tr></table></figure>

<p>步骤分为三步，基本与增广路径算法一致，其从S和T分别开始搜索，实际就是双向广搜，分别维持着一个属于S的队列和一个属于T的队列，当S的队列找到下一个节点，并发现下一个节点属于T的队列时，进行增广，并记录瓶颈流（bottleneck flow）所在位置，由于这些瓶颈流在增广后被移除，变为0后，需要重新看还有否必要将这些节点放入到队列中，这一步叫做adoption。名字还挺不错:)</p>
<p>具体可见代码实现，由于其给出的库是由Template方式编写，而且用了一些自己定义数据结构，所以代码不易看懂，需要耐心体会。</p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://vision.csd.uwo.ca/wiki/vision/upload/8/85/Maxflow_mincut.png" height="300px" width="30%" align="right" /></p>
<p>《算法导论》对最大流的介绍是：最大流问题是关于流网络的最简单的问题，它提出这样的问题：在不违背容量限制的条件下，把物质从源点传输到汇点的最大速率是多少？</p>
<p>更多关于网络流的介绍请看<a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81" target="_blank">网络流wiki</a></p>
<p>我最初接触最大流问题是在2011年，那时候我大四，刚保研完，去问导师我需要看哪些方面的书，老板说去把《算法导论》图论相关，以及把最大流最小割算法仔细看一遍。</p>
<p>图论算法在众多算法中算是比较复杂的了，首先读入数据需要构建邻接矩阵，然后再进行求解，求解过程显得并不是很直观。当时我对最大流最小割算法本身就不是很明了，更不明白如何可以应用到图像分割中，现在终于有些体会。<br>]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="最大流" scheme="http://liaoxl.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用moderncv打造个人简历]]></title>
    <link href="http://liaoxl.github.io/blog/20131011/modercv-resume/"/>
    <id>http://liaoxl.github.io/blog/20131011/modercv-resume/</id>
    <published>2013-10-11T11:20:00.000Z</published>
    <updated>2014-03-16T06:00:36.000Z</updated>
    <content type="html"><![CDATA[<p>本科的时候，简历是word做的，当时觉得做得还不错，也不习惯转为pdf，后面在投递简历的时候居然有时就以word的形式发过去，那时自认好像还不错，居然无知到pdf才是国际的统一标准，word存在各种版本间的问题。</p>
<p>word转pdf自然不失为一种提供pdf简历的方法，但word有很多“自动调整”功能，虽然有时候极大的方便了非技术用户使用，但却非常不方便自己DIY。</p>
<p>恰好近来在写paper，在琢磨了一阵latex，这玩意跟vim差不多，你不用的话，看了再多遍manual都没用，但经常用则很容易理解。<a id="more"></a></p>
<hr>
<p>用latex制作cv的想法源于这个<a href="https://github.com/zellux/resume" target="_blank">开源项目</a>，我把它下载下来，在自己机器上安装了Texlive(系统是Fedora 17)，发现编译中文简历有问题，似乎是编码的问题。我大概看了下这位作者所使用的模板是<a href="http://www.ctan.org/tex-archive/macros/latex/contrib/moderncv" target="_blank">moderncv</a>的模板，所以下载下来自己按照模板写了，并创建了自己的<a href="https://github.com/liaoxl/Resume" target="_blank">简历开源项目</a></p>
<p>如果总结起来的话，其步骤大概如下：</p>
<ol>
<li><p>配置Texlive环境，我当时直接下载的ISO文件（直接<code>yum</code>安装的，因为源里的版本比较旧，对中文支持不好），在我校的<a href="http://mirror.hust.edu.cn/CTAN/systems/texlive/" target="_blank">开源站点</a>，然后用这个命令挂载<code>mount -o loop -t iso9660 /home/moondark/Downloads/texlive2013-20130530.iso /mnt/vcdrom/</code>，当然前提你得在<code>/mnt/</code>目录下创建<code>vcdrom/</code>这个目录;</p>
</li>
<li><p>下载<a href="http://www.ctan.org/tex-archive/macros/latex/contrib/moderncv" target="_blank">moderncv</a>的格式文件;</p>
</li>
<li><p>仿造<a href="http://www.ctan.org/tex-archive/macros/latex/contrib/moderncv" target="_blank">modercv</a>上面的examples来书写自己的简历;</p>
</li>
<li><p>我用<code>pdflatex</code>命令编译的，好像用<code>xelatex</code>命令也可以，具体区别我也不甚清楚</p>
</li>
</ol>
<p>over</p>
]]></content>
    <summary type="html"><![CDATA[<p>本科的时候，简历是word做的，当时觉得做得还不错，也不习惯转为pdf，后面在投递简历的时候居然有时就以word的形式发过去，那时自认好像还不错，居然无知到pdf才是国际的统一标准，word存在各种版本间的问题。</p>
<p>word转pdf自然不失为一种提供pdf简历的方法，但word有很多“自动调整”功能，虽然有时候极大的方便了非技术用户使用，但却非常不方便自己DIY。</p>
<p>恰好近来在写paper，在琢磨了一阵latex，这玩意跟vim差不多，你不用的话，看了再多遍manual都没用，但经常用则很容易理解。]]></summary>
    
      <category term="latex" scheme="http://liaoxl.github.io/tags/latex/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Octopress中添加MathJax]]></title>
    <link href="http://liaoxl.github.io/blog/20130918/octopress-mathjax/"/>
    <id>http://liaoxl.github.io/blog/20130918/octopress-mathjax/</id>
    <published>2013-09-17T16:30:00.000Z</published>
    <updated>2014-03-16T06:00:17.000Z</updated>
    <content type="html"><![CDATA[<p>有些时候写博客需要用到数学公式，需要对Octopress的设置进行更改，才能较好的完成公式的显示</p>
<p>步骤如下：</p>
<ol>
<li><p>安装Kramdown解析器（因为其对MathJax的支持较好），在GemFile文件中添加<code>gem &#39;kramdown&#39;, &#39;~&gt;0.13.8&#39;</code>，保存，执行<code>bundle install</code> 即可；当然也可以用一步命令<code>gem install kramdown</code>;</p>
</li>
<li><p>在<code>_config.yml</code>中修改markdown解析器，将<code>markdown: rdiscount</code> 换为 <code>markdown: kramdown</code>，保存，之所以这么做是因为前者对于MathJax的解析不如后者好；</p>
</li>
<li><p>在<code>source/_includes/custom/head.html</code>中，加入以下脚本，从而使得MathJax能够被使用：</p>
<a id="more"></a>

</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">&lt;!-- MathJax --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript">
MathJax.Hub.Config({
	tex2jax: {
		inlineMath: [ [<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">"\\("</span>,<span class="string">"\\)"</span>] ],
		processEscapes: <span class="literal">true</span>
	}
});
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript">
MathJax.Hub.Config({
	tex2jax: {
		 skipTags: [<span class="string">'script'</span>, <span class="string">'noscript'</span>, <span class="string">'style'</span>, <span class="string">'textarea'</span>, <span class="string">'pre'</span>, <span class="string">'code'</span>]
	}
});
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript">
MathJax.Hub.Queue(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
		<span class="keyword">var</span> all = MathJax.Hub.getAllJax(), i;
		<span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; all.length; i += <span class="number">1</span>) {
		all[i].SourceElement().parentNode.className += <span class="string">' has-jax'</span>;
		}
		});
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>
	<span class="attribute">src</span>=<span class="value">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;</span><span class="javascript">
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<p>测试显示效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="xml">  $$ a</span><span class="keyword">^2</span><span class="xml"> + b</span><span class="keyword">^2</span><span class="xml"> = c</span><span class="keyword">^2</span><span class="xml"> $$</span>
</pre></td></tr></table></figure>

<p>$$ a^2 + b^2 = c^2 $$</p>
]]></content>
    <summary type="html"><![CDATA[<p>有些时候写博客需要用到数学公式，需要对Octopress的设置进行更改，才能较好的完成公式的显示</p>
<p>步骤如下：</p>
<ol>
<li><p>安装Kramdown解析器（因为其对MathJax的支持较好），在GemFile文件中添加<code>gem &#39;kramdown&#39;, &#39;~&gt;0.13.8&#39;</code>，保存，执行<code>bundle install</code> 即可；当然也可以用一步命令<code>gem install kramdown</code>;</p>
</li>
<li><p>在<code>_config.yml</code>中修改markdown解析器，将<code>markdown: rdiscount</code> 换为 <code>markdown: kramdown</code>，保存，之所以这么做是因为前者对于MathJax的解析不如后者好；</p>
</li>
<li><p>在<code>source/_includes/custom/head.html</code>中，加入以下脚本，从而使得MathJax能够被使用：</p>
]]></summary>
    
      <category term="Octopress" scheme="http://liaoxl.github.io/tags/Octopress/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[说说我的研一]]></title>
    <link href="http://liaoxl.github.io/blog/20130816/yyzj/"/>
    <id>http://liaoxl.github.io/blog/20130816/yyzj/</id>
    <published>2013-08-16T05:09:00.000Z</published>
    <updated>2014-03-16T06:00:05.000Z</updated>
    <content type="html"><![CDATA[<p>我一直觉得，一个人如果善于总结自己已经学过的知识，并为自己定制一些目标，可以在接下来的时间里，更有效率的工作。很可惜，我并不是一个善于总结的人，我总是埋头折腾，然而经常回头一看，发现自己走了很多弯路，幸好我有一些比较聪明的朋友，能够给我一些很有帮助的指导。</p>
<p>很多时候，我的生活就像我在电脑面前搜索，我明明在搜索一个问题的答案，但我却很容易被搜索过程中看到的另外的问题吸引过去，最终迷失了已有的方向。</p>
<a id="more"></a>

<p>在读研期间，我一直在假想，假设我工作了，现在将会是怎样的一番景象，尤其今年化为将工资涨了近30%，两年前，我面对着保研协议和华为的三方协议，选择了保研，现在看到已工作的同学拿着不菲的收入，而现在的我在实验室拿着200元/月的浅薄工资，除了偶尔时间上更为自由一点，依然要苦逼的工作，心里很有一番滋味。</p>
<p>然而，人不能同时走两条路。</p>
<hr>
<h3 id="其实也没做多少事">其实也没做多少事</h3>
<ul>
<li><p>去年这个时候的暑假，我正在帮老板修改paper，完成实验，paper上要求的实验做完之后，我回了一趟家，等待这研一的正式报道。<br>那篇paper我作为三作投了Patter Recognition之后被拒了，从我做实验到我知道被拒，几乎总总过了一年，我开始了解了为什么那么多博士不能按期毕业。</p>
</li>
<li><p>在去年的国庆节，我糅合了两个程序，一个是粒子滤波跟踪的，另一个是光流法跟踪的，作为跟踪来讲，它比原光流跟踪效果要好，在某些特殊情况下可以克服粒子滤波的缺陷，然而，以上这两个方法本身效果也并不出色，所以，即使我在它们的基础上进行改进，其效果依然不登大雅之堂。但我觉得我想法还是有创新之处，可以自己写一片小文章，不过在写成初稿之后，被老板压下，将我换做图像分割方向了。如果有机会，我将之前写的程序转移到linux下，并将其开源吧</p>
</li>
</ul>
<p>其实我是非常愿意做图像分割领域，我老板正擅长这个领域，我当初也是冲着这个来的。只是有点晚，图割做图像分割，我在大四上学期学习过，但未深入了解，我当时只知道图割做图像分割是用最大流最小割定理来证明，并通过网络流算法完成其分割过程的。现在虽然了解了很多网络流算法，但还不能立马手写出，对于图割常用的最大流算法原理也处于比较迷糊的状态。</p>
<p>转到图像分割方向的第一件事居然是修改一个国家自然科学基金的报告。说实话，我真的觉得这些文档类工作在浪费我宝贵的研究生时间。</p>
<ul>
<li><p>转眼到了2013年，过年来学校第一件事就是跟实验室同级同学一起调一个程序，我花了一个多礼拜在linux下给同学搭建了一个较好用的协同分割框架，这个分割框架老板觉得是可以写文章的，然而在五六月份实验结果出来后，效果不尽如人意，老板决定换idea，当然，我并不主要负责那个程序，所以也不关我的事。</p>
</li>
<li><p>后来，我在写一个diversity ranking进行协同分割的程序，准确的说，我是在修改。同时也修改四色标记程序，使其成为一个具有“启发式”的分割程序。直到现在，这两个程序依然是我主要要改进的两个程序。<br>说不定我发paper的唯一希望也就在这里了。</p>
</li>
</ul>
<hr>
<h3 id="目标驱动">目标驱动</h3>
<p>以上都是实验室相关的工作，之所以读研，就是为了个好工作，当然得做点实事：</p>
<p>首先要说的就是APUE了，这本书我最初看不懂，现在也是稍微懂了一点点，以后我还将继续阅读n遍；</p>
<p>其次参加各种竞赛：腾讯马拉松，微软编程之美，中兴捧月，结局基本都一样：通过第一轮，过不了第二轮，甚是遗憾，明年继续努力；</p>
<p>再者，在POJ上面A了70多道题，挤进前1w名（呵呵）；</p>
<p>然后，就是阅读一些与工作相关的书籍，比如Cracking the coding interview, 算法导论，设计模式，其中夹杂着阅读一些新语言相关的内容，比如ruby, nodejs, python等，这些新语言都很有意思，有些的确值得学习一下，同时也逛各种开原社区，如ruby-china, CNode, 也学习了git，github等便捷的使用；</p>
<p>还有很多事需要做……</p>
<hr>
<p>今年工作是相对去年好找的，错失了今年不知道明年我来找工作的时候是怎样的行情？总之好好努力吧。</p>
]]></content>
    <summary type="html"><![CDATA[<p>我一直觉得，一个人如果善于总结自己已经学过的知识，并为自己定制一些目标，可以在接下来的时间里，更有效率的工作。很可惜，我并不是一个善于总结的人，我总是埋头折腾，然而经常回头一看，发现自己走了很多弯路，幸好我有一些比较聪明的朋友，能够给我一些很有帮助的指导。</p>
<p>很多时候，我的生活就像我在电脑面前搜索，我明明在搜索一个问题的答案，但我却很容易被搜索过程中看到的另外的问题吸引过去，最终迷失了已有的方向。</p>
]]></summary>
    
      <category term="胡言乱语" scheme="http://liaoxl.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
      <category term="生活" scheme="http://liaoxl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
