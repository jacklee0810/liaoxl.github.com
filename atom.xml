<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Moondark]]></title>
  <subtitle><![CDATA[Do something]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liaoxl.github.io/"/>
  <updated>2014-05-28T15:15:36.681Z</updated>
  <id>http://liaoxl.github.io/</id>
  
  <author>
    <name><![CDATA[Xiangli Liao]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Hello, Hexo! Goodbye, Octopress!]]></title>
    <link href="http://liaoxl.github.io/blog/20140315/hello-world/"/>
    <id>http://liaoxl.github.io/blog/20140315/hello-world/</id>
    <published>2014-03-15T07:45:08.000Z</published>
    <updated>2014-03-17T04:19:09.000Z</updated>
    <content type="html"><![CDATA[<p>最终，从<a href="http://octopress.org/" target="_blank">Octopress</a>迁移到<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a></p>
<p><a href="http://octopress.org/" target="_blank">Octopress</a>有些缺点，让我一直很难以忍受，虽然感觉很<code>Geek</code>，但内心里一直想找个可以代替它的，这些所谓的缺点，事实上大部分都是由于前端引起的，我不是个前端程序员，我不会设计漂亮的前端页面，但我也有自己的品味，不想将就。</p>
<p>先说说我对<a href="http://octopress.org/" target="_blank">Octopress</a>的不满：</p>
<ul>
<li><p>字体太大，仿佛所有用<a href="http://octopress.org/" target="_blank">Octopress</a>框架的，字体都不小，虽然可以调，但调完后在这个框架里又没那么好看了</p>
</li>
<li><p>Tags或Tag Cloud都太丑，我只能勉强看懂这些CSS，这是从<code>github</code>上面用的其它开源插件</p>
</li>
<li><p>所有第三方<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes" target="_blank">主题</a>，我都认真看了一遍，我居然没有找到一款符合我口味的。</p>
</li>
<li><p>右边的<code>SideBar</code>太难看</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><code>code</code>的CSS不好看，超链接不好看……</p>
</li>
<li><p>以上综合，就是看着不舒服</p>
</li>
<li><p>排在最后的，才是为人诟病的生成速度，我并不怎么在乎这点，完全可以泡壶茶慢慢等</p>
</li>
</ul>
<p>如果我是一个优秀的前端程序员，可能我就直接大刀阔斧的往上面修改了，然后继续沿用<a href="http://octopress.org/" target="_blank">Octopress</a>，可惜我不是。<br>我曾在这上面改过，经常的问题就是：好不容易某部分好看了，结果发现与整体的框架不符，显得特别突兀。最终我放弃了修改。</p>
<p>很久之前，我就看到了<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>，那个时候我再看网易开源公开课，正在尝试用用<code>Nodejs</code>，当时不换的原因就是还是没有哪个样式让我觉得特别舒服，直到前一阵子看到<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>的<a href="http://hexo.io/docs/" target="_blank">官网</a>，我觉得官网是很好看的，后来再仔细看了下<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>的<a href="#">github</a>，发现这个博客框架发展很快，居然多了这么多的主题样式，而且看着让我觉得很舒服。</p>
<p>于是抽个周末，就迁移博客了。</p>
<p>从<a href="http://octopress.org/" target="_blank">Octopress</a>迁移到<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>是很容易的事，<a href="http://hexo.io/docs/migration.html" target="_blank">官网</a>就有相应的介绍，事实上，<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>本来就是很简单实用的博客框架，非常值得称赞。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最终，从<a href="http://octopress.org/" target="_blank">Octopress</a>迁移到<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a></p>
<p><a href="http://octopress.org/" target="_blank">Octopress</a>有些缺点，让我一直很难以忍受，虽然感觉很<code>Geek</code>，但内心里一直想找个可以代替它的，这些所谓的缺点，事实上大部分都是由于前端引起的，我不是个前端程序员，我不会设计漂亮的前端页面，但我也有自己的品味，不想将就。</p>
<p>先说说我对<a href="http://octopress.org/" target="_blank">Octopress</a>的不满：</p>
<ul>
<li><p>字体太大，仿佛所有用<a href="http://octopress.org/" target="_blank">Octopress</a>框架的，字体都不小，虽然可以调，但调完后在这个框架里又没那么好看了</p>
</li>
<li><p>Tags或Tag Cloud都太丑，我只能勉强看懂这些CSS，这是从<code>github</code>上面用的其它开源插件</p>
</li>
<li><p>所有第三方<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes" target="_blank">主题</a>，我都认真看了一遍，我居然没有找到一款符合我口味的。</p>
</li>
<li><p>右边的<code>SideBar</code>太难看</p>
</li>
</ul>
]]></summary>
    
      <category term="Hexo" scheme="http://liaoxl.github.io/tags/Hexo/"/>
    
      <category term="Octopress" scheme="http://liaoxl.github.io/tags/Octopress/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二分查找]]></title>
    <link href="http://liaoxl.github.io/blog/20140220/binary-search/"/>
    <id>http://liaoxl.github.io/blog/20140220/binary-search/</id>
    <published>2014-02-20T15:09:00.000Z</published>
    <updated>2014-03-16T06:05:10.000Z</updated>
    <content type="html"><![CDATA[<p>在微博上看到一篇文章，关于二分查找：<a href="http://my.oschina.net/fullofbull/blog/199693" target="_blank">当我写二分查找时，我想些什么</a></p>
<p>于是想到刚看过的《编程珠玑》上的一句话，“90%的人无法正确写出二分查找”</p>
<p>自己动手：</p>
<pre><code><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> n, <span class="built_in">int</span> target)
{
    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>, <span class="built_in">right</span>=n-<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[<span class="built_in">mid</span>] == target) return <span class="built_in">mid</span>;
        <span class="keyword">if</span>(target &gt; A[<span class="built_in">mid</span>]) <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><p>写完了后，去看这篇文章的答案，发现有很多问题，果然也属于那“90%”。<br><a id="more"></a></p>
<p>问题1, 需要对n进行判断，这个属于编程严谨性的问题；第二个问题，程序可以“优化”。</p>
<blockquote><p>我们先来考虑循环的执行步骤。假设我们有一个有着 n 个元素的数组（此处n是一个很大的数值），那么从该数组中第一次找到目标的概率为 1/n（一个很小的数值），下一次（经过一次二分）的概率则是 1/(n/2)——仍然不是很大——以此类推下去。事实上，只有当元素的个数减少到了 10 到 20 的时候，一次找到目标的概率才变得有意义，而对于10 到 20 个元素进行查找需要的只是大概 4 次循环。当查找失败时（在大多数的应用中很普遍），那些额外的测试就将变成纯粹的额外开销。</p>
<p>我们也可以来计算一下，在什么时候找到目标值的概率能接近 50%，但请你扪心自问：在一个复杂度为 O(log2N) 的算法中，对于它的每一步都增添一个额外的复杂计算，而目的仅仅是为了减少最后的几次计算，这样做有意义吗？</p>
</blockquote>


<p>这段话什么意思呢？归根到底就一个意思，如果一个很大的数组中没有我们想要的目标，那么条件判断 if (A[mid] == target) 完全是一个不必要的开销（分支跳转）。实际上，这种条件只要一次就够了，那就是循环终止并判断最终目标的时候。</p>
<p>代码可以改为： </p>
<pre><code><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> n, <span class="built_in">int</span> target)
{
    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>, <span class="built_in">right</span>=n-<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(target &gt; A[<span class="built_in">mid</span>]) <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;
    }
    <span class="keyword">if</span>(<span class="built_in">left</span>&gt;=n || A[<span class="built_in">left</span>]!=target) return -<span class="built_in">left</span>-<span class="number">1</span>;
    return <span class="built_in">left</span>;
}
</code></pre><p>这里注意上面的<code>return -left-1</code>，这行代码在找不到目标时，将目标合适的插入位置输出了，可谓一举两得。</p>
]]></content>
    <summary type="html"><![CDATA[<p>在微博上看到一篇文章，关于二分查找：<a href="http://my.oschina.net/fullofbull/blog/199693" target="_blank">当我写二分查找时，我想些什么</a></p>
<p>于是想到刚看过的《编程珠玑》上的一句话，“90%的人无法正确写出二分查找”</p>
<p>自己动手：</p>
<pre><code><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> n, <span class="built_in">int</span> target)
{
    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>, <span class="built_in">right</span>=n-<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[<span class="built_in">mid</span>] == target) return <span class="built_in">mid</span>;
        <span class="keyword">if</span>(target &gt; A[<span class="built_in">mid</span>]) <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><p>写完了后，去看这篇文章的答案，发现有很多问题，果然也属于那“90%”。<br>]]></summary>
    
      <category term="算法/数据结构" scheme="http://liaoxl.github.io/tags/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[点集的一些几何特征]]></title>
    <link href="http://liaoxl.github.io/blog/20140219/dian-ji/"/>
    <id>http://liaoxl.github.io/blog/20140219/dian-ji/</id>
    <published>2014-02-18T16:10:00.000Z</published>
    <updated>2014-03-16T06:04:56.000Z</updated>
    <content type="html"><![CDATA[<p>点集有很多特征，这里提到的有：最小凸包，最小外接矩形，最大内接三角形，最大内接四边形。</p>
<p>编程里面，如何求取点集的这些特征呢？</p>
<h3 id="预处理知识">预处理知识</h3>
<ul>
<li>对于三个点，p0,p1,p2，如何判断以p0为中心，p0p1到p0p2是顺时针还是逆时针？</li>
</ul>
<p>求向量p0p2与p0p1的叉积，若大于0,则说明是p0p2在p0p1的顺时针方向，若小于0，则说明p0p2在p0p1的逆时针方向。</p>
<a id="more"></a>


<h3 id="最小凸包">最小凸包</h3>
<h4 id="Graham栈扫描法。">Graham栈扫描法。</h4>
<p>这里有一篇<a href="http://blog.csdn.net/suwei19870312/article/details/5422818" target="_blank">博客</a>对此有比较详细的讨论，并给出比较好的伪代码，这里借鉴一下。</p>
<p>平面上有n个点p0,p1,p2,p3,…,pn，求其最小凸包</p>
<pre><code>GRAHAM-SCAN(Q)
{
     <span class="number">1</span>. 取出所有点钟<span class="keyword">y</span>坐标最小的点作为初始点p<span class="number">0</span>（如果有<span class="keyword">y</span>坐标相同的，选择<span class="keyword">x</span>坐标最小的）
     <span class="number">2</span>. 之后对于所有其他点，以p<span class="number">0</span>为中心，点集中的所有点按关于p<span class="number">0</span>的极角逆时针排序,形成p1,p2,..pn-<span class="number">1</span>（如果有极角重合，保存最远的点）
     <span class="number">3</span>. <span class="keyword">push</span>(p<span class="number">0</span>,S) 
     <span class="number">4</span>. <span class="keyword">push</span>(p1,S)
     <span class="number">5</span>. <span class="keyword">push</span>(P2.S)
     <span class="keyword">for</span>(i: <span class="number">3</span>-&gt;<span class="keyword">m</span>)
     {     
           px = nexttoTop(S)
           py = Top(S) 
           <span class="keyword">do</span> <span class="keyword">while</span> (如果(py-&gt;pi向量)相对于(px-&gt;py向量)是顺时针的)
                     <span class="keyword">pop</span>(S)
                     px = nextotTop(S)
                     py = Top(S)
           <span class="keyword">push</span>(pi, S);
     }
     <span class="keyword">return</span> S;
}
</code></pre><h3 id="最小外接矩形">最小外接矩形</h3>
<p>在上述最小凸包的基础上，进行求取，最小外接矩形</p>
<p>这里就是开始<em>旋转卡壳</em>思想的应用。</p>
<p>首先有一个前提，也是可以证明的，<em>凸包的最小外接矩形，至少有一条边与凸包的一条边重合</em>，这点是可以证明的，但过程比较复杂。</p>
<p>在这个前提下，就可以通过下列为代码进行求解了：</p>
<pre><code><span class="constant">MinRec</span>(<span class="constant">Q</span>)
{
    <span class="constant">Rec</span>=<span class="constant">MAXINT</span>
    <span class="keyword">for</span> i=<span class="number">0</span><span class="symbol">:n</span>
        <span class="constant">Pick</span> pipi+<span class="number">1</span> 作为矩形的一条边
        依次找投影在这条边上最左边/最右边以及距此边最远的点，作出矩形
        计算面积<span class="constant">Si_i</span>+<span class="number">1</span>,如果<span class="constant">Si_i</span>+<span class="number">1</span>&lt;<span class="constant">Rec</span>，则 <span class="constant">Rec</span>=<span class="constant">Si_i</span>+<span class="number">1</span>，并记录该边与另外三点
    <span class="keyword">end</span>
}
</code></pre><p>上述求解过程，还可以优化。</p>
<p>在找 最左边/最右边/最远 的三点时，对于固定一条边pipi+1而言，从点pi+2逆时针一直找到pi-1，点到边的距离都是先增大，再减小，在该边上最左边/最右边的投影也是先增大后减小的。所以，保存这三点后，下一次计算，找最左边/最右边/最远 的三点时，就可以分别以上次找到的三点为起点，进行寻找。这里可以减去很多计算。</p>
<h3 id="最大内接三角形">最大内接三角形</h3>
<p>最大内接三角形 同样应用 <em>旋转卡壳</em> 的思想</p>
<pre><code>MaxTrangle(Q)
{
    选p0,p1,p2三点，构成三角形；
    <span class="number">1</span>, 固定p0,p1，移动p2，找到能构成的最大三角形p0p1p2<span class="string">'；
    2, 固定p0p2'</span>，移动p1，找到能构成的最大三角形p0p1<span class="string">'p2'</span>；
    <span class="number">3</span>, 固定p1<span class="string">'p2'</span>，移动p0,找到能构成的最大三角形p0<span class="string">'p1'</span>p2<span class="string">'；
    重复1～3，直至三角形面积不再增大
}</span>
</code></pre><h3 id="最大内接四边形">最大内接四边形</h3>
<p>最大内接四边形， 同样应用 <em>旋转卡壳</em> 的思想</p>
<pre><code>MaxSquare(Q)
<span class="cell">{
    选p0,p1,p2,p3三点，构成三角形；
    <span class="number">1</span>, 固定p0,p1,p2，移动p3，找到能构成的最大四边形p0p1p2p3<span class="string">'；
    2, 固定p0,p1,p3'</span>，移动p2，找到能构成的最大四边形p0p1p2<span class="string">'p3'</span>；
    <span class="number">3</span>, 固定p0,p2<span class="string">',p3'</span>，移动p1,找到能构成的最大四边形p0p1<span class="string">'p2'</span>p3<span class="string">'；
    4, 固定p1'</span>,p2<span class="string">',p3'</span>，移动p0,找到能构成的最大四边形p0<span class="string">'p1'</span>p2<span class="string">'p3'</span>；
    重复<span class="number">1</span>～<span class="number">4</span>，直至四边形面积不再增大
}</span>
</code></pre><p>旋转卡壳的思想在求点集的集合特征上有较为广泛的应用，在求得凸包的基础上，可以方便的求取最小外接矩形/最大内接三角形/最大内接四边形。</p>
<p>当然，以上都是伪代码，具体实现，还有一些边界条件得注意。</p>
]]></content>
    <summary type="html"><![CDATA[<p>点集有很多特征，这里提到的有：最小凸包，最小外接矩形，最大内接三角形，最大内接四边形。</p>
<p>编程里面，如何求取点集的这些特征呢？</p>
<h3 id="预处理知识">预处理知识</h3>
<ul>
<li>对于三个点，p0,p1,p2，如何判断以p0为中心，p0p1到p0p2是顺时针还是逆时针？</li>
</ul>
<p>求向量p0p2与p0p1的叉积，若大于0,则说明是p0p2在p0p1的顺时针方向，若小于0，则说明p0p2在p0p1的逆时针方向。</p>
]]></summary>
    
      <category term="算法/数据结构" scheme="http://liaoxl.github.io/tags/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[马年——祝自己顺利]]></title>
    <link href="http://liaoxl.github.io/blog/20140201/ma-nian/"/>
    <id>http://liaoxl.github.io/blog/20140201/ma-nian/</id>
    <published>2014-01-31T21:58:00.000Z</published>
    <updated>2014-03-16T06:04:47.000Z</updated>
    <content type="html"><![CDATA[<p>我是个拖延症患者，原本想在除夕晚上写点什么，后来拖到初一，再后来到了今天</p>
<p>今天起得很早，向来年初二都是要早起，然后去 <a href="#">敬神</a>，也就是祭拜祖宗</p>
<p>今年是重要的一年，我常用的邮箱<a href="#">liaoxl2012@gmail.com</a>后面加的2012，本意就是想指我2012年毕业，那是我大三找实习时候开始用的一个邮箱。没想到后来读研了，今年又是这样的一年，我应该换成2015了。</p>
<p>昨儿出去，见了<a href="#">小斌</a>, <a href="#">水哥</a>, <a href="#">黄鹏</a>,<a href="#">国平</a>, 水哥是多年挚交，但所学是医学，专业方面交集倒是并不多，小斌，黄鹏，国平分别签了腾讯，网易游戏，阿里云，都是国内一等一的工作offer了，着实让人佩服。</p>
<a id="more"></a>

<p>今年是我找工作的一年，虽然去年看到他们找工作或者学习上的一些难熬时刻，但毕竟都已经过去了。而我，正在等待这些的来临，我向来运气不太好，往往越想实现的，哪怕自己很努力，但终归会缺点运气，以至最终失之交臂，或需曲折蜿蜒才能得到。</p>
<p>时间过得真快，蛇年转眼即过。我特地看了一下日历，大约2.10号是蛇年的初一，现在是1.31号是马年的初一，而羊年的初一将是2.19号。算是过了一个相对短一点的一年，迎来了一个长的年。</p>
<p>研究生的两个目标，一个是发文章，另一个是找个好工作，都看今年了</p>
<p>祝自己马年顺利吧！</p>
]]></content>
    <summary type="html"><![CDATA[<p>我是个拖延症患者，原本想在除夕晚上写点什么，后来拖到初一，再后来到了今天</p>
<p>今天起得很早，向来年初二都是要早起，然后去 <a href="#">敬神</a>，也就是祭拜祖宗</p>
<p>今年是重要的一年，我常用的邮箱<a href="#">liaoxl2012@gmail.com</a>后面加的2012，本意就是想指我2012年毕业，那是我大三找实习时候开始用的一个邮箱。没想到后来读研了，今年又是这样的一年，我应该换成2015了。</p>
<p>昨儿出去，见了<a href="#">小斌</a>, <a href="#">水哥</a>, <a href="#">黄鹏</a>,<a href="#">国平</a>, 水哥是多年挚交，但所学是医学，专业方面交集倒是并不多，小斌，黄鹏，国平分别签了腾讯，网易游戏，阿里云，都是国内一等一的工作offer了，着实让人佩服。</p>
]]></summary>
    
      <category term="胡言乱语" scheme="http://liaoxl.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
      <category term="生活" scheme="http://liaoxl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++的虚析构函数]]></title>
    <link href="http://liaoxl.github.io/blog/20131205/virtual-destructor/"/>
    <id>http://liaoxl.github.io/blog/20131205/virtual-destructor/</id>
    <published>2013-12-05T11:16:00.000Z</published>
    <updated>2014-03-16T06:04:30.000Z</updated>
    <content type="html"><![CDATA[<p>C++是门神奇的语言，总是有一些不能以我们“程序员”编写它的角度去理解的问题，究其根本，大多都是C++编译器在“适当”的时候，会自动为我们的程序增加或删除一些东西，如果其编译器所做的改动，与我们预期的结果并不相关，自然我们也能得到较好理解的运行结果，然而，深入学习C++之后，就会发现，其中很多特性，必须要掌握，必须要知道编译器做了哪些东西，才能保证程序的正确执行。</p>
<p>C++类的构造，析构函数是C++编译器在编译的过程中，所作“适当”修改的主要场所</p>
<a id="more"></a>

<p>不扯远，在类继承中，一般类的析构函数都要被定义成虚函数，或者必须要定义成虚函数，这是为什么呢？</p>
<p>看如下两个类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>class Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2) {}
        ~Point2d(){}

        <span class="keyword">int</span> x;
        <span class="keyword">int</span> y;
};

class Point3d : <span class="keyword">public</span> Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point3d</span>():<span class="title">z</span>(3){}
        ~Point3d(){}

        <span class="keyword">int</span> z;
};
</pre></td></tr></table></figure>

<p>这上面<code>Point3d</code>是由基类<code>Point2d</code>派生出来的，C++有个特点，可以用基类的指针指向派生类，即派生类可以用基类指针<code>new</code>出来</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">Point2d* pt2d</span>=<span class="string">new Point3d();</span>
</pre></td></tr></table></figure>

<p>至于为什么能这样<code>new</code>，我想应该是<code>new</code>出来的空间比基类指针所能访问到的空间更大，所以认为是“安全”的，基于这个理念，派生类指针是不能<code>new</code>基类的，因为会产生“不安全”的访问。</p>
<p>通过看了《深度探索C++对象模型》，来解释一下上述一行式子中，编译器究竟做了什么事：</p>
<p>1,产生一个指向<code>Point2d</code>的指针，<code>pt2d</code>;<br>2,生成一个<code>Point3d</code>的类；<br>3,将<code>Point3d</code>产生的地址赋值给一个指向<code>Point2d</code>的指针</p>
<p>以上的解释比较直白，甚至可以说是“无用”的</p>
<p>将它们细化，第一步没什么好说的，第二步中，生成一个<code>Point3d</code>的类，派生类中的构造函数是如何执行呢？分为以下几步：</p>
<p>1）先调用基类的构造函数，其实在编译器中，是将基类的构造函数嵌入到派生类的构造函数中；</p>
<p>2）如果有虚函数表，将虚函数表重新绑定；</p>
<p>3）执行当前的构造函数，产生一个派生类。</p>
<p>为了验证这一过程，可以在构造函数写出输出函数，看是否这样，如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="comment">/*
 * con_des.cpp
 * Copyright (C) 2013 moondark &lt;liaoxl2012@gmail.com&gt;
 *
 * Distributed under terms of the MIT license.
 */</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using</span> namespace std;

class Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2)
        {
            cout &lt;&lt; <span class="string">"Point2d Constructor!"</span> &lt;&lt; endl;
        }
        
        ~Point2d(){}

        <span class="keyword">int</span> x;
        <span class="keyword">int</span> y;
};

class Point3d : <span class="keyword">public</span> Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point3d</span>():<span class="title">z</span>(3)
        {
            cout &lt;&lt; <span class="string">"Point3d Constructor!"</span> &lt;&lt; endl;
        }
        ~Point3d(){}

        <span class="keyword">int</span> z;
}; 

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])
{
    
    Point2d* pt2d=<span class="keyword">new</span> Point3d();
    delete pt2d;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>可见，输出是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Point2d <span class="function"><span class="keyword">Constructor</span>!
<span class="title">Point3d</span> <span class="title">Constructor</span>!</span>
</pre></td></tr></table></figure>

<p>将第二步分解了，那么它又是如何执行第三步呢？</p>
<p>由第二步知道，在派生类中，包含着一个已经构造出来的基类，这个基类在原来的基础上，只是虚函数表做了更改，重新绑定了派生类的函数。而这个<code>Point2d</code>的指针，就是指向派生类的基类实体。</p>
<p>如本文标题所写，要讨论的是为什么是虚析构函数？</p>
<p>在上文中的那段完整可执行代码中，如果你在析构函数也添加打印信息，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>class Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2)
        {
            cout &lt;&lt; <span class="string">"Point2d Constructor!"</span> &lt;&lt; endl;
        }
        
        ~Point2d()
        {
            cout &lt;&lt; <span class="string">"Point2d Destructor!"</span> &lt;&lt; endl;
        }

        <span class="keyword">int</span> x;
        <span class="keyword">int</span> y;
};

class Point3d : <span class="keyword">public</span> Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point3d</span>():<span class="title">z</span>(3)
        {
            cout &lt;&lt; <span class="string">"Point3d Constructor!"</span> &lt;&lt; endl;
        }
        ~Point3d()
        {
            cout &lt;&lt; <span class="string">"Point3d Destructor!"</span> &lt;&lt; endl;
        }

        <span class="keyword">int</span> z;
};
</pre></td></tr></table></figure>

<p>重新运行上述代码，则发现<code>delete</code>操作只促发了基类的的析构函数，并未调用派生类的析构函数，于是就产生了问题！</p>
<p>众所周知，析构函数的作用，就是在销毁对象时“合适”的处理一些信息，其实说白了就是擦屁股。</p>
<p>而虚函数的作用，就是可以动态绑定，比如我在基类定义了一个虚函数<code>virtual show()</code>，那么如果我在派生类重写了这个函数，则这时用上述基类指针<code>new</code>出派生类来之后，<code>pt2d</code>访问<code>show</code>函数，实际是派生类的，为何？因为在构造的时候进行重新绑定，按照这个思想，我们应该对基类的析构函数定义为虚函数，这样<code>delete</code>的时候，就是调用派生类的析构函数了。</p>
<p>于是，理所当然，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>class Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2)
        {
            cout &lt;&lt; <span class="string">"Point2d Constructor!"</span> &lt;&lt; endl;
        }
        
        <span class="keyword">virtual</span> ~Point2d()
        {
            cout &lt;&lt; <span class="string">"Point2d Destructor!"</span> &lt;&lt; endl;
        }

        <span class="keyword">int</span> x;
        <span class="keyword">int</span> y;
};

class Point3d : <span class="keyword">public</span> Point2d
{
    <span class="keyword">public</span>:
        <span class="title">Point3d</span>():<span class="title">z</span>(3)
        {
            cout &lt;&lt; <span class="string">"Point3d Constructor!"</span> &lt;&lt; endl;
        }
        ~Point3d()
        {
            cout &lt;&lt; <span class="string">"Point3d Destructor!"</span> &lt;&lt; endl;
        }

        <span class="keyword">int</span> z;
};
</pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Point2d <span class="function"><span class="keyword">Constructor</span>!
<span class="title">Point3d</span> <span class="title">Constructor</span>!
<span class="title">Point3d</span> <span class="title">Destructor</span>!
<span class="title">Point2d</span> <span class="title">Destructor</span>!</span>
</pre></td></tr></table></figure>

<p>哇，它正常先调用了派生类的析构函数，再调用基类的析构函数，完全销毁了对象，没有内存泄漏之类的问题诶！</p>
<p>但是，我当时就思考一个问题，如果是虚函数，一般情况下，派生类重写了虚函数，则它只调用派生类的虚函数，而不调用基类的虚函数，但这里却调用了基类的虚函数，这是为什么呢？</p>
<p>记得前面讲了构造函数的生成对象的3个主要步骤，通过阅读《深度探索C++对象模型》就能够了解到，析构函数的行为，在顺序上，是与构造函数相反的，即：</p>
<p>1）执行当前析构函数;</p>
<p>2）重新解绑定虚函数表；</p>
<p>3）调用基类的析构函数</p>
<p>这里最重要的是2，它重新解绑定了虚函数表，这样派生类的析构函数才能找到基类的析构函数，从而能够正确完成程序的功能！</p>
<p>听起来很奇妙！</p>
<p>实际中，基类（如果有派生类）的析构函数往往都定义成虚函数。</p>
<p>接下来就还有个小问题：为何构造函数不能定义为虚函数呢？</p>
<p>前面提到过，构造函数有个过程是绑定虚函数表，如果构造函数定义为虚函数，这个虚函数表该如何生成？如何绑定？对象还没完成构造，如何动态绑定虚函数表！</p>
<p>以上是个人觉得对虚析构函数机制的深入了解。</p>
]]></content>
    <summary type="html"><![CDATA[<p>C++是门神奇的语言，总是有一些不能以我们“程序员”编写它的角度去理解的问题，究其根本，大多都是C++编译器在“适当”的时候，会自动为我们的程序增加或删除一些东西，如果其编译器所做的改动，与我们预期的结果并不相关，自然我们也能得到较好理解的运行结果，然而，深入学习C++之后，就会发现，其中很多特性，必须要掌握，必须要知道编译器做了哪些东西，才能保证程序的正确执行。</p>
<p>C++类的构造，析构函数是C++编译器在编译的过程中，所作“适当”修改的主要场所</p>
]]></summary>
    
      <category term="C/C++" scheme="http://liaoxl.github.io/tags/C/C++/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Image Cosegmentation by Co-Diffusion]]></title>
    <link href="http://liaoxl.github.io/blog/20131204/coseg/"/>
    <id>http://liaoxl.github.io/blog/20131204/coseg/</id>
    <published>2013-12-04T15:51:00.000Z</published>
    <updated>2014-03-16T06:04:18.000Z</updated>
    <content type="html"><![CDATA[<p>这算是大半年来的结果吧，从今年4月份一直做到10月份，有很多很多的尝试，虽然最终在理论上并未有很大的创新，实验结果却比较给力。</p>
<p>协同分割，即不仅要完成分割，而且要将不同图像的分割结果进行“归类”行为</p>
<p>写出了一篇像模像样的paper，正在赶投各种Journal，不知终归何处</p>
<p>看看实验的效果图吧，最好的肯定是我做出来的，哈哈</p>
<a id="more"></a>

<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_co-contra1_%e5%89%af%e6%9c%ac.png" alt="co-contra1"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_co-contrao2-4_%e5%89%af%e6%9c%ac.png" alt="co-contra2"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_co-contraw2-4_%e5%89%af%e6%9c%ac.png" alt="co-contra3"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_cows_%e5%89%af%e6%9c%ac.jpg" alt="cows"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_flowers_%e5%89%af%e6%9c%ac.png" alt="flowers"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_Kendo-EKC4_%e5%89%af%e6%9c%ac.png" alt="kendo-ekc"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_skating1_%e5%89%af%e6%9c%ac.png" alt="skating"></p>
<p>当然，所得到的方法还有很多短板，需要改进，不过暂时没有太多的思路。</p>
]]></content>
    <summary type="html"><![CDATA[<p>这算是大半年来的结果吧，从今年4月份一直做到10月份，有很多很多的尝试，虽然最终在理论上并未有很大的创新，实验结果却比较给力。</p>
<p>协同分割，即不仅要完成分割，而且要将不同图像的分割结果进行“归类”行为</p>
<p>写出了一篇像模像样的paper，正在赶投各种Journal，不知终归何处</p>
<p>看看实验的效果图吧，最好的肯定是我做出来的，哈哈</p>
]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="图像处理" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Cosegmentation" scheme="http://liaoxl.github.io/tags/Cosegmentation/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[尝试hadoop的单机环境搭建]]></title>
    <link href="http://liaoxl.github.io/blog/20131201/hadoop/"/>
    <id>http://liaoxl.github.io/blog/20131201/hadoop/</id>
    <published>2013-12-01T11:34:00.000Z</published>
    <updated>2014-03-16T06:03:50.000Z</updated>
    <content type="html"><![CDATA[<p>近来关注大数据，云计算等相关技术，把Google的三大论文看了一遍，作为非计算机科班的同学，看得有点云里雾里，看了不少书才略微理清楚现在这些流行的大数据框架之间的关系。</p>
<p>Hadoop便是其中一个非常吸引我的框架，打算对其环境进行配置，其中走了不少弯路，想写点记录一下。</p>
<a id="more"></a>

<p>首先，要讨论的是OpenJDK与SunJDK，网上的大堆教程基本都是清一色的要安装SunJDK，为何呢？因为JDK的开源版在1.6.0版本之前，与SunJDK还有一些不同，不能很好的支持hadoop，但在1.6.0版本之后，就可以很好的支持了。</p>
<p>为何要提到这个呢？因为很多系统默认装的就是OpenJDK，如果换成SunJDK，可能会麻烦很多，当然，你可以在有OpenJDK的情况下依旧装上SunJDK，用<a href="#">alternative</a>命令来设置版本，显然这样麻烦许多。比如我对我的linux分盘不够大，我不希望资源被浪费，所以我只愿意安装其中一种。</p>
<p>这里提一下我所走的弯路，我首先卸载了OpenJDK（用不考虑依赖关系的命令），装上SunJDK之后，我又知道了其实OpenJDK不影响，于是我删了SunJDK，重新装了OpenJDK （我是不是太折腾了）</p>
<p>其次，要设置好Java的环境变量，<code>vim /etc/profile</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment"># SET JAVA Environment OpenJDK</span>
<span class="constant">JAVA_HOME</span>=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">1.7</span>.<span class="number">0</span>-openjdk/
<span class="constant">JRE_HOME</span>=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">1.7</span>.<span class="number">0</span>-openjdk/
<span class="constant">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:</span><span class="variable">$JAVA_HOME</span>/<span class="symbol">bin:</span><span class="variable">$JRE_HOME</span>/bin
<span class="constant">CLASSPATH</span>=.<span class="symbol">:</span><span class="variable">$JAVA_HOME</span>/lib/dt.<span class="symbol">jar:</span><span class="variable">$JAVA_HOME</span>/lib/tools.<span class="symbol">jar:</span><span class="variable">$JRE_HOME</span>/lib
export <span class="constant">JAVA_HOME</span> <span class="constant">JRE_HOME</span> <span class="constant">PATH</span> <span class="constant">CLASSPATH</span>
</pre></td></tr></table></figure>

<p>然后，ssh，其实这个我早就安装了。SSH有什么作用呢？一般我们相互访问，都需要输入口令，而SSH则产生一个钥匙，这个钥匙可以自动作为具有访问权限的标识，我们就不需要再去手动的输入命令了，然程序自动调用这个钥匙去开锁吧（这样解释应该是对的吧）</p>
<p>最后，就是hadoop了，可分为几个步骤来讲解</p>
<p>1）添加组和用户：其实这个步骤未必一定需要，但为了计算产生的各种数据不要“污染”你自个的用户区，就建一个账户专门来处理吧。而且，如果是集群的，为了更好编号什么的，一般创建一个易于管理识别的账户。</p>
<p>账户和组的创建可以自己探索了，ubuntu和fedora是不一样的，但都比较容易，注意要添加sudo权限</p>
<p>2）解压hadoop的包，假设创建的用户为<code>hadoop</code>，解压至<code>/home/hadoop/hadoop</code>文件夹下，然后设置hadoop的环境变量，同样<code>vim /etc/profile</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment"># SET For HADOOP</span>
<span class="keyword">export</span> HADOOP_DEV_HOME=/home/hadoop/hadoop
<span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_DEV_HOME</span>/bin
<span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_DEV_HOME</span>/sbin
<span class="keyword">export</span> HADOOP_MAPARED_HOME=<span class="variable">${HADOOP_DEV_HOME}</span>
<span class="keyword">export</span> HADOOP_COMMON_HOME=<span class="variable">${HADOOP_DEV_HOME}</span>
<span class="keyword">export</span> HADOOP_HDFS_HOME=<span class="variable">${HADOOP_DEV_HOME}</span>
<span class="keyword">export</span> YARN_HOME=<span class="variable">${HADOOP_DEV_HOME}</span>
<span class="keyword">export</span> HADOOP_CONF_DIR=<span class="variable">${HADOOP_DEV_HOME}</span>/etc/hadoop
</pre></td></tr></table></figure>

<p>记住这里改完，应该以hadoop用户身份，进行source，才会生效</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">source</span> /etc/profile
</pre></td></tr></table></figure>

<p>3）配置xml文件<br>需要配置的xml文件包括：<code>core-site.xml</code>, <code>hdfs-site.xml</code>, <code>mapred-site.xml</code>(这个好似没有这个文件，有个文件叫做mapred-site.xml.template吧，拷贝一个并命名为mapred-site.xml), <code>yarn-site.xml</code><br>这四个xml的作用目前我还不是特别清楚，看起来像是部署数据存取的位置以及node的命名，如下配置：（注：上面类似：file:/home/hadoop/dfs/name的目录我都手动创建了，不知运行时它会否自动创建）</p>
<p>core-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://localhost:8020<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;<span class="title">description</span>&gt;</span> The name of the default file system<span class="tag">&lt;/<span class="title">description</span>&gt;</span>
        <span class="tag">&lt;<span class="title">final</span>&gt;</span>true<span class="tag">&lt;/<span class="title">final</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>hdfs-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>&lt;configuration&gt;
    &lt;<span class="keyword">property</span>&gt;
        &lt;<span class="property">name</span>&gt;dfs.namenode.<span class="property">name</span>.dir&lt;/<span class="property">name</span>&gt;
        &lt;value&gt;<span class="type">file</span>:/home/hadoop/dfs/<span class="property">name</span>&lt;/value&gt;
        &lt;description&gt;Determines <span class="keyword">where</span> <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> <span class="keyword">local</span> filesystem <span class="keyword">the</span> DFS <span class="property">name</span> node should store <span class="keyword">the</span> <span class="property">name</span> table. If this <span class="keyword">is</span> a comma-delimited <span class="type">list</span> <span class="keyword">of</span> directories <span class="keyword">then</span> <span class="keyword">the</span> <span class="property">name</span> table <span class="keyword">is</span> replicated <span class="keyword">in</span> all <span class="keyword">of</span> <span class="keyword">the</span> directories, <span class="keyword">for</span> redundancy. &lt;/description&gt;
        &lt;final&gt;<span class="constant">true</span>&lt;/final&gt;
    &lt;/<span class="keyword">property</span>&gt;

    &lt;<span class="keyword">property</span>&gt;
        &lt;<span class="property">name</span>&gt;dfs.datanode.data.dir&lt;/<span class="property">name</span>&gt;
        &lt;value&gt;<span class="type">file</span>:/home/hadoop/dfs/data&lt;/value&gt;
        &lt;description&gt;Determines <span class="keyword">where</span> <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> <span class="keyword">local</span> filesystem an DFS data node should store <span class="keyword">its</span> blocks. If this <span class="keyword">is</span> a comma-delimited <span class="type">list</span> <span class="keyword">of</span> directories, <span class="keyword">then</span> data will be stored <span class="keyword">in</span> all named directories, typically <span class="function_start"><span class="keyword">on</span></span> different devices.Directories <span class="keyword">that</span> do <span class="keyword">not</span> exist are ignored
        &lt;/description&gt;
        &lt;final&gt;<span class="constant">true</span>&lt;/final&gt;
    &lt;/<span class="keyword">property</span>&gt;

    &lt;<span class="keyword">property</span>&gt;
        &lt;<span class="property">name</span>&gt;dfs.replication&lt;/<span class="property">name</span>&gt;
        &lt;value&gt;<span class="number">1</span>&lt;/value&gt;
    &lt;/<span class="keyword">property</span>&gt;

    &lt;<span class="keyword">property</span>&gt;
        &lt;<span class="property">name</span>&gt;dfs.permissions&lt;/<span class="property">name</span>&gt;
        &lt;value&gt;<span class="constant">false</span>&lt;/value&gt;
    &lt;/<span class="keyword">property</span>&gt;
&lt;/configuration&gt;
</pre></td></tr></table></figure>

<p>mapred-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.system.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:/home/hadoop/mapred/system<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;<span class="title">final</span>&gt;</span>true<span class="tag">&lt;/<span class="title">final</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.local.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:/home/hadoop/mapred/local<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;<span class="title">final</span>&gt;</span>true<span class="tag">&lt;/<span class="title">final</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>yarn-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>

<span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>org.apache.hadoop.mapred ShuffleHandler<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>4）修改hadoop-env.sh, <code>vim /home/hadoop/hadoop/etc/hadoop/hadoop-env.sh</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment"># export JAVA_HOME=${JAVA_HOME}</span>
export <span class="constant">JAVA_HOME</span>=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">1.7</span>.<span class="number">0</span>-openjdk/
</pre></td></tr></table></figure>

<p>5）测试</p>
<p>格式化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>hdfs namenode -<span class="built_in">format</span>
</pre></td></tr></table></figure>

<p>如果出现<code>EXIT 0</code>，说明（应该）成功了</p>
<p>启动DFS</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>hadoop-daemon.sh <span class="operator"><span class="keyword">start</span> namenode
hadoop-daemon.sh <span class="keyword">start</span> datanode</span>
</pre></td></tr></table></figure>

<p>使用jps查看进程是否启动（会显示namenode和datanode）<br>jps类似于一个进程查看器，即查看JVM中的当前进程，这些进程的启动都会有log，可以直接去看log看有否启动成功。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>jps
</pre></td></tr></table></figure>

<p>可以访问这个网页</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="label">http:</span>//localhost:<span class="number">50070</span>/dfshealth<span class="preprocessor">.jsp</span>
</pre></td></tr></table></figure>

<p>关闭DFS</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>hadoop-daemon.sh <span class="keyword">stop</span> namenode
hadoop-daemon.sh <span class="keyword">stop</span> datanode
</pre></td></tr></table></figure>

<hr>
<h3 id="EOF">EOF</h3>
<p>关于对hadoop的尝试先就到这吧</p>
]]></content>
    <summary type="html"><![CDATA[<p>近来关注大数据，云计算等相关技术，把Google的三大论文看了一遍，作为非计算机科班的同学，看得有点云里雾里，看了不少书才略微理清楚现在这些流行的大数据框架之间的关系。</p>
<p>Hadoop便是其中一个非常吸引我的框架，打算对其环境进行配置，其中走了不少弯路，想写点记录一下。</p>
]]></summary>
    
      <category term="hadoop" scheme="http://liaoxl.github.io/tags/hadoop/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 与 系统剪贴板clipboard]]></title>
    <link href="http://liaoxl.github.io/blog/20131117/vim-clipboard/"/>
    <id>http://liaoxl.github.io/blog/20131117/vim-clipboard/</id>
    <published>2013-11-17T06:41:00.000Z</published>
    <updated>2014-03-16T06:03:38.000Z</updated>
    <content type="html"><![CDATA[<p>在fedora 17下，刚开始不太习惯vim的时候，也没发现默认装的vim不能使用系统剪贴板这个问题，后来用多了，发现居然不能从vim复制到系统剪贴板，刚开始我还以为我快捷键使用的不对，但试过多次，均不成功。于是乎，在vim中想复制就必须用gedit打开，然后用鼠标类似windows的操作来完成复制操作，对于常用文件夹可能还不觉得有多么烦，但有些路径深的，那就实在是非常不爽！！</p>
<p>命令那么简单，怎么会搞错呢？后来我才发现，原来系统自带的（我的要么是一安装就有，要么就是我用yum安装的）是不具备这个功能的，即<code>&quot;+y</code>不适应。怎样查看自己的vim版本是否支持系统剪贴板呢？通过以下命令，如果<code>clipboard</code>前面是个减号，则说明系统编译时候未加入clipboard这个选项</p>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>[moondark@Moondark ~]$ vim --version|grep <span class="built_in"><span class="keyword">clipboard</span></span>
-<span class="built_in"><span class="keyword">clipboard</span></span>       +iconv           +path_extra      -toolbar
+eval            +mouse_dec       +startuptime     -xterm_clipboard
</pre></td></tr></table></figure>

<p>很显然解决这个问题有个很直接的方法：<strong>重编译支持系统剪贴板的Vim</strong></p>
<p>然而我就觉得很不爽，想找个不重新编译就能解决的方法，这个时候我想到了我之前试过的一个命令行复制工具<code>xclip</code>，用它配合vim就能够实现使用系统剪贴板了。在网上看到有人说<code>xclip</code>会因为<code>detach</code>在关闭vim后失效，用<code>xsel</code>会更好，我目前还没接触到，所以就先使用这个先吧，具体命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>" \c                  复制至公共剪贴板
vmap <span class="tag">&lt;<span class="title">leader</span>&gt;</span>c :!xclip -selection clipboard<span class="tag">&lt;<span class="title">CR</span>&gt;</span>u
</pre></td></tr></table></figure>

<p>我是将复制命令映射到<code>\c</code>上了，这个可以自定义，目前用着还觉得挺方便的。</p>
<p>更多关于我的vim配置，可见我的<a href="https://github.com/liaoxl/dotfiles" target="_blank">dotfiles</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>在fedora 17下，刚开始不太习惯vim的时候，也没发现默认装的vim不能使用系统剪贴板这个问题，后来用多了，发现居然不能从vim复制到系统剪贴板，刚开始我还以为我快捷键使用的不对，但试过多次，均不成功。于是乎，在vim中想复制就必须用gedit打开，然后用鼠标类似windows的操作来完成复制操作，对于常用文件夹可能还不觉得有多么烦，但有些路径深的，那就实在是非常不爽！！</p>
<p>命令那么简单，怎么会搞错呢？后来我才发现，原来系统自带的（我的要么是一安装就有，要么就是我用yum安装的）是不具备这个功能的，即<code>&quot;+y</code>不适应。怎样查看自己的vim版本是否支持系统剪贴板呢？通过以下命令，如果<code>clipboard</code>前面是个减号，则说明系统编译时候未加入clipboard这个选项</p>
]]></summary>
    
      <category term="Vim" scheme="http://liaoxl.github.io/tags/Vim/"/>
    
      <category term="Xclip" scheme="http://liaoxl.github.io/tags/Xclip/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Graphcuts 与 Kmeans]]></title>
    <link href="http://liaoxl.github.io/blog/20131116/graphcuts-kmeans/"/>
    <id>http://liaoxl.github.io/blog/20131116/graphcuts-kmeans/</id>
    <published>2013-11-16T10:30:00.000Z</published>
    <updated>2014-03-16T06:03:18.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    
    
      <category term="最大流" scheme="http://liaoxl.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="Kmeans" scheme="http://liaoxl.github.io/tags/Kmeans/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Frequency Tuned Saliency]]></title>
    <link href="http://liaoxl.github.io/blog/20131109/frequency-tuned-saliency/"/>
    <id>http://liaoxl.github.io/blog/20131109/frequency-tuned-saliency/</id>
    <published>2013-11-09T12:03:00.000Z</published>
    <updated>2014-03-16T06:02:57.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ivrgwww.epfl.ch/supplementary_material/RK_CVPR09/Images/SaliencyIntro.jpg" alt="Introduction"></p>
<p>在近年来，图像相关的会议或者杂志中，炒的比较热的一个词是：<strong>显著性</strong>！</p>
<h3 id="何谓显著性？">何谓显著性？</h3>
<p>顾名思义，显著性就是指不同于一般性质的一种表现，通常它都是不好量化衡量的。</p>
]]></content>
    
    
      <category term="Saliency" scheme="http://liaoxl.github.io/tags/Saliency/"/>
    
      <category term="图像处理" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[刷完leetcode的一点感想]]></title>
    <link href="http://liaoxl.github.io/blog/20131102/shua-wan-leetcode/"/>
    <id>http://liaoxl.github.io/blog/20131102/shua-wan-leetcode/</id>
    <published>2013-11-02T10:47:00.000Z</published>
    <updated>2014-03-16T06:02:25.000Z</updated>
    <content type="html"><![CDATA[<p>两年前，在实习生笔试的时候，笔试百度，对试卷上很多问题感到不知所云，毫无悬念的挂了</p>
<p>读研两年，今年代笔百度，发现算法题都见过，或者有思路，但一时之间居然都想不到很好的解法，而且很少手写思路，手写代码，有点仓皇失措；概念题却是很难答好，大多我都知道，但却难以描述清楚；最后一题大题，是设计分布式缓存系统，需要考虑负载均衡以及增删设备，我知识面比较窄，居然不知有一致性哈希，于是又跪了</p>
<p>痛定思痛，虽然我明年找工作，若以这样的状态和水平去笔试，面试，难以有什么好结果。</p>
<a id="more"></a>

<p>从笔试回来之后怒刷leetcode，约摸一个月有余，今天终于刷完142题（最后一题word ladder2是看答案copy的），纪念一下，并总结下这段时间狂刷题的感觉：</p>
<p><img src="http://images.cnitblog.com/blog/286484/201311/01214116-d82ca8508af049e290529faedbc8fc38.png" alt="leetcode-welcome"></p>
<ul>
<li><p>从做上面的题，我发现我更擅长一些数学技巧不高的程序题，习惯靠直觉立马书写代码，而非严格推理之后，再书写代码</p>
</li>
<li><p>对于链表的题比较擅长，链表可以在纸上画画，关键要考虑的问题，就是链表指针在运算中会改变，如何保存需要保存的链表指针值是难点，除了那题拷贝具有random指针的链表题，其他链表题我都比较快速的AC掉</p>
</li>
<li><p>对于树的题，常见的方法有：BFS和递归（可以看作是DFS），整体来说，难度也不大，其中递归应该是最常用的，递归的方法需要注意的就是边界判定；当然另一个问题，就是很多情况下，会被要求写非递归的解法，比如说树的遍历，或者知先序中序构建树，这些问题我得好好研究</p>
</li>
<li><p>对于求解题的BFS和DFS得到了比较大的锻炼，之前一直感觉模糊的掌握了DFS和BFS这两种搜索方法，事实上，直到现在才算是掌握的比较不错，对于leetcode上面的很多题，如果不限时的话，我都能以DFS搞定（起码能有20题以上），BFS往往在求解最先到达或者最短时间的时候用到，用起来感觉还不错</p>
</li>
<li><p>对于DP还是不算很熟悉，除了LCS，LIS还有编辑距离这样的经典DP题，其他我都很少往DP想，为什么我总觉得DP有点难理解呢？</p>
</li>
<li><p>关于DP和BFS，DFS求解的选择问题：一般来说，需要记录解（由哪些组成）优先选择BFS和DFS，它们在运算的时候能够很好的保存中间结果；对于DP，适合求解最终结果是怎么的情况，比如求值（最长公共子序列），或者判断是否存在（bool），DP如果要输出最优路径的话，是个比较麻烦的问题，一般还需要设置一个观测DP在选择表中如何移动的数组，关于DP我要好好训练下。</p>
</li>
<li><p>对STL熟悉了很多，用过很多之前都没用过的容器，几乎都用遍了吧：set,map,hash_set(unordered_set),hash_map(unordered_map),multimap,multiset(?好像这个我没用过),vector,string,pair,stack,queue等等，以及algorithm的函数，比如sort, unique,这些STL提供的，真是极大的方便了生活，以前经常得自己写一些基本数据结构，然而，自己写的再好哪有STL的好用啊！</p>
</li>
<li><p>对于在电脑面前写一些简单的算法程序应该是没很大问题了，但接下来的问题是：1,手写我要跪，虽然现在用vim，但我思路经常很跳，经常想起来就在前面插入，纸上可没这条件；2,一些基本的算法还不够熟练，比如快排，堆排，归并，KMP，等等，要立马写出一个bug free并且efficient&amp;&amp;elegant的代码是件不容易的时，我以后得专门在github上面建一个repo好好练习，自己写给自己看</p>
</li>
<li><p>leetcode上的大部分题都有不止一种解法，得好好看看其他人的解法，并且总结总结自己的解法</p>
</li>
</ul>
<p>对做leetcode的总结大致如此了。</p>
<p> 看了一些大公司的笔试面试题，尤其是笔试题，都特别广泛特别杂，要想在笔试拿高分，我还需要看很多很多书籍，一般数据结构题占试卷的分数也就30%的样子，如果其它题了解不够深的话，基本也难拿多高的分，所以一大波书在等待着我；另一方面，由于我是C/C++系，其实很多C++的高级机制都不知道，有些知道了由于不常用，后来也忘了，这个必须得好好总结。</p>
]]></content>
    <summary type="html"><![CDATA[<p>两年前，在实习生笔试的时候，笔试百度，对试卷上很多问题感到不知所云，毫无悬念的挂了</p>
<p>读研两年，今年代笔百度，发现算法题都见过，或者有思路，但一时之间居然都想不到很好的解法，而且很少手写思路，手写代码，有点仓皇失措；概念题却是很难答好，大多我都知道，但却难以描述清楚；最后一题大题，是设计分布式缓存系统，需要考虑负载均衡以及增删设备，我知识面比较窄，居然不知有一致性哈希，于是又跪了</p>
<p>痛定思痛，虽然我明年找工作，若以这样的状态和水平去笔试，面试，难以有什么好结果。</p>
]]></summary>
    
      <category term="leetcode" scheme="http://liaoxl.github.io/tags/leetcode/"/>
    
      <category term="求职面试" scheme="http://liaoxl.github.io/tags/%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从图割到图像分割（三）——多层图图割]]></title>
    <link href="http://liaoxl.github.io/blog/20131021/duo-ceng-tu/"/>
    <id>http://liaoxl.github.io/blog/20131021/duo-ceng-tu/</id>
    <published>2013-10-21T11:42:00.000Z</published>
    <updated>2014-03-16T06:02:01.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_MultiGraph.jpg" height="300px" width="30%" align="right" /></p>
<p>完整的了解了图割方法处理图像分割之后，在已有的<a href="#">graphcuts</a>开源代码的情况下，接下来就是自己创作的时间了。</p>
<p>如前面所说，图的构建是很有讲究的，何时采用四邻域，何时采用八邻域，何时采用K近邻，再何时采用全邻域？</p>
<p>这些都是很有讲究的，很多人就是在这上面稍加改动，就能发一些顶级文章。不过确实，通过$Maxflow/Mincut$处理图像时，对图的构造是非常敏感的，哪怕是你改动$Tlink$与$Nlink$的比例，都能产生很大的影响。但敏感归敏感，$Maxflow/Mincut$求取的全局最优解，恰是许多研究或能量优化函数中所梦寐以求的。</p>
<a id="more"></a>

<hr>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_natural_image1.jpg" width="30%" align="right" /></p>
<p>图论方法在交互式分割中，总是将图像分割成前景和背景两类，即用户选定前景，或用户选定前景/背景，或用户选定背景。然而，很明显，在自然图像中，很多情况下并非只有两类，需要选定多类才能达到较好的分割效果。</p>
<p>由两类扩展成多类，是我<a href="http://grid.hust.edu.cn/wenbingtao/" target="_blank">导师</a>提出来的想法，并完善，通过多层图方法完成图像中多类的交互式分割。</p>
<p>其中，多类分割的实现方法，也是在最初<code>Graphcuts</code>源码上进行改进，具体可见我的github，<a href="https://github.com/liaoxl/MultiLayerGraph" target="_blank">MulitLayerGraph</a>。这份代码的主要思想是源自我<a href="#">导师</a>，主要工作是我素未谋面的师兄<a href="#">常峰</a>写的，师兄写的代码比较乱，有些小bug，并且不是用模板来实现的，鉴于我在研究此类问题，并且算是对这类问题非常熟悉了，所以将代码全部重构一下，用模板写了并放在github上面。</p>
<p>从别人的源代码我学到了很多东西，而自己却没有什么贡献，一直感到很惭愧，这份代码应该是我github上面算法含金量最高的了。</p>
<hr>
<h3 id="多层图的构建">多层图的构建</h3>
<p>首先，要了解经典<code>Graphcuts</code>是多少层，它是多少层？是两层，即将目标分为两类；</p>
<p>然后，要明白<code>Tlink</code>的含义，<code>Tlink</code>一般都是通过已观测的信息，所以将目标分为两类时，其<code>Tlink</code>都是通过已观测信息得到的；</p>
<p>其次，将以上的两类变成多类，则通过多类观测的信息，构建多类图（这个多类最初在Boykov的文章中乘坐MultiGraph），长得类似这个形状，可以通俗的认为是有多个源点的图，其对<code>Multi-Label</code>问题的优化可具体看<a href="http://scholar.google.com.hk/scholar?q=Fast+Approximate+Energy+Minimization+via+Graph+Cuts&amp;hl=zh-CN&amp;as_sdt=0&amp;as_vis=1&amp;oi=scholart&amp;sa=X&amp;ei=THmkUv-YKqjpiAeNs4CADQ&amp;ved=0CCkQgQMwAA" target="_blank">Fast Approximate Energy Minimization via Graph Cuts</a>；</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_mg.jpg" align="center" /></p>
<p>我们提出的是<code>MultiLayerGraph</code>，如文章最开始的图所示。每一层（红，蓝，绿）内部的构建都是相同的，如之前的博文所述<code>Nlink</code>，那么上图认为是几层图呢？直观上要么是三层（s，t不算）或五层（s，t各算一层）。<em>然而实际是四层！</em></p>
<hr>
<h3 id="Graphcuts类方法分割得到的类数，取决于<code>Tlink</code>的层数">Graphcuts类方法分割得到的类数，取决于<code>Tlink</code>的层数</h3>
<hr>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_cuts.jpg" align="right" /></p>
<p>我们假定，<code>Tlink</code>表示的都是相似性的倒数，即越相似，<code>Tlink</code>越小，考虑到最大流最小割算法切断的是最小权值，所以最相似的肯定越可能被切断！</p>
<p>于是乎，我们就采取这样的策略：构建N层图，比如上述的四层图；然后根据观测信息设置每层的<code>Tlink</code>；最后，执行最大流算法，并观测当前节点的<code>Tlink</code>是在哪一层被切断！</p>
<p>多层图一个标准的割应该如右图左边的，右边是不对的，并且通过算法是不能得到的。</p>
<hr>
<h3 id="如何判断<code>Tlink</code>是在哪里切断的呢？">如何判断<code>Tlink</code>是在哪里切断的呢？</h3>
<p>这就源自最初的<a href="#">Graphcuts</a>算法了</p>
<p>在开源的<a href="#">Graphcuts</a>算法中，在计算最大流时，一直维护着两颗“树”，一棵是由<code>S</code>延伸出来的；一棵是由<code>T</code>延伸出来的。在最后时刻，由这两棵树交界的部分形成最小割。</p>
<p>那么就有这样一个特点，假设当前<code>Tlink</code>被割断，则上面一个点肯定来自<code>S</code>树，下面一个点肯定属于<code>T</code>树。所以通过这个特点，可以判断在哪切断的 :)</p>
<hr>
<p>这实际上是一种近似的方法，为什么这么说呢？</p>
<p>上面的网络流图中，每一层的节点实际上都是相同的，不同的是<code>Tlink</code>有多层，所以完成一次分类，产生了一些额外的“边”需要计算进来并考虑切断。</p>
<p>不过这个误差不太好估计。</p>
<p>总的来说，图割的结果很取决于参数，一般来说，所有<code>Tlink</code>会统一权值的计算方法，所有<code>Nlink</code>也会统一权值的计算方法；然而<code>Tlink</code>与<code>Nlink</code>的比例该如何设定？</p>
<p>一般只有实验中来知道吧。</p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_MultiGraph.jpg" height="300px" width="30%" align="right" /></p>
<p>完整的了解了图割方法处理图像分割之后，在已有的<a href="#">graphcuts</a>开源代码的情况下，接下来就是自己创作的时间了。</p>
<p>如前面所说，图的构建是很有讲究的，何时采用四邻域，何时采用八邻域，何时采用K近邻，再何时采用全邻域？</p>
<p>这些都是很有讲究的，很多人就是在这上面稍加改动，就能发一些顶级文章。不过确实，通过$Maxflow/Mincut$处理图像时，对图的构造是非常敏感的，哪怕是你改动$Tlink$与$Nlink$的比例，都能产生很大的影响。但敏感归敏感，$Maxflow/Mincut$求取的全局最优解，恰是许多研究或能量优化函数中所梦寐以求的。</p>
]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="最大流" scheme="http://liaoxl.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="多层图" scheme="http://liaoxl.github.io/tags/%E5%A4%9A%E5%B1%82%E5%9B%BE/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从图割到图像分割（二）——图的构造]]></title>
    <link href="http://liaoxl.github.io/blog/20131020/tu-de-gou-zao/"/>
    <id>http://liaoxl.github.io/blog/20131020/tu-de-gou-zao/</id>
    <published>2013-10-20T15:28:00.000Z</published>
    <updated>2014-03-16T05:57:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_graph.png" width="30%" height="200px" align="right" /></p>
<p>之前解释了为什么能用最大流最小割算法来做图像分割，其实更为正式的引用，即为众多paper所写的那样，图割其实是用来优化能量函数的，我是从自己的一些体会来写的，因为“能量函数”这东西，太过虚无飘渺，不够直观，不便于理解。</p>
<p>在我了解了为什么能够用过做图像分割后，又有问题困扰我：为什么我们所见到的图构建都是四邻域或八邻域的？为什么不是一个全域图（两两相连）？</p>
<p>这个问题似乎也有很多搞图像分割的大牛注意到了，他们最初或许是在实验中发现四邻域和八邻域已经很好了，但后来他们还是给为什么这样做提供了理论依据</p>
<a id="more"></a>

<hr>
<h3 id="<a_href="http://en-wikipedia-org/wiki/Markov_random_field" target="_blank">Markov_Random_Field</a>"><a href="http://en.wikipedia.org/wiki/Markov_random_field" target="_blank">Markov Random Field</a></h3>
<p><a href="http://baike.baidu.com/view/2313875.htm" target="_blank">马尔克夫随机场</a>是解释这个问题的最有力理论依据，先看马尔克夫随机场定义：它包含两层意思：一是什么是马尔可夫，二是什么是随机场。</p>
<p>马尔可夫一般是马尔可夫性质的简称。它指的是一个随机变量序列按时间先后关系依次排开的时候，第N+1时刻的分布特性，与N时刻以前的随机变量的取值无关。拿天气来打个比方。如果我们假定天气是马尔可夫的，其意思就是我们假设今天的天气仅仅与昨天的天气存在概率上的关联，而与前天及前天以前的天气没有关系。其它如传染病和谣言的传播规律，就是马尔可夫的。</p>
<p>随机场包含两个要素：位置（site），相空间（phase space）。当给每一个位置中按照某种分布随机赋予相空间的一个值之后，其全体就叫做随机场。我们不妨拿种地来打个比方。“位置”好比是一亩亩农田；“相空间”好比是种的各种庄稼。我们可以给不同的地种上不同的庄稼，这就好比给随机场的每个“位置”，赋予相空间里不同的值。所以，俗气点说，随机场就是在哪块地里种什么庄稼的事情。</p>
<p>好了，明白了上面两点，就可以讲马尔可夫随机场了。还是拿种地打比方，如果任何一块地里种的庄稼的种类仅仅与它邻近的地里种的庄稼的种类有关，与其它地方的庄稼的种类无关，那么这些地里种的庄稼的集合，就是一个马尔可夫随机场。</p>
<p><strong>在图割的图构造里面，其实就是：当前节点只与邻近的四邻域或八邻域节点相关，故可以只构建四邻域或八邻域图</strong></p>
<hr>
<h3 id="图构造的数学模型">图构造的数学模型</h3>
<p>说到这里，先看看典型的能量函数模型：</p>
<p>$E(L)=\sum<em>{p\in{P}}D_p(L_p) + \sum</em>{(p,q)\in{N}}V_{p,q}(L_p,L_q)$</p>
<p>这里有$L=\lbrace L_p \mid p\in{P} \rbrace$</p>
<p>以上两项都叫做惩罚项，意味着突袭那个分割的每一次“割断”，都会带来惩罚，如何使得总惩罚最小，即可看作是最优的完成了图像分割的任务。</p>
<p>然而，假使要使得能量函数最优时即为最好的分割结果，上式每项就必须赋予相应的含义，否则构建一个与分割无关的能量函数模型，即使将能量函数最小化，也无任何意义。</p>
<p>我们知道基于图割的图像分割大多都是交互式分割，什么叫做交互式分割？就是用户提供一些先验知识，然后根据这些先验知识对原有的数学模型进行量化，得到一个可优化的数学表达式。例如，用户可以通过认定一张图像上的一个苹果是他所要的目标，则他在图像上圈定苹果，我们程序知道了用户圈定的点是属于前景点，则可以将所有类似苹果的像素点都归类为前景点，这就是交互式的一种方法。</p>
<p>在此也是，前面一项$D_p(L_p)$表示根据观测信息（用户提供）判断当前点是否归类为前景点，并且设定，如果归类错误，其付出的代价是多少。</p>
<p>也许由前面的信息就可以大致判断当前像素的归类了，那后面一项有什么意义呢？</p>
<p>后面一项表示相邻像素点间的约束信息，举个例子：如果当前像素属于前景点，那么它左边一个点或者右边一个点与当前点相似，那么它属于前景的概率是不是也很大？在前面一项不能准确判断的时候，这时候这个约束关系就作用明显了。</p>
<hr>
<h3 id="Tlink的构建">Tlink的构建</h3>
<p><code>Tlink</code>，在能量函数中一般称为数据项，即上式左半部分：$D_p(L_p)$，在图的构建中为与源点，汇点相连的边的权值，<code>T</code>在这里表示<code>Terminal</code>，一般而言，源点表示的是前景，汇点表示的是背景。</p>
<p>如前面所说，<code>Tlink</code>的构建与所给信息相关，考虑到$Maxflow/Mincut$切断的是权值最小的点，假设用相似性作为<code>Tlink</code>的权值的话，则如果当前像素属于前景，切断的应该是与汇点连接的<code>Tlink</code>，反之则切断与源点相连接的<code>Tlink</code>。</p>
<p>假设，将相似性归一化，则相似性可看作是属于某一类的概率值，如根据已有信息，得到某个归一化的相似性权值<code>p</code>，则可以说它属于前景的概率为<code>p</code>，这样属于背景的概率就是<code>1-p</code>了。</p>
<p>当然很多情况下，为了公平起见，还是会提供一些背景点，用类似前景<code>Tlink</code>的方法构建背景<code>Tlink</code>。</p>
<p>然而，这里就有个问题：在我有一堆点作为前景点的前提下，我如何算一个点与给定点的相似度？</p>
<p>事实上，这本身就是一个值得探讨的问题，我只是说说我见过的一些方法：</p>
<p>1）算距离平均值/得到中心点算距离;</p>
<p>2）算与最近/最远点的距离；</p>
<p>3）用已有点构建单高斯模型，用所构建的单高斯模型算相似性；</p>
<p>4）用已有点构建多高斯模型(GMM)，用所构建的GMM来算相似性；</p>
<p>这些都是比较常用的方法，在所发表的文章中看，用的最多的是4,我想一来是效果好，而来是有更好的理论可以些（原来我这么揣测）</p>
<hr>
<h3 id="Nlink的构建">Nlink的构建</h3>
<p>对比来说，<code>Nlink</code>的构建是比较简单的。这里<code>N</code>可以解释为<code>Neighbor</code>，在图的构造上即为相互邻接的像素点相连，<code>Nlink</code>表示“邻接”像素点之间的约束关系，即切断“邻接”像素点（换句话说，将邻接的像素点分为不同类）所需花费的惩罚，所以简单来说，就只需要弄清两个问题：</p>
<p>1）怎样算是“邻接”？</p>
<p>2）作为邻接的像素点，其权值如何设定？</p>
<p>一般来说，“邻接”都是采用四邻域或八领域，理由如前面所述，权值的设定，一般都采用高斯权值：</p>
<p>$$ w_{ij}=\left{<br>\begin{aligned}<br>&amp; exp(-\beta\parallel{f(i)-f(j)}^2) &amp;  如果(i,j)相邻\<br>&amp; 0 &amp;  其他 \<br>\end{aligned}<br>\right.<br>$$</p>
<p>$\beta$是用来控制权值比重的，$f(i), f(j)$分别表示像素<code>i</code>与像素<code>j</code>的特征，这里的特征既可以指颜色特征，也可以指其它特征。</p>
<hr>
<h3 id="简略总结<code>Tlink</code>与<code>Nlink</code>的作用">简略总结<code>Tlink</code>与<code>Nlink</code>的作用</h3>
<p><code>Tlink</code>作为数据项，尽可能的将像素归类为正确的类别，保证像素分类的正确性；</p>
<p><code>Nlink</code>作为平滑项，尽可能的约束相邻像素不被切断，保持数据的平滑，在图像上，表现为边界平滑；</p>
<p>最终结果在以上两者的共同影响下得到！</p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/420237/o_graph.png" width="30%" height="200px" align="right" /></p>
<p>之前解释了为什么能用最大流最小割算法来做图像分割，其实更为正式的引用，即为众多paper所写的那样，图割其实是用来优化能量函数的，我是从自己的一些体会来写的，因为“能量函数”这东西，太过虚无飘渺，不够直观，不便于理解。</p>
<p>在我了解了为什么能够用过做图像分割后，又有问题困扰我：为什么我们所见到的图构建都是四邻域或八邻域的？为什么不是一个全域图（两两相连）？</p>
<p>这个问题似乎也有很多搞图像分割的大牛注意到了，他们最初或许是在实验中发现四邻域和八邻域已经很好了，但后来他们还是给为什么这样做提供了理论依据</p>
]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="最大流" scheme="http://liaoxl.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从图割到图像分割（一）——最大流算法]]></title>
    <link href="http://liaoxl.github.io/blog/20131013/tu-ge/"/>
    <id>http://liaoxl.github.io/blog/20131013/tu-ge/</id>
    <published>2013-10-13T13:42:00.000Z</published>
    <updated>2014-03-16T06:01:29.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://vision.csd.uwo.ca/wiki/vision/upload/8/85/Maxflow_mincut.png" height="300px" width="30%" align="right" /></p>
<p>《算法导论》对最大流的介绍是：最大流问题是关于流网络的最简单的问题，它提出这样的问题：在不违背容量限制的条件下，把物质从源点传输到汇点的最大速率是多少？</p>
<p>更多关于网络流的介绍请看<a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81" target="_blank">网络流wiki</a></p>
<p>我最初接触最大流问题是在2011年，那时候我大四，刚保研完，去问导师我需要看哪些方面的书，老板说去把《算法导论》图论相关，以及把最大流最小割算法仔细看一遍。</p>
<p>图论算法在众多算法中算是比较复杂的了，首先读入数据需要构建邻接矩阵，然后再进行求解，求解过程显得并不是很直观。当时我对最大流最小割算法本身就不是很明了，更不明白如何可以应用到图像分割中，现在终于有些体会。<br><a id="more"></a></p>
<hr>
<h3 id="最大流算法">最大流算法</h3>
<p>从算法导论书中，最大流算法分为两种：</p>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm" target="_blank">Ford-Fulkerson方法</a>：书上对该“方法”进行了解释，之所以称作“方法”而不是“算法”，是因为Ford-Fulkerson方法是一种思想，而对这思想的实现，有不同的优化方法</li>
</ol>
<p>以<a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm" target="_blank">Ford-Fulkerson方法</a>为思想的最快算法为：</p>
<p><a href="http://www.nocow.cn/index.php/Dinic%E7%AE%97%E6%B3%95" target="_blank">Dinic算法</a>时间复杂度为：$O(n^2m)$，其中n为顶点数，m为边数</p>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm" target="_blank">压入重标记方法(push-relabel)</a>：这同样也是一种思想，具体实现也有不同的优化实现方法。</li>
</ol>
<p>基于<a href="http://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm" target="_blank">压入重标记方法(push-relabel)</a>方法的最快的方法有两种：</p>
<p><a href="#">H_PRF</a>时间复杂度为（最坏）$O(n^2\sqrt{m})$</p>
<p><a href="#">Q_PRF</a>时间复杂度为（最坏）$O(n^3)$</p>
<hr>
<h3 id="最大流=&gt;最小割">最大流=&gt;最小割</h3>
<p>决定最大流算法能够应用在图像分割的原因，就在于这条定理了</p>
<p>割的定义：</p>
<p>流网络$G=(V,E)$的<em>割</em>$(S,T)$将$V$划分为$S$和$T=V-S$两部分，使得$ s\in{S},t\in{T} $。如果$f$是一个流，则穿过割$(S,T)$的净流被定义为$f(S,T)$，割$(S,T)$的容量为$c(S,T)$。一个网络的<strong>最小割</strong>也就是网络中所有割中具有最小容量的割。</p>
<p><strong>最大流最小割</strong>定理<br>如果$f$是具有源点$s$和汇点$t$的流网络$G=(V,E)$中的一个流，则下列条件是等价的：</p>
<ul>
<li>$f$是$G$的一个最大流</li>
<li>残留网络$G<em>f$不包含增广路径</em></li>
<li>对于$G$的某个割$(S,T)$，有$f=c(S,T)$</li>
</ul>
<p>其中第三条，说明最大流的值实际上等于某一最小割的容量，即可以用最大流来求取最小割：<br>$$|f|=f(S,T)=\sum<em>{u\in{S}}\sum</em>{v\in{T}}f(u,v)\leq\sum<em>{u\in{S}}\sum</em>{v\in{T}}c(u,v)$$</p>
<hr>
<h3 id="为何可以用最小割算法来分割图像？">为何可以用最小割算法来分割图像？</h3>
<p>这个问题我刚接触图割的时候，就想了很久，刚开始我在直观上比较难理解</p>
<p>首先，要理解，最大流算法得到的最小割有什么意义？如果写过最大流算法，或者看明白最大流算法的都知道，在一个增广路径中，限制流容量增加的，就是其中具有最小流量的路径，如果将流从$S$向$T$推送，最终将形成由“最小容量”的一个割，这个割就是最小割，由这些“最小容量”的容量加起来即为最大流（实际上称作最大净流好些）</p>
<p>其次，图像是可以看作由一个个像素组成的巨大图，假设我将像素一一用边连接起来，则这些像素点会成为这个巨大图网络的顶点，如果能利用最大流算法，求取其最小割，通过最小割分开的顶点就是边权值相对较小的点，假设我边的权值与顶点间的相似度成正比，那么最小割分开的顶点就是相似度最小的点，即，通过最大流算法，我们将图像分成了一块块相似的像素区，这不就是图像分割吗？</p>
<p>最后，那么从源点能流出多少流呢？从汇点又能接收多少流呢？如果都是无穷大，那还会形成分割吗？显然这是需要限制的。如果从像素点中选出两个点，一个作为源点，一个作为汇点，图像中其它点与源点的相似度作为流入的流量，与汇点的相似度作为流出的流量，则应用最大流算法得到的结果，即将点分为两部分，一部分属于“相似于”源点，一部分“相似于”汇点，而又由于像素点两两相连，为保证像素间的光滑性，会产生相对光滑的分界。</p>
<p>实际中，像素点连接源点或汇点的边叫做T-Link、像素点相互连接的边叫做N-Link、T-link的构造当然要比上述我说的要复杂，而N-Link也不要求要两两相连，T-Link约束了像素点与给顶点的相似性，而N-Link约束了像素点之间的光滑性。</p>
<p>在Paper中，对构图的描述方式不一样，一般描述为目标函数为一个能量函数，而这个能量函数的优化，可以转化为一个最小割方法来求解。</p>
<hr>
<h3 id="Min-Cut/Max-Flow">Min-Cut/Max-Flow</h3>
<p>讲到最大流最小割算法，不得不提到大名鼎鼎的<a href="http://www.csd.uwo.ca/~yuri/" target="_blank">Boykov</a>和<a href="http://pub.ist.ac.at/~vnk/" target="_blank">Kolmogorov</a>，这两位牛人在2004年图像领域最顶级杂志TPAMI的一篇文章：<a href="http://www.csd.uwo.ca/~yuri/Papers/pami04.pdf" target="_blank">An Experimental Comparison of Min-Cut/Max-Flow Algorithms for Energy Minimization in Vision</a>，讲述了如何将图像分割转化为一个能量函数优化问题，并且如何用最大流最小割算法对其进行优化，此外，他们提供了开源的<a href="http://vision.csd.uwo.ca/code/maxflow-v3.01.zip" target="_blank">代码库</a>，提供了非常友好的接口给相关研究者调用，从而使得基于图割的图像分割思想广泛应用，其中包括后来大名鼎鼎的<a href="#">Lazy Snapping</a>和<a href="#">Grab Cut</a>。像Photoshop，美图秀秀等基于交互式分割得到目标的功能基本源于图割方法。</p>
<p>图割方法在之前的图像分割领域并非没有用过，之所以后来应用广泛，我认为很大一部分原因得益于开源代码库：实现一个最大流算法并非特别难的事，但如何高效实现，以及由于图像像素点很多，如何有效管理实现过程中的内存分配，及如何提供一个简单易用的接口，恐怕是绝大部分之前的人研究遇到的难点。</p>
<p><a href="http://www.csd.uwo.ca/~yuri/" target="_blank">Boykov</a>和<a href="http://pub.ist.ac.at/~vnk/" target="_blank">Kolmogorov</a>在文章中提出的maxflow算法是一种增广路径算法，其方法的时间复杂度为$O(n^2m|C|)$。从理论上讲，其时间复杂度大于以上三种，但实际的表现效果，优于以上所有（我猜应该是与图像所构成的图的特殊结构有关）。</p>
<p>算法可分为三个步骤：</p>
<ul>
<li>“growth” stage: search trees S and T grow until they touch giving an s → t path</li>
<li>“augmentation” stage: the found path is augmented, search tree(s) break into forest(s)</li>
<li>“adoption” stage: trees S and T are restored.</li>
</ul>
<p>伪代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>initialize: S = {s}, T = {t}, A = {s, t}, O = ∅
<span class="keyword">while</span> <span class="constant">true</span>
	grow S <span class="operator">or</span> T <span class="built_in">to</span> find <span class="operator">an</span> augmenting path P <span class="built_in">from</span> s <span class="built_in">to</span> t
	<span class="keyword">if</span> P = ∅ terminate
	augment <span class="command"><span class="keyword">on</span> <span class="title">P</span></span>
	adopt orphans
<span class="function"><span class="keyword">end</span> <span class="title">while</span></span>
</pre></td></tr></table></figure>

<p>步骤分为三步，基本与增广路径算法一致，其从S和T分别开始搜索，实际就是双向广搜，分别维持着一个属于S的队列和一个属于T的队列，当S的队列找到下一个节点，并发现下一个节点属于T的队列时，进行增广，并记录瓶颈流（bottleneck flow）所在位置，由于这些瓶颈流在增广后被移除，变为0后，需要重新看还有否必要将这些节点放入到队列中，这一步叫做adoption。名字还挺不错:)</p>
<p>具体可见代码实现，由于其给出的库是由Template方式编写，而且用了一些自己定义数据结构，所以代码不易看懂，需要耐心体会。</p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://vision.csd.uwo.ca/wiki/vision/upload/8/85/Maxflow_mincut.png" height="300px" width="30%" align="right" /></p>
<p>《算法导论》对最大流的介绍是：最大流问题是关于流网络的最简单的问题，它提出这样的问题：在不违背容量限制的条件下，把物质从源点传输到汇点的最大速率是多少？</p>
<p>更多关于网络流的介绍请看<a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81" target="_blank">网络流wiki</a></p>
<p>我最初接触最大流问题是在2011年，那时候我大四，刚保研完，去问导师我需要看哪些方面的书，老板说去把《算法导论》图论相关，以及把最大流最小割算法仔细看一遍。</p>
<p>图论算法在众多算法中算是比较复杂的了，首先读入数据需要构建邻接矩阵，然后再进行求解，求解过程显得并不是很直观。当时我对最大流最小割算法本身就不是很明了，更不明白如何可以应用到图像分割中，现在终于有些体会。<br>]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="最大流" scheme="http://liaoxl.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用moderncv打造个人简历]]></title>
    <link href="http://liaoxl.github.io/blog/20131011/modercv-resume/"/>
    <id>http://liaoxl.github.io/blog/20131011/modercv-resume/</id>
    <published>2013-10-11T11:20:00.000Z</published>
    <updated>2014-03-16T06:00:36.000Z</updated>
    <content type="html"><![CDATA[<p>本科的时候，简历是word做的，当时觉得做得还不错，也不习惯转为pdf，后面在投递简历的时候居然有时就以word的形式发过去，那时自认好像还不错，居然无知到pdf才是国际的统一标准，word存在各种版本间的问题。</p>
<p>word转pdf自然不失为一种提供pdf简历的方法，但word有很多“自动调整”功能，虽然有时候极大的方便了非技术用户使用，但却非常不方便自己DIY。</p>
<p>恰好近来在写paper，在琢磨了一阵latex，这玩意跟vim差不多，你不用的话，看了再多遍manual都没用，但经常用则很容易理解。<a id="more"></a></p>
<hr>
<p>用latex制作cv的想法源于这个<a href="https://github.com/zellux/resume" target="_blank">开源项目</a>，我把它下载下来，在自己机器上安装了Texlive(系统是Fedora 17)，发现编译中文简历有问题，似乎是编码的问题。我大概看了下这位作者所使用的模板是<a href="http://www.ctan.org/tex-archive/macros/latex/contrib/moderncv" target="_blank">moderncv</a>的模板，所以下载下来自己按照模板写了，并创建了自己的<a href="https://github.com/liaoxl/Resume" target="_blank">简历开源项目</a></p>
<p>如果总结起来的话，其步骤大概如下：</p>
<ol>
<li><p>配置Texlive环境，我当时直接下载的ISO文件（直接<code>yum</code>安装的，因为源里的版本比较旧，对中文支持不好），在我校的<a href="http://mirror.hust.edu.cn/CTAN/systems/texlive/" target="_blank">开源站点</a>，然后用这个命令挂载<code>mount -o loop -t iso9660 /home/moondark/Downloads/texlive2013-20130530.iso /mnt/vcdrom/</code>，当然前提你得在<code>/mnt/</code>目录下创建<code>vcdrom/</code>这个目录;</p>
</li>
<li><p>下载<a href="http://www.ctan.org/tex-archive/macros/latex/contrib/moderncv" target="_blank">moderncv</a>的格式文件;</p>
</li>
<li><p>仿造<a href="http://www.ctan.org/tex-archive/macros/latex/contrib/moderncv" target="_blank">modercv</a>上面的examples来书写自己的简历;</p>
</li>
<li><p>我用<code>pdflatex</code>命令编译的，好像用<code>xelatex</code>命令也可以，具体区别我也不甚清楚</p>
</li>
</ol>
<p>over</p>
]]></content>
    <summary type="html"><![CDATA[<p>本科的时候，简历是word做的，当时觉得做得还不错，也不习惯转为pdf，后面在投递简历的时候居然有时就以word的形式发过去，那时自认好像还不错，居然无知到pdf才是国际的统一标准，word存在各种版本间的问题。</p>
<p>word转pdf自然不失为一种提供pdf简历的方法，但word有很多“自动调整”功能，虽然有时候极大的方便了非技术用户使用，但却非常不方便自己DIY。</p>
<p>恰好近来在写paper，在琢磨了一阵latex，这玩意跟vim差不多，你不用的话，看了再多遍manual都没用，但经常用则很容易理解。]]></summary>
    
      <category term="latex" scheme="http://liaoxl.github.io/tags/latex/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Octopress中添加MathJax]]></title>
    <link href="http://liaoxl.github.io/blog/20130918/octopress-mathjax/"/>
    <id>http://liaoxl.github.io/blog/20130918/octopress-mathjax/</id>
    <published>2013-09-17T16:30:00.000Z</published>
    <updated>2014-03-16T06:00:17.000Z</updated>
    <content type="html"><![CDATA[<p>有些时候写博客需要用到数学公式，需要对Octopress的设置进行更改，才能较好的完成公式的显示</p>
<p>步骤如下：</p>
<ol>
<li><p>安装Kramdown解析器（因为其对MathJax的支持较好），在GemFile文件中添加<code>gem &#39;kramdown&#39;, &#39;~&gt;0.13.8&#39;</code>，保存，执行<code>bundle install</code> 即可；当然也可以用一步命令<code>gem install kramdown</code>;</p>
</li>
<li><p>在<code>_config.yml</code>中修改markdown解析器，将<code>markdown: rdiscount</code> 换为 <code>markdown: kramdown</code>，保存，之所以这么做是因为前者对于MathJax的解析不如后者好；</p>
</li>
<li><p>在<code>source/_includes/custom/head.html</code>中，加入以下脚本，从而使得MathJax能够被使用：</p>
<a id="more"></a>

</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">&lt;!-- MathJax --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript">
MathJax.Hub.Config({
	tex2jax: {
		inlineMath: [ [<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">"\\("</span>,<span class="string">"\\)"</span>] ],
		processEscapes: <span class="literal">true</span>
	}
});
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript">
MathJax.Hub.Config({
	tex2jax: {
		 skipTags: [<span class="string">'script'</span>, <span class="string">'noscript'</span>, <span class="string">'style'</span>, <span class="string">'textarea'</span>, <span class="string">'pre'</span>, <span class="string">'code'</span>]
	}
});
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/x-mathjax-config"</span>&gt;</span><span class="javascript">
MathJax.Hub.Queue(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
		<span class="keyword">var</span> all = MathJax.Hub.getAllJax(), i;
		<span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; all.length; i += <span class="number">1</span>) {
		all[i].SourceElement().parentNode.className += <span class="string">' has-jax'</span>;
		}
		});
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>
	<span class="attribute">src</span>=<span class="value">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;</span><span class="javascript">
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<p>测试显示效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="xml">  $$ a</span><span class="keyword">^2</span><span class="xml"> + b</span><span class="keyword">^2</span><span class="xml"> = c</span><span class="keyword">^2</span><span class="xml"> $$</span>
</pre></td></tr></table></figure>

<p>$$ a^2 + b^2 = c^2 $$</p>
]]></content>
    <summary type="html"><![CDATA[<p>有些时候写博客需要用到数学公式，需要对Octopress的设置进行更改，才能较好的完成公式的显示</p>
<p>步骤如下：</p>
<ol>
<li><p>安装Kramdown解析器（因为其对MathJax的支持较好），在GemFile文件中添加<code>gem &#39;kramdown&#39;, &#39;~&gt;0.13.8&#39;</code>，保存，执行<code>bundle install</code> 即可；当然也可以用一步命令<code>gem install kramdown</code>;</p>
</li>
<li><p>在<code>_config.yml</code>中修改markdown解析器，将<code>markdown: rdiscount</code> 换为 <code>markdown: kramdown</code>，保存，之所以这么做是因为前者对于MathJax的解析不如后者好；</p>
</li>
<li><p>在<code>source/_includes/custom/head.html</code>中，加入以下脚本，从而使得MathJax能够被使用：</p>
]]></summary>
    
      <category term="Octopress" scheme="http://liaoxl.github.io/tags/Octopress/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[说说我的研一]]></title>
    <link href="http://liaoxl.github.io/blog/20130816/yyzj/"/>
    <id>http://liaoxl.github.io/blog/20130816/yyzj/</id>
    <published>2013-08-16T05:09:00.000Z</published>
    <updated>2014-03-16T06:00:05.000Z</updated>
    <content type="html"><![CDATA[<p>我一直觉得，一个人如果善于总结自己已经学过的知识，并为自己定制一些目标，可以在接下来的时间里，更有效率的工作。很可惜，我并不是一个善于总结的人，我总是埋头折腾，然而经常回头一看，发现自己走了很多弯路，幸好我有一些比较聪明的朋友，能够给我一些很有帮助的指导。</p>
<p>很多时候，我的生活就像我在电脑面前搜索，我明明在搜索一个问题的答案，但我却很容易被搜索过程中看到的另外的问题吸引过去，最终迷失了已有的方向。</p>
<a id="more"></a>

<p>在读研期间，我一直在假想，假设我工作了，现在将会是怎样的一番景象，尤其今年化为将工资涨了近30%，两年前，我面对着保研协议和华为的三方协议，选择了保研，现在看到已工作的同学拿着不菲的收入，而现在的我在实验室拿着200元/月的浅薄工资，除了偶尔时间上更为自由一点，依然要苦逼的工作，心里很有一番滋味。</p>
<p>然而，人不能同时走两条路。</p>
<hr>
<h3 id="其实也没做多少事">其实也没做多少事</h3>
<ul>
<li><p>去年这个时候的暑假，我正在帮老板修改paper，完成实验，paper上要求的实验做完之后，我回了一趟家，等待这研一的正式报道。<br>那篇paper我作为三作投了Patter Recognition之后被拒了，从我做实验到我知道被拒，几乎总总过了一年，我开始了解了为什么那么多博士不能按期毕业。</p>
</li>
<li><p>在去年的国庆节，我糅合了两个程序，一个是粒子滤波跟踪的，另一个是光流法跟踪的，作为跟踪来讲，它比原光流跟踪效果要好，在某些特殊情况下可以克服粒子滤波的缺陷，然而，以上这两个方法本身效果也并不出色，所以，即使我在它们的基础上进行改进，其效果依然不登大雅之堂。但我觉得我想法还是有创新之处，可以自己写一片小文章，不过在写成初稿之后，被老板压下，将我换做图像分割方向了。如果有机会，我将之前写的程序转移到linux下，并将其开源吧</p>
</li>
</ul>
<p>其实我是非常愿意做图像分割领域，我老板正擅长这个领域，我当初也是冲着这个来的。只是有点晚，图割做图像分割，我在大四上学期学习过，但未深入了解，我当时只知道图割做图像分割是用最大流最小割定理来证明，并通过网络流算法完成其分割过程的。现在虽然了解了很多网络流算法，但还不能立马手写出，对于图割常用的最大流算法原理也处于比较迷糊的状态。</p>
<p>转到图像分割方向的第一件事居然是修改一个国家自然科学基金的报告。说实话，我真的觉得这些文档类工作在浪费我宝贵的研究生时间。</p>
<ul>
<li><p>转眼到了2013年，过年来学校第一件事就是跟实验室同级同学一起调一个程序，我花了一个多礼拜在linux下给同学搭建了一个较好用的协同分割框架，这个分割框架老板觉得是可以写文章的，然而在五六月份实验结果出来后，效果不尽如人意，老板决定换idea，当然，我并不主要负责那个程序，所以也不关我的事。</p>
</li>
<li><p>后来，我在写一个diversity ranking进行协同分割的程序，准确的说，我是在修改。同时也修改四色标记程序，使其成为一个具有“启发式”的分割程序。直到现在，这两个程序依然是我主要要改进的两个程序。<br>说不定我发paper的唯一希望也就在这里了。</p>
</li>
</ul>
<hr>
<h3 id="目标驱动">目标驱动</h3>
<p>以上都是实验室相关的工作，之所以读研，就是为了个好工作，当然得做点实事：</p>
<p>首先要说的就是APUE了，这本书我最初看不懂，现在也是稍微懂了一点点，以后我还将继续阅读n遍；</p>
<p>其次参加各种竞赛：腾讯马拉松，微软编程之美，中兴捧月，结局基本都一样：通过第一轮，过不了第二轮，甚是遗憾，明年继续努力；</p>
<p>再者，在POJ上面A了70多道题，挤进前1w名（呵呵）；</p>
<p>然后，就是阅读一些与工作相关的书籍，比如Cracking the coding interview, 算法导论，设计模式，其中夹杂着阅读一些新语言相关的内容，比如ruby, nodejs, python等，这些新语言都很有意思，有些的确值得学习一下，同时也逛各种开原社区，如ruby-china, CNode, 也学习了git，github等便捷的使用；</p>
<p>还有很多事需要做……</p>
<hr>
<p>今年工作是相对去年好找的，错失了今年不知道明年我来找工作的时候是怎样的行情？总之好好努力吧。</p>
]]></content>
    <summary type="html"><![CDATA[<p>我一直觉得，一个人如果善于总结自己已经学过的知识，并为自己定制一些目标，可以在接下来的时间里，更有效率的工作。很可惜，我并不是一个善于总结的人，我总是埋头折腾，然而经常回头一看，发现自己走了很多弯路，幸好我有一些比较聪明的朋友，能够给我一些很有帮助的指导。</p>
<p>很多时候，我的生活就像我在电脑面前搜索，我明明在搜索一个问题的答案，但我却很容易被搜索过程中看到的另外的问题吸引过去，最终迷失了已有的方向。</p>
]]></summary>
    
      <category term="胡言乱语" scheme="http://liaoxl.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
      <category term="生活" scheme="http://liaoxl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ACER-4738ZG 拆机改散热]]></title>
    <link href="http://liaoxl.github.io/blog/20130630/acer-4738zg/"/>
    <id>http://liaoxl.github.io/blog/20130630/acer-4738zg/</id>
    <published>2013-06-30T02:13:00.000Z</published>
    <updated>2014-03-16T05:59:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>武汉真是个很热的地方，我的笔记本于2011年3月份左右购买的，到现在已经两年多了，第一个暑假，我是在苏州的空调房使用，第二个暑假，我是在实验室的空调房使用，没有直接感受到夏天对笔记本的杀伤力，今年在寝室使用，在Linux发现无线网不稳定，然后我感觉到手底下的笔记本有些烫，我只是猜测跟发热有关。于是我切回到windows，开了鲁大师监控温度（话说我不知道在linux下如何进行温度监控），发现很快主板就到了报警温度（75度），我尝试打了一盘dota，发现显卡笔记本都超过了报警温度了，我觉得该给笔记本改善下散热了。  <a id="more"></a></p>
<p>首先我想到的，就是给笔记本清灰，当时当机立断，拆机拆风扇，很失望的是发现里面很少的灰。</p>
<p>其次，我想到了买散热底座，我从亚马逊上面买了一个，放回寝室，在实际使用中，发现降温效果实在太有限，而且多了一个底座很不方便，加上那个底座本身走线不好导致有些响，我就退货了。</p>
<p>拆机的时候，看到CPU那里的硅脂已经很干了，显卡上不知道用什么东西垫了一片（我那时还不知道这是叫做散热硅胶片），整体感觉都是很粗糙的样纸，决定给电脑换硅脂。起初从同学那里借了硅脂过来，然而当时有个地方我搞错了，我错以为显卡上的硅胶片只是涂厚一点的硅脂而已，于是我在那里涂厚一点硅脂。结果呢，能够用，但是显卡温度很不稳定，我在网上查阅，才发现那时硅胶片，并且发现了更好的散热解决方案——垫铜片。</p>
<p>于是上网买上等硅脂+铜片<br>一般淘宝上卖这些的，都还会附送一些小玩意，比如多给一个散热硅胶片，然后你可以放在北桥上面改善一下北桥的散热。</p>
<h2 id="接下来是拆机过程（图文）">接下来是拆机过程（图文）</h2>
<p>1，准备工具：<br><img src="http://images.cnitblog.com/blog/286484/201306/30111807-7470419464bb48959b23f28df4ec1be6.jpg" alt="ready1"><br><img src="http://images.cnitblog.com/blog/286484/201306/30111817-9e7d0ed7d0c34e30916a81970074b0ad.jpg" alt="ready2"></p>
<p>2，拆开后盖<br><img src="http://images.cnitblog.com/blog/286484/201306/30111831-1af6a8c754854086afcaa4ec9d7928e1.jpg" alt="back1"><br><img src="http://images.cnitblog.com/blog/286484/201306/30111838-9429c38a799149b18c38c0834b4bae53.jpg" alt="back2"></p>
<p>3，拆开风扇（没什么灰）<br><img src="http://images.cnitblog.com/blog/286484/201306/30111900-ef4b242e592c4c1f88579f555163df20.jpg" alt="fan1"><br><img src="http://images.cnitblog.com/blog/286484/201306/30111909-2f841c9067f74da79985048bddb611f7.jpg" alt="fan2"></p>
<p>4，第一次涂的乱七八糟的硅脂<br><img src="http://images.cnitblog.com/blog/286484/201306/30111921-50686ad030dd4a518cb1174102f43186.jpg" alt="s1"><br><img src="http://images.cnitblog.com/blog/286484/201306/30111930-8ecb9a65ed2d45dbae1bfaf87f11ee1b.jpg" alt="s2"></p>
<p>5，清理硅脂<br><img src="http://images.cnitblog.com/blog/286484/201306/30111940-11c5a435c58742218517d207ee505a1a.jpg" alt="clean1"><br><img src="http://images.cnitblog.com/blog/286484/201306/30111955-3f74f6b6bacb4eb189a25078f6bb5286.jpg" alt="clean2"><br><img src="http://images.cnitblog.com/blog/286484/201306/30112002-e0556227b1744ab49117779aa3887f5b.jpg" alt="clean3"></p>
<p>6，先加铜片，再抹上硅脂<br><img src="http://images.cnitblog.com/blog/286484/201306/30112011-b231e4f6dc014bf3a99340edecc53b29.jpg" alt="cu"><br><img src="http://images.cnitblog.com/blog/286484/201306/30112222-144c4f36d5f842a9a693a9009811b967.jpg" alt="cu1"></p>
<p>7，给CPU抹上硅脂<br><img src="http://images.cnitblog.com/blog/286484/201306/30112043-7f2c8ffb34b8494fbb522a094017f8c6.jpg" alt="cpu"></p>
<p>8，北桥垫上导热硅胶片，将风扇等装好<br><img src="http://images.cnitblog.com/blog/286484/201306/30112110-57f5ed81f5b74e3db7a8bc88e2af6193.jpg" alt="bq"></p>
<h2 id="完工">完工</h2>
<p>最终CPU和显卡的温度都得到了比较大的下降，CPU原本一直是60多度，现在已经稳定在50度左右，而显卡动不动可能80度的，现在已经基本在60度左右，但主板变化不是特别明显，原来在75度左右，现在也只是在65度～70度之间，可能是宏基电脑本身主板就很单薄吧，以至于真的比较难得到改善。</p>
<p>下一个电脑，还是准备MAC吧</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>武汉真是个很热的地方，我的笔记本于2011年3月份左右购买的，到现在已经两年多了，第一个暑假，我是在苏州的空调房使用，第二个暑假，我是在实验室的空调房使用，没有直接感受到夏天对笔记本的杀伤力，今年在寝室使用，在Linux发现无线网不稳定，然后我感觉到手底下的笔记本有些烫，我只是猜测跟发热有关。于是我切回到windows，开了鲁大师监控温度（话说我不知道在linux下如何进行温度监控），发现很快主板就到了报警温度（75度），我尝试打了一盘dota，发现显卡笔记本都超过了报警温度了，我觉得该给笔记本改善下散热了。  ]]></summary>
    
      <category term="4738ZG" scheme="http://liaoxl.github.io/tags/4738ZG/"/>
    
      <category term="瞎折腾" scheme="http://liaoxl.github.io/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TP-link WR703N, OpenWrt, Mentohust]]></title>
    <link href="http://liaoxl.github.io/blog/20130612/tp-wr703n/"/>
    <id>http://liaoxl.github.io/blog/20130612/tp-wr703n/</id>
    <published>2013-06-12T00:50:00.000Z</published>
    <updated>2014-03-16T05:58:48.000Z</updated>
    <content type="html"><![CDATA[<p>最近笔记本电脑的有线网卡坏了，具体怎么坏的，我也不清楚，很可能是老化了（但我的才两年，并且我很少听人说网卡这么快老化），也有可能下雨打雷天我没有拔网线。不过很久以前，我的笔记本网口灯无论有没有接网线，开机之后它都一直亮着，不知道什么原因，电脑型号是宏基4738ZG。<a id="more"></a></p>
<p>坏了一个有线网卡不打紧，但我们学校的联网需要用有线+锐捷认证，我有三种解决方案，第一种是我买个USB有线网卡，第二种是修主板上的有线网卡，第三种就是构建寝室的无线网。第一种加个有线网卡太麻烦了，而去USB网卡发热量都挺大，电脑总共三个USB口，或许可以加个USB拓展的，但那岂不是更麻烦；第二种太贵，据说都是200￥往上走的价格；第三种，其实我老早就想实现了，半年省下的网费基本就够我买一个无线路由器了。</p>
<h2 id="路由器选择">路由器选择</h2>
<p>我想找到OpenWrt官方支持的路由器，<a href="http://rockuw.com/" target="_blank">小吴</a>向我推荐了TP-link WR703N，我的确觉得它挺漂亮，不过看着它娇小的体型，还是有点担心它能力不足，而且有更便宜的路由器。犹豫了一会，最后还是买了，因为觉得它太漂亮了。</p>
<p><img src="/images/WR703N/wr703n.jpg" alt="wr703n"></p>
<h2 id="刷路由器_OpenWrt_&amp;&amp;_配置">刷路由器 OpenWrt &amp;&amp; 配置</h2>
<p>刷机对于WR703N来说是件非常容易的事，为了能够图文说明，参考了<a href="http://www.geek-workshop.com/thread-2418-1-1.html" target="_blank">这篇文章</a>。</p>
<ol>
<li><p>下载固件，<a href="rockuw.com">小吴</a>以自身经历跟我说明刷错固件的后果，我觉得比较有必要注意需下载的固件，在<a href="http://downloads.openwrt.org/" target="_blank">OpenWrt Downloads</a>的attitud adjustment文件夹目录下，据说这里是稳定版，snapshots里面的是最新的。</p>
</li>
<li><p>刷机。无论是用有线还是无线，连上路由器，用浏览器打开<a href="http://192.168.1.1/" target="_blank">192.168.1.1</a>，点击系统工具-&gt;软件升级，然后你在这个页面上上传固件就可以了，是一个.bin文件，点击升级，一会就好了。<strong>注意这里不能断电</strong></p>
</li>
<li><p>初始配置。在刷好机器机器后，这一步必须用网线连接，因为刚刷好的OpenWrt上面是自动关闭了无线（后面会有设置开启）。<br>首先用一根网线将703N的Lan口和你电脑相连，电脑上设置为DHCP模式。然后运行cmd.exe，输入telent 192.168.1.1（windows必须已开启telnet），或在linux命令行操作。<br>成功后出现OpenWrt的欢迎界面：</p>
</li>
</ol>
<p><img src="/images/WR703N/telnet.jpg" alt="telnet"></p>
<p>这一步需要更改root密码，输入passwd，然后按提示输入。更改root密码后就能用SSH服务了，输入exit退出telnet。</p>
<p><strong>网络配置</strong>。官方固件是不带LuCI的，即我们不能从浏览器操作，必须在命令行下完成。在windows下，下载ssh连接工具<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html" target="_blank">putty</a>。linux下的话，我是已经安装好了，其软件包为：<br>    $ which ssh<br>    /usr/bin/ssh<br>    $ rpm -qf /usr/bin/ssh<br>    openssh-clients-5.9p1-22.fc17.i686</p>
<p>比较建议这一部分呢操作在linux完成。打开终端，切换到root用户，然后</p>
<pre><code><span class="title">ssh</span> <span class="number">192.168.1.1</span>
</code></pre><p>显示如下：</p>
<pre><code><span class="comment"># ssh 192.168.1.1</span>
root@<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>'s password: 


BusyBox v1<span class="number">.19</span><span class="number">.4</span> (<span class="number">2013</span>-<span class="number">03</span>-<span class="number">14</span> <span class="number">11</span>:<span class="number">28</span>:<span class="number">31</span> UTC) built-<span class="keyword">in</span> shell (ash)
Enter 'help' <span class="keyword">for</span> a <span class="type">list</span> <span class="keyword">of</span> built-<span class="keyword">in</span> commands.

  _______                     ________        __
 |       |.<span class="comment">-----.-----.-----.|  |  |  |.----.|  |_</span>
 |   -   ||  _  |  -__|     ||  |  |  ||   _||   _|
 |_______||   __|_____|__|__||________||__|  |____|
          |__| W I R E L E S S   F R E E D O M
 <span class="comment">-----------------------------------------------------</span>
 ATTITUDE ADJUSTMENT (<span class="number">12.09</span>, r36088)
 <span class="comment">-----------------------------------------------------</span>
  * <span class="number">1</span>/<span class="number">4</span> oz Vodka      Pour all ingredients <span class="keyword">into</span> mixing
  * <span class="number">1</span>/<span class="number">4</span> oz Gin        tin <span class="keyword">with</span> ice, strain <span class="keyword">into</span> glass.
  * <span class="number">1</span>/<span class="number">4</span> oz Amaretto
  * <span class="number">1</span>/<span class="number">4</span> oz Triple sec
  * <span class="number">1</span>/<span class="number">4</span> oz Peach schnapps
  * <span class="number">1</span>/<span class="number">4</span> oz Sour mix
  * <span class="number">1</span> splash Cranberry juice
 <span class="comment">-----------------------------------------------------</span>
 root@OpenWrt:~<span class="comment"># </span>
</code></pre><p>上面输入的密码就是第三步里面设置的密码。</p>
<p>首先开启无线，输入</p>
<pre><code>～# vi /etc/config/wireless
config wifi-device  radio0                                               
    <span class="built_in">option</span> <span class="class"><span class="keyword">type</span>     <span class="title">mac80211</span>              </span>
    <span class="built_in">option</span> channel  <span class="number">11</span>                                                  
    <span class="built_in">option</span> macaddr  <span class="number">14</span>:cf:<span class="number">92</span>:<span class="number">9</span>d:a4:<span class="number">8</span>c                                   
    <span class="built_in">option</span> hwmode   <span class="number">11</span>ng                                                
    <span class="built_in">option</span> htmode   HT20                                                
    <span class="built_in">list</span> ht_capab   SHORT-GI-<span class="number">20</span>                                   
    <span class="built_in">list</span> ht_capab   SHORT-GI-<span class="number">40</span>                                         
    <span class="built_in">list</span> ht_capab   RX-STBC1                                            
    <span class="built_in">list</span> ht_capab   DSSS_CCK-<span class="number">40</span>                                         
    # REMOVE THIS LINE TO ENABLE WIFI:    
            这里加上注释，即开启无线网络
    # <span class="built_in">option</span> disabled <span class="number">1</span>                                                 
</code></pre><p>  配置无线设置                                                         </p>
<pre><code>config wifi-iface                                                         
    <span class="keyword">option</span> device   radio0                                             
    <span class="keyword">option</span> network  lan                                                
    <span class="keyword">option</span> mode     ap                                             
            网络名称
    <span class="keyword">option</span> ssid     moondark                                            
    <span class="keyword">option</span> encryption psk2
            连接时用的密码
    <span class="keyword">option</span> <span class="keyword">key</span>      xxxxxx   
</code></pre><p>然后修改network文件</p>
<pre><code>～<span class="comment"># vi /etc/config/network</span>
</code></pre><p><img src="/images/WR703N/network.png" alt="network"></p>
<p>然后输入<code>/etc/init.d/network restart</code></p>
<h2 id="运行mentohust及其配置">运行mentohust及其配置</h2>
<p>感谢学长HustMoon的mentohust，作为一名huster，在用这个软件的时候略微有点特别的感觉。</p>
<p>下载mentohust，这个与一般mentohust不同，它有已编译好的mips架构的<a href="https://code.google.com/p/mentohust-wrt/downloads/detail?name=mentohust.mips.7z" target="_blank">mentohust</a>，里面有两个包，任意一个拷贝过去即可，可直接用。<br>切到自己linux终端，拷贝命令：</p>
<pre><code>scp /path/to/mentohust root<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">1</span><span class="symbol">:/root</span>
为了能够运行，更改权限
root<span class="variable">@OpenWrt</span><span class="symbol">:~</span><span class="comment"># chmod +x /root/mentohust</span>
</code></pre><p>连接上网命令。</p>
<pre><code>mentohust <span class="attribute">-u</span>用户名 <span class="attribute">-p</span>密码 <span class="attribute">-neth0</span> <span class="attribute">-a1</span> <span class="attribute">-d0</span> <span class="attribute">-b1</span> <span class="attribute">-l0</span>
</code></pre><p>随路由器开机启动上网，<code>vi /etc/rc.local</code>在<code>exit 0</code>前面加入：</p>
<pre><code>mentohust <span class="attribute">-u</span>用户名 <span class="attribute">-p</span>密码 <span class="attribute">-neth0</span> <span class="attribute">-a1</span> <span class="attribute">-d0</span> <span class="attribute">-b1</span> <span class="attribute">-l0</span>
</code></pre><hr>
<h1 id="完结">完结</h1>
<p>电脑最终能够重新上网感觉很好，事实上，在本科的时候我就想用刷OpenWrt的路由器通过mentohust共享上网的，但本科由于种种原因，没有实践，现在成功了，而且为寝室作出贡献，有些成就感。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近笔记本电脑的有线网卡坏了，具体怎么坏的，我也不清楚，很可能是老化了（但我的才两年，并且我很少听人说网卡这么快老化），也有可能下雨打雷天我没有拔网线。不过很久以前，我的笔记本网口灯无论有没有接网线，开机之后它都一直亮着，不知道什么原因，电脑型号是宏基4738ZG。]]></summary>
    
      <category term="WR703N" scheme="http://liaoxl.github.io/tags/WR703N/"/>
    
      <category term="OpenWrt" scheme="http://liaoxl.github.io/tags/OpenWrt/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git及GitHub的基本应用]]></title>
    <link href="http://liaoxl.github.io/blog/20130517/git/"/>
    <id>http://liaoxl.github.io/blog/20130517/git/</id>
    <published>2013-05-17T13:55:00.000Z</published>
    <updated>2014-03-16T05:58:00.000Z</updated>
    <content type="html"><![CDATA[<p>使用Octopress + GitHub来搭建自己的博客，首先得对Octopress的博客环境进行配置，还要对Git版本管理及markdown语法有一定了解。对这两个都进行学习了一下，觉得markdown语法比较简单，多练习一段时间，就可以很自然的掌握了。而Git的版本管理及GitHub的远程仓库管理，让我觉得比较难以理解，所以进行了一些测试学习。学习Git可以去<a href="http://git-scm.com/book" target="_blank">Pro Git</a>的官方网站，或者这本书的<a href="https://github.com/progit/progit" target="_blank">GitHub</a>，也可以去新浪共享上面去<a href="http://ishare.iask.sina.com.cn/f/16096245.html" target="_blank">下载</a></p>
<hr>
<p>推荐安装tig，有有助于对git的理解，对于fedora 17，直接</p>
<pre><code><span class="variable">$ </span>yum intall tig
</code></pre><h2 id="<!-_more_->"><a id="more"></a></h2>
<h2 id="Git基础">Git基础</h2>
<p>Git的基本用法比较简单，我就从我的理解来记录一些，首先进行一些基本配置：</p>
<pre><code><span class="variable">$ </span>mkdir git-hub
<span class="variable">$ </span>cd git-hub/

<span class="variable">$ </span>tig
<span class="symbol">tig:</span> <span class="constant">Not</span> a git repository

<span class="variable">$ </span>git config --list 
user.name=<span class="constant">Xiangli</span> <span class="constant">Liao</span>
user.email=liaoxl2012<span class="variable">@gmail</span>.com
core.editor=vim
</code></pre><p>这里创建一个目录，作为即将使用git的目录，首先对其初始化：</p>
<pre><code><span class="variable">$ </span>git init 
<span class="constant">Initialized</span> empty <span class="constant">Git</span> repository <span class="keyword">in</span> /home/moondark/rubydev/git-hub/.git/
</code></pre><p>它就在当前目录下初始化了git，即最初通过<code>git init</code>初始化的是为空的。</p>
<pre><code>$ vim record.txt
$ git status
<span class="preprocessor"># On branch master</span>
<span class="preprocessor">#</span>
<span class="preprocessor"># Initial commit</span>
<span class="preprocessor">#</span>
<span class="preprocessor"># Untracked files:</span>
<span class="preprocessor">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span>
<span class="preprocessor">#</span>
<span class="preprocessor">#    record.txt</span>
nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)
</code></pre><p>通常用<code>git status</code>来查看当前目录文件的git状态，建议常用，一般情况下，都会有提示操作，如这里的最后一行，按照提示：</p>
<pre><code>$ git add .
$ git status
<span class="preprocessor"># On branch master</span>
<span class="preprocessor">#</span>
<span class="preprocessor"># Initial commit</span>
<span class="preprocessor">#</span>
<span class="preprocessor"># Changes to be committed:</span>
<span class="preprocessor">#   (use "git rm --cached &lt;file&gt;..." to unstage)</span>
<span class="preprocessor">#</span>
<span class="preprocessor">#    new file:   record.txt</span>
<span class="preprocessor">#</span>
</code></pre><p>这里的意思是，你添加的record.txt文件，处于暂存状态<code>stage</code>，如果不不想加入这个文件，你可以按照提示用<code>git rm --cached record.txt</code>来移除，如果你确定了，那你需要用<code>git commit -m&#39;Your Message&#39;</code>来提交你的更改，在这之前，你可以用tig命令查看当前状态：</p>
<pre><code>$ tig
tig: No revisions match <span class="keyword">the</span> <span class="keyword">given</span> arguments.
</code></pre><p>它显示当前为一个空的，此时你用<code>git commit -m&#39;Your Message&#39;</code>来提交，<code>Your Message</code>这里是一个快速提交更新的注释方法，表示你这次提交的描述，最好简明扼要，方便理解，如下：</p>
<pre><code>$ git <span class="operator"><span class="keyword">commit</span> -m <span class="string">'First Comment'</span>
[master (root-<span class="keyword">commit</span>) <span class="number">11</span>a8c45] <span class="keyword">First</span> Comment
<span class="number">1</span> file changed, <span class="number">28</span> insertions(+)
<span class="keyword">create</span> mode <span class="number">100644</span> record.txt


$ tig
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">19</span>:<span class="number">32</span> Xiangli Liao       I [master] <span class="keyword">First</span> Comment</span>
</code></pre><p>tig显示的，是当前分支的提交状态。继续修改record.txt，应用git命令：</p>
<pre><code>$ git status
# <span class="keyword">On</span> branch master
# Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
#   (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
#   (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)
#
#    modified:   <span class="keyword">record</span>.txt
#
no changes added <span class="keyword">to</span> commit (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)

$ git commit -m <span class="attribute">'Try</span> second commit'
# <span class="keyword">On</span> branch master
# Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
#   (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
#   (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)
#
#    modified:   <span class="keyword">record</span>.txt
#
no changes added <span class="keyword">to</span> commit (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)
</code></pre><p>此时要提交，根据提示，要么用<code>git add</code>或<code>git commit -a</code>均可，如果是对于已跟踪的但修改了的文件，用<code>git commit -a</code>是个比较快速的方法进行提交更新：</p>
<pre><code>$ git <span class="operator"><span class="keyword">commit</span> -a -m <span class="string">'Try second commit'</span>
[master bf899f5] Try <span class="keyword">second</span> <span class="keyword">commit</span>
 <span class="number">1</span> file changed, <span class="number">34</span> insertions(+)

$ tig
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">19</span>:<span class="number">37</span> Xiangli Liao       o [master] Try <span class="keyword">second</span> <span class="keyword">commit</span>
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">19</span>:<span class="number">32</span> Xiangli Liao       I <span class="keyword">First</span> Comment</span>
</code></pre><p>git本地的命令基本常用的就以上，还有一个常用的就是<code>git branch</code>，用于添加分支的，当然这个对于初学者来说一般不常用到。</p>
<hr>
<h2 id="Git_&amp;&amp;_GitHub">Git &amp;&amp; GitHub</h2>
<p>其实经常使用的，就是利用git与github一起管理自己的代码，其中有一些操作并不是很好理解，所以记录下来，做个笔记。</p>
<p>GitHub这种一般叫做远程仓库，即有一个“虚拟”的仓库，你跟若干个人都能同时用这个仓库进行存取东西。既然是若干个人用，当然就很容易出现一些问题，比如说不同步，或者有不同的分支，又或者有些分支需要合并。</p>
<p>首先，添加远程仓库，在github上创建一个Repo，比如创建一个Repo<a href="https://github.com/liaoxl/Git-Learning" target="_blank">Git-Learning</a>，你在本地添加远程仓库，采用<code>git remote</code>命令添加远程仓库。添加github上面的远程仓库有两种，一种是https，一种是SSH，前一种每一次push需要输入用户名/密码，后一种用SSH连接需要配置一下本地SSH，具体可以见<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank">GitHub SSH Keys</a>，这样每一次不需要每次输入用户名/密码，感觉更方便一些。</p>
<pre><code><span class="string">" https</span>
git remote add origin https:<span class="comment">//github.com/liaoxl/Git-Learning.git</span>
<span class="string">"SSH</span>
git remote add origin git@github.com:liaoxl/Git-Learning.git
</code></pre><p>然后可以用<code>git remote -v</code>来查看远程仓库。</p>
<pre><code>$ git remote -v
origin    git@github<span class="preprocessor">.com</span>:liaoxl/Git-Learning<span class="preprocessor">.git</span> (fetch)
origin    git@github<span class="preprocessor">.com</span>:liaoxl/Git-Learning<span class="preprocessor">.git</span> (<span class="keyword">push</span>)
</code></pre><p>推送的话，即将本地已经<code>commit</code>的文件推送到远程仓库，即：</p>
<pre><code><span class="variable">$ </span>git push origin 
</code></pre><p>在远程仓库上修改代码如何更新到本地呢？最简单的就是，我直接在github上面对自己文件内容进行修改，于是我本地文件中没有这些改变，这个时候就需要更新本地仓库：</p>
<pre><code>$ git pull origin master
<span class="subst">*</span> branch            master     <span class="subst">-&gt; </span>FETCH_HEAD
Already up<span class="attribute">-to</span><span class="attribute">-date</span><span class="built_in">.</span>
</code></pre><p>我操作发现，push可以默认推送到远程仓库的origin/master分支上，而更新本地文件必须指明分支，否则：</p>
<pre><code>$ git pull origin 
You asked <span class="built_in">to</span> pull <span class="built_in">from</span> <span class="operator">the</span> remote <span class="string">'origin'</span>, but did <span class="operator">not</span> specify
<span class="operator">a</span> branch. Because this is <span class="operator">not</span> <span class="operator">the</span> default configured remote
<span class="keyword">for</span> your current branch, you must specify <span class="operator">a</span> branch <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">command</span> <span class="title">line</span>.</span>
</code></pre><p>如果想推送到远程分支上，应该怎么办呢？可以首先查看有那些分支：</p>
<pre><code>$ git branch -a
* master
testing
<span class="comment">remotes/origin/master</span>
<span class="comment">remotes/origin/test</span>
</code></pre><p>推送的时候需要指明本地分支与远程分支：</p>
<pre><code>$ git push origin master:master
Everything up-<span class="built_in">to</span>-<span class="built_in">date</span>
</code></pre><p>如果不指定本地分支，<strong>并不是推送默认分支，而是删除远程分支</strong></p>
<pre><code><span class="variable">$ </span>git push origin <span class="symbol">:test</span>
<span class="constant">To</span> git<span class="variable">@github</span>.<span class="symbol">com:</span>liaoxl/<span class="constant">Git</span>-<span class="constant">Learning</span>.git
 - [deleted]         test
</code></pre><p>有了分支，就有合并的问题。如果我在远程仓库上进行了更新，本地文件我也进行了更新，在<code>git push</code>之前必须先用<code>git pull</code>来先更新本地仓库，否则：</p>
<pre><code>$ git push origin master 
Username <span class="keyword">for</span> <span class="string">'https://github.com'</span>: liaoxl
Password <span class="keyword">for</span> <span class="string">'https://liaoxl@github.com'</span>: 
To <span class="keyword">https</span>://github.com/liaoxl/Git-Learning.git
 ! [rejected]        master -&gt; master (non-fast-forward)
 error: failed <span class="built_in">to</span> push some refs <span class="built_in">to</span> <span class="string">'https://github.com/liaoxl/Git-Learning.git'</span>
 hint: Updates were rejected because <span class="operator">the</span> tip <span class="operator">of</span> your current branch is behind
 hint: its remote counterpart. Merge <span class="operator">the</span> remote changes (e.g. <span class="string">'git pull'</span>)
 hint: <span class="keyword">before</span> pushing again.
 hint: See <span class="operator">the</span> <span class="string">'Note about fast-forwards'</span> <span class="operator">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.
</code></pre><p>而用<code>git pull</code>更新本地仓库，又将涉及到合并(merge)的问题，git会自动尝试帮你合并(做一些最简单的合并），如果它自动合并失败，会提示有冲突，需要手动合并，如下是自动合并的：</p>
<pre><code>$ git pull https:<span class="comment">//github.com/liaoxl/Git-Learning.git " 这里也可用 git pull origin master</span>
remote: Counting objects: <span class="number">4</span>, <span class="keyword">done</span>.
remote: Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="keyword">done</span>.
remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)
Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="keyword">done</span>.
From https:<span class="comment">//github.com/liaoxl/Git-Learning</span>
 * branch            HEAD       -&gt; FETCH_HEAD
 Updating fd38d27.<span class="number">.6</span>a01674
 Fast-forward
 README.md | <span class="number">4</span> ++++
 <span class="number">1</span> file changed, <span class="number">4</span> insertions(+)
  create mode <span class="number">100644</span> README.md
</code></pre><p>以下是不能自动合并的：</p>
<pre><code>$ git <span class="operator"><span class="keyword">commit</span> -a -m <span class="string">'Changes on local'</span>
[master <span class="number">78</span>c9b6f] Changes <span class="keyword">on</span> <span class="keyword">local</span>
 <span class="number">1</span> file changed, <span class="number">3</span> insertions(+), <span class="number">1</span> deletion(-)

 $ git pull https://github.com/liaoxl/Git-Learning.git
 <span class="keyword">From</span> https://github.com/liaoxl/Git-Learning
  * branch            HEAD       -&gt; FETCH_HEAD
    Auto-merging morefile
    CONFLICT (content): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> morefile
    Automatic <span class="keyword">merge</span> failed;</span> fix conflicts and then <span class="operator"><span class="keyword">commit</span> the result.</span>
</code></pre><p>这个时候就需要自己手动合并，合并之后必须重新<code>commit</code>，才能用<code>git push</code>完成推送命令，即合并之后文件改变了，需要提交更新。</p>
<p>在经过若干次操作之后，用tig命令查看当前分支的状态，就显得比较直观了，非常推荐：</p>
<pre><code>$ tig
2013-05-18 10:46 Xiangli Liao       o [master] [origin/master] <span class="operator"><span class="keyword">update</span> record.tx~
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">17</span> <span class="number">00</span>:<span class="number">49</span> Xiangli Liao       M─┐ <span class="keyword">merge</span> master <span class="keyword">and</span> testing
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">17</span> <span class="number">00</span>:<span class="number">44</span> Xiangli Liao       │ o [testing] new file test.rb
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">17</span> <span class="number">00</span>:<span class="number">47</span> Xiangli Liao       o │ new file test.rb master
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">17</span> <span class="number">00</span>:<span class="number">10</span> Xiangli Liao       M─┐ <span class="keyword">after</span> <span class="keyword">Merge</span> conflict
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">17</span> <span class="number">00</span>:<span class="number">07</span> Xiangli Liao       │ o changes github
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">17</span> <span class="number">00</span>:<span class="number">08</span> Xiangli Liao       o │ changes <span class="keyword">local</span> morefile
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">23</span>:<span class="number">52</span> Xiangli Liao       M─┐ try manually merg <span class="keyword">local</span>
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">23</span>:<span class="number">48</span> Xiangli Liao       │ o change readme <span class="keyword">on</span> github
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">23</span>:<span class="number">49</span> Xiangli Liao       o │ changes <span class="keyword">on</span> <span class="keyword">local</span>
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">23</span>:<span class="number">41</span> Xiangli Liao       o─┘ <span class="keyword">Update</span> README.md
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">23</span>:<span class="number">31</span> Xiangli Liao       o source2 <span class="keyword">local</span>
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">23</span>:<span class="number">16</span> Xiangli Liao       o source1 <span class="keyword">local</span>
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">23</span>:<span class="number">13</span> Xiangli Liao       o New dir <span class="keyword">local</span>
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">22</span>:<span class="number">57</span> Xiangli Liao       o <span class="keyword">do</span> changes <span class="keyword">on</span> morefile
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">22</span>:<span class="number">50</span> Xiangli Liao       M─┐ <span class="keyword">some</span> changes <span class="keyword">on</span> morefile
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">22</span>:<span class="number">34</span> Xiangli Liao       │ o More changes
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">22</span>:<span class="number">36</span> Xiangli Liao       o │ Changes <span class="keyword">on</span> <span class="keyword">local</span>
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">22</span>:<span class="number">32</span> Xiangli Liao       o─┘ <span class="keyword">Update</span> morefile
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">21</span>:<span class="number">38</span> Xiangli Liao       o <span class="keyword">Create</span> README.md
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">20</span>:<span class="number">32</span> Xiangli Liao       o <span class="keyword">some</span> changes
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">19</span>:<span class="number">53</span> Xiangli Liao       o Test <span class="keyword">commit</span> -a <span class="keyword">for</span> new file
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">19</span>:<span class="number">37</span> Xiangli Liao       o Try <span class="keyword">second</span> <span class="keyword">commit</span>
<span class="number">2013</span>-<span class="number">05</span>-<span class="number">16</span> <span class="number">19</span>:<span class="number">32</span> Xiangli Liao       I <span class="keyword">First</span> Comment
[main] <span class="number">1</span>b98974d93252a884ef07e071072f5a6df063ad1 - <span class="keyword">commit</span> <span class="number">1</span> <span class="keyword">of</span> <span class="number">24</span> (<span class="number">100</span>%)</span>
</code></pre><hr>
<h2 id="Git_与_Octopress">Git 与 Octopress</h2>
<p>来看看Octopress用的git命令，我起初一直不理解为何要：</p>
<pre><code>$ git push origin <span class="built_in">source</span>
</code></pre><p>这说明在本地已经有了一个source分支</p>
<pre><code>$ git branch
master
* <span class="built_in">source</span>
</code></pre><p>这一步是在<code>rake setup_github_pages</code>产生的，看看其Rakefile<br>    desc “Set up _deploy folder and deploy branch for Github Pages deployment”<br>    task :setup_github_pages, :repo do |t, args|</p>
<p>其中这一步是控制git branch的</p>
<pre><code><span class="keyword">unless</span> (`git remote -v` =~ <span class="regexp">/origin.+?octopress(?:\.git)?/</span>).<span class="keyword">nil</span>?
    <span class="comment"># If octopress is still the origin remote (from cloning) rename it to octopress</span>
    system <span class="string">"git remote rename origin octopress"</span>
    <span class="keyword">if</span> branch == <span class="string">'master'</span>
        <span class="comment"># If this is a user/organization pages repository, add the correct origin remote</span>
        <span class="comment"># and checkout the source branch for committing changes to the blog source.</span>
        system <span class="string">"git remote add origin <span class="subst">#{repo_url}</span>"</span>
        puts <span class="string">"Added remote <span class="subst">#{repo_url}</span> as origin"</span>
        system <span class="string">"git config branch.master.remote origin"</span>
        puts <span class="string">"Set origin as default remote"</span>
        system <span class="string">"git branch -m master source"</span>
        puts <span class="string">"Master branch renamed to 'source' for committing your blog source files"</span>
    <span class="keyword">else</span>
        <span class="keyword">unless</span> !public_dir.match(<span class="string">"<span class="subst">#{project}</span>"</span>).<span class="keyword">nil</span>?
            system <span class="string">"rake set_root_dir[<span class="subst">#{project}</span>]"</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>可以查看自己Octopress目录中的所有分支：</p>
<pre><code>$ git branch -a
master
* source
<span class="comment">remotes/octopress/2.1</span>
<span class="comment">remotes/octopress/HEAD -&gt; octopress/master</span>
<span class="comment">remotes/octopress/colorize</span>
<span class="comment">remotes/octopress/gh-pages</span>
<span class="comment">remotes/octopress/guard</span>
<span class="comment">remotes/octopress/linklog</span>
<span class="comment">remotes/octopress/master</span>
<span class="comment">remotes/octopress/migrator</span>
<span class="comment">remotes/octopress/plugins</span>
<span class="comment">remotes/octopress/refactor_with_tests</span>
<span class="comment">remotes/octopress/rubygemcli</span>
<span class="comment">remotes/octopress/site</span>
<span class="comment">remotes/octopress/site-2.1</span>
<span class="comment">remotes/origin/source</span>
</code></pre>]]></content>
    <summary type="html"><![CDATA[<p>使用Octopress + GitHub来搭建自己的博客，首先得对Octopress的博客环境进行配置，还要对Git版本管理及markdown语法有一定了解。对这两个都进行学习了一下，觉得markdown语法比较简单，多练习一段时间，就可以很自然的掌握了。而Git的版本管理及GitHub的远程仓库管理，让我觉得比较难以理解，所以进行了一些测试学习。学习Git可以去<a href="http://git-scm.com/book" target="_blank">Pro Git</a>的官方网站，或者这本书的<a href="https://github.com/progit/progit" target="_blank">GitHub</a>，也可以去新浪共享上面去<a href="http://ishare.iask.sina.com.cn/f/16096245.html" target="_blank">下载</a></p>
<hr>
<p>推荐安装tig，有有助于对git的理解，对于fedora 17，直接</p>
<pre><code><span class="variable">$ </span>yum intall tig
</code></pre><h2 id="<!-_more_->">]]></summary>
    
      <category term="Linux" scheme="http://liaoxl.github.io/tags/Linux/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
