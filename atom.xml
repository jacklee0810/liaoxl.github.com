<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Moondark]]></title>
  <subtitle><![CDATA[你必须非常努力，才能看起来毫不费力]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liaoxl.github.io/"/>
  <updated>2014-11-15T07:17:02.115Z</updated>
  <id>http://liaoxl.github.io/</id>
  
  <author>
    <name><![CDATA[Xiangli Liao]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[图论的常用算法]]></title>
    <link href="http://liaoxl.github.io/blog/20140911/maxflow/"/>
    <id>http://liaoxl.github.io/blog/20140911/maxflow/</id>
    <published>2014-09-11T07:29:56.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>在科研中，其实主要用的是最大流开源库，没有自己写过。</p>
<p>为了在效率上优化，实际上<a href="#">maxflow/min-cut</a>这个库写的还挺复杂，我曾看过一些，但只能做到在有代码的情况下弄懂。</p>
<h2 id="最小生成树——Prim">最小生成树——Prim</h2>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Prim(<span class="keyword">int</span>** a, <span class="keyword">int</span> n, <span class="keyword">int</span>& maxRoad)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> mst=<span class="number">0</span>;</div><div class="line">    bool* visit=<span class="keyword">new</span> bool[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) visit[i]=<span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span>* curRow=<span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) curRow[i]=a[<span class="number">0</span>][i];</div><div class="line">    visit[<span class="number">0</span>]=<span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">int</span> <span class="keyword">next</span>=-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> nextlen=<span class="number">0</span>xfffff;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</div><div class="line">        {</div><div class="line">            <span class="keyword">if</span>(!visit[j] && curRow[j]&lt;nextlen)</div><div class="line">            {</div><div class="line">                <span class="keyword">next</span>=j;</div><div class="line">                nextlen=curRow[j];</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">next</span>==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        mst+=curRow[<span class="keyword">next</span>];</div><div class="line">        <span class="keyword">if</span>(curRow[<span class="keyword">next</span>]&gt;maxRoad) maxRoad=curRow[<span class="keyword">next</span>];</div><div class="line">        visit[<span class="keyword">next</span>]=<span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</div><div class="line">        {</div><div class="line">            <span class="keyword">if</span>(!visit[j] && a[<span class="keyword">next</span>][j]&lt;curRow[j]) curRow[j]=a[<span class="keyword">next</span>][j];</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">delete</span> [] visit;</div><div class="line">    <span class="keyword">delete</span> [] curRow;</div><div class="line">    <span class="keyword">return</span> mst;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="最短路径——Dijkstra">最短路径——Dijkstra</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> findMinNode(<span class="keyword">int</span>** a, <span class="keyword">int</span> s, <span class="keyword">int</span> n, <span class="keyword">bool</span>* visit)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> curmin=-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> curlen=maxdist;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(!visit[i] && a[s][i]&lt;curlen)</div><div class="line">        {</div><div class="line">            curmin=i;</div><div class="line">            curlen=a[s][i];</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> curmin;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Dijkstra(<span class="keyword">int</span>** a, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span>* dist=<span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">bool</span>* visit=<span class="keyword">new</span> <span class="keyword">bool</span>[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(i==s) dist[i]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> dist[i]=maxdist;</div><div class="line">        visit[i]=<span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">//visit[s]=true;</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">int</span> curmin=findMinNode(a,s,n,visit);</div><div class="line">        <span class="keyword">if</span>(curmin==-<span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line">        visit[curmin]=<span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</div><div class="line">        {</div><div class="line">            <span class="keyword">if</span>(!visit[j] && dist[j]&gt;dist[curmin]+a[curmin][j]) dist[j]=dist[curmin]+a[curmin][j];</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; dist[i];</div><div class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; dist[i];</div><div class="line">    }</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> [] dist;</div><div class="line">    <span class="keyword">delete</span> [] visit;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="最短路径——BellmanFord">最短路径——BellmanFord</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BellmanFord(<span class="keyword">int</span>** a, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span>* dist=<span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) dist[i]=maxdist;</div><div class="line">    dist[s]=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n-<span class="number">1</span>; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</div><div class="line">        {</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</div><div class="line">            {</div><div class="line">                <span class="keyword">if</span>(dist[k]&gt;dist[j]+a[j][k]) dist[k]=dist[j]+a[j][k];</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; dist[i];</div><div class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; dist[i];</div><div class="line">    }</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</div><div class="line">    <span class="keyword">delete</span> [] dist;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="最短路径——Floyd">最短路径——Floyd</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Floyd(<span class="keyword">int</span>** a, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span>* ptr=<span class="keyword">new</span> <span class="keyword">int</span>[n*n];</div><div class="line">    <span class="built_in">memset</span>(ptr,maxdist,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n*n);</div><div class="line">    <span class="keyword">int</span>** distmat=<span class="keyword">new</span> <span class="keyword">int</span>*[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        distmat[i]=ptr+i*n;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</div><div class="line">        {</div><div class="line">            distmat[i][j]=a[i][j];</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</div><div class="line">        {</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</div><div class="line">            {</div><div class="line">                <span class="keyword">if</span>(distmat[i][j]&gt;distmat[i][k]+distmat[k][j]) distmat[i][j]=distmat[i][k]+distmat[k][j];</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">int</span>* dist=distmat[s];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; dist[i];</div><div class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; dist[i];</div><div class="line">    }</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</div><div class="line">    <span class="keyword">delete</span> [] distmat;</div><div class="line">    <span class="keyword">delete</span> [] ptr;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="最大流——Dinic">最大流——Dinic</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">bool makeLevel(<span class="keyword">int</span><span class="variable">**</span> a, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span>* level, <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) level[i]=-<span class="number">1</span>;</div><div class="line">    level[s]=<span class="number">0</span>;</div><div class="line">    queue&lt;<span class="keyword">int</span>&gt; mq;</div><div class="line">    mq.push(s);</div><div class="line">    <span class="keyword">while</span>(!mq.empty())</div><div class="line">    {</div><div class="line">        <span class="keyword">int</span> len=mq.<span class="keyword">size</span>();</div><div class="line">        <span class="keyword">while</span>(len--)</div><div class="line">        {</div><div class="line">            <span class="keyword">int</span> curnode=mq.front();</div><div class="line">            mq.pop();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">            {</div><div class="line">                <span class="keyword">if</span>(level[i]==-<span class="number">1</span> && a[curnode][i]&gt;<span class="number">0</span>)</div><div class="line">                {</div><div class="line">                    level[i]=level[curnode]+<span class="number">1</span>;</div><div class="line">                    mq.push(i);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> level[t]!=-<span class="number">1</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> findFlow(<span class="keyword">int</span><span class="variable">**</span> a, <span class="keyword">int</span> x, <span class="keyword">int</span> t, <span class="keyword">int</span> n, <span class="keyword">int</span>* level, <span class="keyword">int</span> <span class="keyword">flow</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> <span class="keyword">flow</span>;</div><div class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(level[i]==level[x]+<span class="number">1</span> && a[x][i]&gt;<span class="number">0</span> && (ret=findFlow(a,i,t,n,level,<span class="keyword">min</span>(<span class="keyword">flow</span>,a[x][i]))))</div><div class="line">        {</div><div class="line">            a[i][x]+=ret;</div><div class="line">            a[x][i]-=ret;</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line">void Dinic(<span class="keyword">int</span><span class="variable">**</span> a, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span>* level=new <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">int</span> <span class="keyword">flow</span>=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> maxflow=<span class="number">0xfffff</span>;</div><div class="line">    <span class="keyword">while</span>(makeLevel(a,s,t,level,n))</div><div class="line">    {</div><div class="line">        <span class="keyword">flow</span>+=findFlow(a,s,t,n,level,maxflow);</div><div class="line">    }</div><div class="line">    cout &lt;&lt; <span class="keyword">flow</span> &lt;&lt; endl;</div><div class="line">    <span class="keyword">delete</span> [] level;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>在科研中，其实主要用的是最大流开源库，没有自己写过。</p>
<p>为了在效率上优化，实际上<a href="#">maxflow/min-cut</a>这个库写的还挺复杂，我曾看过一些，但只能做到在有代码的情况下弄懂。</p>
<h2 id="最小生成树——Prim">最小生成树——Prim</h2>
]]></summary>
    
      <category term="算法/数据结构" scheme="http://liaoxl.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用的排序算法]]></title>
    <link href="http://liaoxl.github.io/blog/20140907/sort/"/>
    <id>http://liaoxl.github.io/blog/20140907/sort/</id>
    <published>2014-09-07T08:27:37.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>排序是最基本的算法，面试中可能都不直接考，但经常涉及到排序算法的变种</p>
<p>我尝试了下自己手写，发现全部写对，困难不小。</p>
<p>头文件，习惯性将常用的头文件都加入进去</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;deque&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;time.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>;</div></pre></td></tr></table></figure>

<a id="more"></a>

<p>先产生一个100,000的数组，并写入文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">    freopen(<span class="string">"random.txt"</span>,<span class="string">"r"</span>,stdin);</div><div class="line">    <span class="keyword">double</span> time_start=(<span class="keyword">double</span>)clock();</div><div class="line">    srand((<span class="keyword">unsigned</span>)time( NULL ));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">int</span> tmp=rand();</div><div class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; tmp;</div><div class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; tmp;</div><div class="line">    }</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</div><div class="line">    <span class="keyword">double</span> time_end=(<span class="keyword">double</span>)clock();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"io time: %.2fms\n"</span>,(time_end-time_start));</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> [] a;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>后面读取的流程如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">    freopen(<span class="string">"random.txt"</span>,<span class="string">"r"</span>,stdin);</div><div class="line">    <span class="keyword">double</span> time_start=(<span class="keyword">double</span>)clock();</div><div class="line">    <span class="keyword">int</span>* a=<span class="keyword">new</span> <span class="keyword">int</span>[maxn];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</div><div class="line">    {</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&a[i]);</div><div class="line">    }</div><div class="line">    <span class="keyword">double</span> time_end=(<span class="keyword">double</span>)clock();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"io time: %.2fms\n"</span>,(time_end-time_start));</div><div class="line"></div><div class="line">    time_start=(<span class="keyword">double</span>)clock();</div><div class="line">    shellSort(a, maxn);</div><div class="line">    ofstream ofile;</div><div class="line">    ofile.open(<span class="string">"shellSort.txt"</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) ofile &lt;&lt; a[i];</div><div class="line">        <span class="keyword">else</span> ofile &lt;&lt; <span class="string">" "</span> &lt;&lt; a[i];</div><div class="line">    }</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</div><div class="line">    time_end=(<span class="keyword">double</span>)clock();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sort time: %.2fms\n"</span>,(time_end-time_start));</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> [] a;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="插入排序">插入排序</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> insertSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">int</span> tmp=a[i];</div><div class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>; tmp&lt;a[j] && j&gt;=<span class="number">0</span>; j--)</div><div class="line">        {</div><div class="line">            a[j+<span class="number">1</span>]=a[j];</div><div class="line">        }</div><div class="line">        a[j+<span class="number">1</span>]=tmp;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="冒泡排序">冒泡排序</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> bubbleSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</div><div class="line">    {</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;i; j++)</div><div class="line">        {</div><div class="line">            <span class="keyword">if</span>(a[j]&gt;=a[j+<span class="number">1</span>]) swap(a[j],a[j+<span class="number">1</span>]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="归并排序">归并排序</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">void mergeTwoArray(<span class="built_in">int</span> a[], <span class="built_in">int</span> lena, <span class="built_in">int</span> b[], <span class="built_in">int</span> lenb)</div><div class="line">{</div><div class="line">    <span class="built_in">int</span>* tmparray=<span class="keyword">new</span> <span class="built_in">int</span>[lena+lenb];</div><div class="line">    <span class="built_in">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i&lt;lena && j&lt;lenb)</div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(a[i]&lt;b[j])</div><div class="line">        {</div><div class="line">            tmparray[k]=a[i];</div><div class="line">            i++,k++;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span></div><div class="line">        {</div><div class="line">            tmparray[k]=b[j];</div><div class="line">            j++,k++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">while</span>(i&lt;lena)</div><div class="line">    {</div><div class="line">        tmparray[k]=a[i];</div><div class="line">        i++,k++;</div><div class="line">    }</div><div class="line">    <span class="keyword">while</span>(j&lt;lenb)</div><div class="line">    {</div><div class="line">        tmparray[k]=b[j];</div><div class="line">        j++,k++;</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;lena+lenb; i++)</div><div class="line">    {</div><div class="line">        a[i]=tmparray[i];</div><div class="line">    }</div><div class="line">    delete [] tmparray;</div><div class="line">}</div><div class="line">void mergeSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</div><div class="line">    {</div><div class="line">        <span class="built_in">int</span> <span class="built_in">mid</span>=n/<span class="number">2</span>;</div><div class="line">        <span class="built_in">int</span> lena=<span class="built_in">mid</span>;</div><div class="line">        <span class="built_in">int</span> lenb=n-<span class="built_in">mid</span>;</div><div class="line">        <span class="built_in">int</span>* b=a+<span class="built_in">mid</span>;</div><div class="line">        mergeSort(a,lena);</div><div class="line">        mergeSort(b,lenb);</div><div class="line">        mergeTwoArray(a,lena,b,lenb);</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="堆排序">堆排序</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> siftDown(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> lhs=<span class="number">2</span>*i+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> rhs=<span class="number">2</span>*i+<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> maxid=i;</div><div class="line">    <span class="keyword">if</span>(lhs&lt;n && a[i]&lt;a[lhs]) maxid=lhs;</div><div class="line">    <span class="keyword">if</span>(rhs&lt;n && a[maxid]&lt;a[rhs]) maxid=rhs;</div><div class="line">    <span class="keyword">if</span>(maxid!=i)</div><div class="line">    {</div><div class="line">        swap(a[i],a[maxid]);</div><div class="line">        siftDown(a,maxid,n);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> makeHeap(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>+<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</div><div class="line">    {</div><div class="line">        siftDown(a,i,n);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> heapSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    makeHeap(a,n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</div><div class="line">    {</div><div class="line">        swap(a[<span class="number">0</span>],a[i]);</div><div class="line">        siftDown(a,<span class="number">0</span>,i);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="快速排序">快速排序</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void quickSort(int <span class="literal">a</span>[], int n)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span><span class="comment">;</span></div><div class="line">    int mid=<span class="literal">a</span>[<span class="number">0</span>]<span class="comment">;</span></div><div class="line">    int i=<span class="number">0</span>,j=n-<span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="keyword">while</span>(i&lt;j)</div><div class="line">    {</div><div class="line">        <span class="keyword">while</span>(j&gt;i && <span class="literal">a</span>[j]&gt;=mid) j--<span class="comment">;</span></div><div class="line">        <span class="keyword">if</span>(j&gt;i)</div><div class="line">        {</div><div class="line">            <span class="literal">a</span>[i]=<span class="literal">a</span>[j]<span class="comment">;</span></div><div class="line">            i++<span class="comment">;</span></div><div class="line">        }</div><div class="line">        <span class="keyword">while</span>(i&lt;j && <span class="literal">a</span>[i]&lt;mid) i++<span class="comment">;</span></div><div class="line">        <span class="keyword">if</span>(i&lt;j)</div><div class="line">        {</div><div class="line">            <span class="literal">a</span>[j]=<span class="literal">a</span>[i]<span class="comment">;</span></div><div class="line">            j--<span class="comment">;</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="literal">a</span>[i]=mid<span class="comment">;</span></div><div class="line">    quickSort(<span class="literal">a</span>,i)<span class="comment">;</span></div><div class="line">    quickSort(<span class="literal">a</span>+i+<span class="number">1</span>,n-i-<span class="number">1</span>)<span class="comment">;</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="希尔排序">希尔排序</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> shellSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=n/<span class="number">2</span>; <span class="built_in">step</span>&gt;<span class="number">0</span>; <span class="built_in">step</span>/=<span class="number">2</span>)</div><div class="line">    {</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">step</span>; i&lt;n; i++)</div><div class="line">        {</div><div class="line">            <span class="keyword">int</span> val=a[i];</div><div class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>( j=i-<span class="built_in">step</span>; j&gt;=<span class="number">0</span> && a[j]&gt;val; j-=<span class="built_in">step</span>)</div><div class="line">            {</div><div class="line">                a[j+<span class="built_in">step</span>]=a[j];</div><div class="line">            }</div><div class="line">            a[j+<span class="built_in">step</span>]=val;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>排序是最基本的算法，面试中可能都不直接考，但经常涉及到排序算法的变种</p>
<p>我尝试了下自己手写，发现全部写对，困难不小。</p>
<p>头文件，习惯性将常用的头文件都加入进去</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;deque&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;time.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>;</div></pre></td></tr></table></figure>

]]></summary>
    
      <category term="算法/数据结构" scheme="http://liaoxl.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读《Effective C++》系列]]></title>
    <link href="http://liaoxl.github.io/blog/20140901/effcpp/"/>
    <id>http://liaoxl.github.io/blog/20140901/effcpp/</id>
    <published>2014-09-01T07:25:54.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="《Effective_C++》条款07：为多态基类声明virtual析构函数">《Effective C++》条款07：为多态基类声明virtual析构函数</h2>
<p>这样做主要是为了防止内存泄漏，见我hexo博客。</p>
<blockquote>
<p><a href="http://liaoxl.github.io/blog/20131205/virtual-destructor/" target="_blank" rel="external">C++的虚析构函数</a></p>
</blockquote>
<h2 id="《Effective_C++》条款11：在operator=中处理“自我赋值”">《Effective C++》条款11：在operator=中处理“自我赋值”</h2>
<p>“自我赋值”发生在对象赋值给自己时：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Widget { <span class="keyword">...</span> }</div><div class="line">Widget w;</div><div class="line"><span class="keyword">...</span></div><div class="line">w=w;</div></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator">a</span>[i]=<span class="operator">a</span>[j];<span class="comment"> //潜在的自我赋值，如果i和j有相同的值</span></div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*px=*<span class="keyword">py</span>;   //潜在的自我赋值，如果px和<span class="keyword">py</span>恰好指向同一个东西</div></pre></td></tr></table></figure>

<blockquote>
<p>如果遵循条款13和条款14的忠告，你会运用对象来管理资源，而且你可以确定所谓“资源管理对象”在copy发生时有正确的举措。这种情况下你的赋值操作符或许是“自我赋值安全的”（self-assignment-safe），不需要额外操心。然而如果你尝试自行管理资源（如果你打算写一个用于资源管理的class就得这样做），可能会掉进“在停止使用资源之前意外释放了它”的陷阱。</p>
</blockquote>
<p>其实从上面例子来看，似乎没有太大的问题，但假设你简历一个class来保存一个指针指向一块动态分配的位图（bitmap）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Bitmap { <span class="keyword">...</span> }</div><div class="line">class Widget {</div><div class="line">  <span class="keyword">...</span></div><div class="line">private:</div><div class="line">  Bitmap* pb;  // 指针，指向一个从heap分配而得到的对象</div><div class="line">};</div></pre></td></tr></table></figure>

<p>对于每次赋值，我们要考虑到资源管理，即可能会写出如下的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Widget&</div><div class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget& rhs) <span class="comment">//一份不安全的operator=实现版本</span></div><div class="line">{</div><div class="line">  <span class="keyword">delete</span> pb;</div><div class="line">  pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里自我赋值的问题是，operator=函数内的*this（赋值的目的端）和rhs有可能是同一个对象。果真如此，delete就不只是销毁当前对象的bitmap，它也销毁rhs的bitmap。</p>
<p>可以通过“证同测试”达到“自我赋值”的检验目的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Widget& Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget& rhs)</div><div class="line">{</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  <span class="keyword">delete</span> pb;</div><div class="line">  pb=<span class="keyword">new</span> Bitmap(*rhs.pb);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然而，这个版本不具备“异常安全性”，考虑在“new Bitmap”导致异常，它将得到一个指针指向一块被删除的Bitmap。</p>
<p>解决办法：</p>
<ul>
<li>在复制pb所指东西之前不删除pb：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Widget& Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget& rhs)</div><div class="line">{</div><div class="line">  Bitmap* pOrig=pb;</div><div class="line">  pb=<span class="keyword">new</span> Bitmap(*rhs.pb);</div><div class="line">  <span class="keyword">delete</span> pOrig;</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>使用copy and swap技术</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Widget {</div><div class="line"><span class="keyword">...</span></div><div class="line">void swap(Widget& rhs);</div><div class="line"><span class="keyword">...</span></div><div class="line">};</div><div class="line">Widget& Widget::operator=(const Widget& rhs)</div><div class="line">{</div><div class="line">  Widget temp(rhs);</div><div class="line">  swap(temp);</div><div class="line">  <span class="keyword">return</span> *this;</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>进阶版：利用传值方式，并考虑传值方式造成的副本</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Widget& Widget::<span class="keyword">operator</span>=(Widget rhs)</div><div class="line">{</div><div class="line">  swap(rhs);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="《Effective_C++》条款25：考虑写一个不抛出异常的swap函数">《Effective C++》条款25：考虑写一个不抛出异常的swap函数</h2>
<p>swap动作的典型实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">namespace std {</div><div class="line">  <span class="keyword">template</span>&lt;typename T&gt;</div><div class="line">  <span class="type">void</span> swap(T& a, T& b)</div><div class="line">  {</div><div class="line">      T temp(a);</div><div class="line">      a=b;</div><div class="line">      b=temp;</div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li><p>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</p>
</li>
<li><p>如果你提供一个member swap，也该提供一个non-member swap用来调用前者，对于classes（而非templates），也请特化 std::swap。</p>
</li>
<li><p>调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”</p>
</li>
<li><p>为“用户定义类型”进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西</p>
</li>
</ul>
<h2 id="《More_Effective_C++》条款01：指针与引用的区别">《More Effective C++》条款01：指针与引用的区别</h2>
<p>指针与引用看上去完全不同（指针用操作符’*’和’-&gt;’，引用使用操作符’.’），但是它们似乎有相同的功能。指针与引用都是让你间接引用其他对象。你如何决定在什么时候使用指针，在什么时候使用引用呢？</p>
<ul>
<li><p>任何情况下不能用指向空值的引用，而指针没这样的限制。</p>
<blockquote>
<p>不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。</p>
</blockquote>
</li>
<li><p>以下情况下你应该使用指针，一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。</p>
</li>
<li><p>如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。当你重载某个操作符时，你也应该使用引用。</p>
</li>
</ul>
<h2 id="《More_Effective_C++》条款06：自增（increment)、自减（decrement）操作符前缀形式与后缀形式的区别">《More Effective C++》条款06：自增（increment)、自减（decrement）操作符前缀形式与后缀形式的区别</h2>
<p>直接从代码层面说明区别，定义一个类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class UPInt { <span class="comment">// "unlimited precision int"</span></div><div class="line">　　<span class="keyword">public</span>:</div><div class="line">　　　UPInt& <span class="keyword">operator</span>++(); <span class="comment">// ++ 前缀</span></div><div class="line">　　　<span class="keyword">const</span> UPInt <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">// ++ 后缀</span></div><div class="line"></div><div class="line">　　　UPInt& <span class="keyword">operator</span>--(); <span class="comment">// -- 前缀</span></div><div class="line">　　　<span class="keyword">const</span> UPInt <span class="keyword">operator</span>--(<span class="keyword">int</span>); <span class="comment">// -- 后缀</span></div><div class="line"></div><div class="line">　　　UPInt& <span class="keyword">operator</span>+=(<span class="keyword">int</span>); <span class="comment">// += 操作符，UPInts</span></div><div class="line">　　　                     <span class="comment">// 与ints 相运算</span></div><div class="line">　　　...</div><div class="line">　　};</div></pre></td></tr></table></figure>

<p>前缀操作的自增是用类似以下的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前缀形式：增加然后取回值</span></div><div class="line">　　UPInt& UPInt::<span class="keyword">operator</span>++()</div><div class="line">　　{</div><div class="line">　　　*<span class="keyword">this</span> += <span class="number">1</span>; <span class="comment">// 增加</span></div><div class="line">　　　<span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 取回值</span></div><div class="line">　　}</div></pre></td></tr></table></figure>

<p>而后缀形式，则是如此：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</div><div class="line">　　{</div><div class="line">　　　UPInt oldValue = *<span class="keyword">this</span>; <span class="comment">// 取回值</span></div><div class="line">　　　++(*<span class="keyword">this</span>); <span class="comment">// 增加</span></div><div class="line">　　　<span class="keyword">return</span> oldValue; <span class="comment">// 返回被取回的值</span></div><div class="line">　　}</div></pre></td></tr></table></figure>

<p>后缀的会有个临时对象的产生，效率高低比较明了。</p>
<h2 id="《More_Effective_C++》条款08：理解各种不同含义的new与delete">《More Effective C++》条款08：理解各种不同含义的new与delete</h2>
<blockquote>
<p>一般情况下，<code>new operator=先operator new + 后 placement new</code>，前者用于分配存储空间，后者用于调用构造函数初始化所分配的内存。</p>
</blockquote>
<h2 id="《More_Effective_C++》条款19：理解临时对象的来源">《More Effective C++》条款19：理解临时对象的来源</h2>
<blockquote>
<p>在C++中真正的临时对象是看不见的，它们不出现在你的源代码中。建立一个没有命名的非堆（non-heap）对象会产生临时对象。这种未命名的对象通常在两种条件下产生：为了使函数成功调用而进行隐式类型转换和函数返回对象时。</p>
</blockquote>
<p>临时对象是有开销的，所以你应该尽可能地去除它们，然而更重要的是训练自己寻找可能建立临时对象的地方</p>
<p>主要有以下两个地方：</p>
<ul>
<li><p>任何时候只要见到常量引用（reference-to-const）参数，就存在建立临时对象而绑定在参数上的可能性</p>
</li>
<li><p>任何时候只要见到函数返回对象，就会有一个临时对象被建立（以后被释放）</p>
</li>
</ul>
<h2 id="《More_Effective_C++》条款26：限制某个类所能产生对象的数量">《More Effective C++》条款26：限制某个类所能产生对象的数量</h2>
<p>据我所知，C++控制类的一些trick主要包括<code>构造函数设置为private</code>+<code>设置static函数调用它们</code>或<code>设置友元函数/类</code>。</p>
<ul>
<li>允许建立零个或一个对象</li>
</ul>
<p>阻止建立某个类的对象，最容易的方法就是把该类的构造函数声明在类的private域</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class CantBeInstantiated {</div><div class="line">　　private:</div><div class="line">　　　CantBeInstantiated();</div><div class="line">　　　CantBeInstantiated(const CantBeInstantiated&);</div><div class="line">　　　<span class="keyword">...</span></div><div class="line">　　};</div></pre></td></tr></table></figure>

<ul>
<li>这样的限制太强了一些，用友元放松限制：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class PrintJob; // forward 声明</div><div class="line">　　              // 参见Effective C++条款<span class="number">34</span></div><div class="line"></div><div class="line">　　class Printer {</div><div class="line">　　public:</div><div class="line">　　　void submitJob(const PrintJob& job);</div><div class="line">　　　void reset();</div><div class="line">　　　void performSelfTest();</div><div class="line">　　　<span class="keyword">...</span></div><div class="line"></div><div class="line">　　friend Printer& thePrinter();</div><div class="line"></div><div class="line">　　private:</div><div class="line">　　　Printer();</div><div class="line">　　　Printer(const Printer& rhs);</div><div class="line">　　　<span class="keyword">...</span></div><div class="line">　　};</div><div class="line"></div><div class="line">　　Printer& thePrinter()</div><div class="line">　　{</div><div class="line">　　　static Printer p; // 单个打印机对象</div><div class="line">　　　<span class="keyword">return</span> p;</div><div class="line">　　}</div></pre></td></tr></table></figure>

<ul>
<li>用静态函数解除限制</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Printer {</div><div class="line">　　public:</div><div class="line">　　　static Printer& thePrinter();</div><div class="line">　　　<span class="keyword">...</span></div><div class="line"></div><div class="line">　　private:</div><div class="line">　　　Printer();</div><div class="line">　　　Printer(const Printer& rhs);</div><div class="line">　　　<span class="keyword">...</span></div><div class="line">　　};</div><div class="line"></div><div class="line">　　Printer& Printer::thePrinter()</div><div class="line">　　{</div><div class="line">　　　static Printer p;</div><div class="line">　　　<span class="keyword">return</span> p;</div><div class="line">　　}</div></pre></td></tr></table></figure>

<ul>
<li>通过静态变量来控制类的数量</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Printer {</div><div class="line">　　<span class="keyword">public</span>:</div><div class="line">　　　<span class="keyword">class</span> TooManyObjects{}; <span class="comment">// 当需要的对象过多时</span></div><div class="line">　　　                     <span class="comment">// 就使用这个异常类 </span></div><div class="line">　　　Printer();</div><div class="line">　　　~Printer();</div><div class="line">　　　...</div><div class="line"></div><div class="line">　　<span class="keyword">private</span>:</div><div class="line">　　　<span class="keyword">static</span> size_t numObjects;</div><div class="line">　　　Printer(<span class="keyword">const</span> Printer& rhs); <span class="comment">// 这里只能有一个printer，</span></div><div class="line">　　　                          <span class="comment">// 所以不允许拷贝</span></div><div class="line">　　};                             <span class="comment">// （参见Effective C++ 条款27）</span></div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">　<span class="comment">// Obligatory definition of the class static</span></div><div class="line">　　size_t Printer<span class="value">::numObjects = <span class="number">0</span>;</span></div><div class="line"></div><div class="line">　　Printer<span class="value">::<span class="function">Printer</span>()</span></div><div class="line">　　{</div><div class="line">　　　if (numObjects &gt;= <span class="number">1</span>) {</div><div class="line">　　　　throw <span class="function">TooManyObjects</span>();</div><div class="line">　　　}</div><div class="line"></div><div class="line">　　　继续运行正常的构造函数;</div><div class="line"></div><div class="line">　　　++numObjects;</div><div class="line">　　}</div><div class="line"></div><div class="line">　　Printer<span class="value">::~<span class="function">Printer</span>()</span></div><div class="line">　　{</div><div class="line">　　　进行正常的析构函数处理;</div><div class="line"></div><div class="line">　　　--numObjects;</div><div class="line">　　}</div></pre></td></tr></table></figure>

<h2 id="《More_Effective_C++》条款27：要求或禁止在堆中产生对象">《More Effective C++》条款27：要求或禁止在堆中产生对象</h2>
<blockquote>
<p>系统自动分配的内存是栈内存，是由系统自动分配、释放。程序员通过new或malloc操作开辟的内存，是堆内存，由程序员通过代码进行分配、释放</p>
</blockquote>
<p>有以上的条件，我们知道，禁止在堆中产生对象，即限制new的功能；要求只在堆中产生对象，即限制系统对象的实例化</p>
<ul>
<li>要求只在堆中产生对象</li>
</ul>
<p>让我们先从必须在堆中建立对象开始说起。为了执行这种限制，你必须找到一种方法禁止以调用“new”以外的其它手段建立对象。这很容易做到。非堆对象（non-heap object）在定义它的地方被自动构造，在生存时间结束时自动被释放，所以只要禁止使用隐式的构造函数和析构函数，就可以实现这种限制。</p>
<p>把这些调用变得不合法的一种最直接的方法是把构造函数和析构函数声明为private。这样做副作用太大。没有理由让这两个函数都是private。最好让析构函数成为private，让构造函数成为public。处理过程与条款26相似，你可以引进一个专用的伪析构函数，用来访问真正的析构函数。客户端调用伪析构函数释放他们建立的对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class UPNumber {</div><div class="line">　　<span class="keyword">public</span>:</div><div class="line">　　　<span class="title">UPNumber</span>();</div><div class="line">　　　UPNumber(<span class="keyword">int</span> initValue);</div><div class="line">　　　UPNumber(<span class="keyword">double</span> initValue);</div><div class="line">　　　UPNumber(<span class="keyword">const</span> UPNumber& rhs);</div><div class="line"></div><div class="line">　　　<span class="comment">// 伪析构函数 (一个const 成员函数， 因为</span></div><div class="line">　　　<span class="comment">// 即使是const对象也能被释放。)</span></div><div class="line">　　　<span class="keyword">void</span> destroy() <span class="keyword">const</span> { delete <span class="keyword">this</span>; }</div><div class="line">　　　...</div><div class="line"></div><div class="line">　　<span class="keyword">private</span>:</div><div class="line">　　　~<span class="title">UPNumber</span>();</div><div class="line">　　};</div></pre></td></tr></table></figure>

<ul>
<li>禁止在堆中产生对象</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> UPNumber {</div><div class="line">　　<span class="keyword">private</span>:</div><div class="line">　　　<span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>(size_t size);</div><div class="line">　　　<span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *ptr);</div><div class="line">　　　...</div><div class="line">　　};</div></pre></td></tr></table></figure>

<h2 id="《More_Effective_C++》条款28：灵巧（smart）指针">《More Effective C++》条款28：灵巧（smart）指针</h2>
<blockquote>
<p>灵巧指针是一种外观和行为都被设计成与内建指针相类似的对象，不过它能提供更多的功能。它们有许多应用的领域，包括资源管理（参见条款9、10、25和31）和重复代码任务的自动化（参见条款17和29）</p>
</blockquote>
<p>当你使用灵巧指针替代C++的内建指针（也就是dumb pointer）,你就能控制下面这些方面的指针的行为：</p>
<p>　　构造和析构。你可以决定建立灵巧指针时应该怎么做。通常赋给灵巧指针缺省值0，避免出现令人头疼的未初始化的指针。当指向某一对象的最后一个灵巧指针被释放时，一些灵巧指针负责删除它们指向的对象。这样做对防止资源泄漏很有帮助。</p>
<p>　　拷贝和赋值。你能对拷贝灵巧指针或设计灵巧指针的赋值操作进行控制。对于一些类型的灵巧指针来说，期望的行为是自动拷贝它们所指向的对象或用对这些对象进行赋值操作，也就是进行deep copy(深层拷贝)。对于其它的一些灵巧指针来说，仅仅拷贝指针本身或对指针进行赋值操作。还有一部分类型的灵巧指针根本就不允许这些操作。无论你认为应该如何去做，灵巧指针始终受你的控制。</p>
<p>大多数灵巧指针模板看起来都象这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt; <span class="comment">//灵巧指针对象模板</span></div><div class="line">　　class SmartPtr { </div><div class="line">　　<span class="keyword">public</span>:</div><div class="line">　　　<span class="title">SmartPtr</span>(T* realPtr = <span class="number">0</span>); <span class="comment">// 建立一个灵巧指针</span></div><div class="line">　　　                       <span class="comment">// 指向dumb pointer所指的</span></div><div class="line">                       　　　<span class="comment">// 对象。未初始化的指针</span></div><div class="line">                      　 　　<span class="comment">// 缺省值为0(null)</span></div><div class="line"></div><div class="line">　　　SmartPtr(<span class="keyword">const</span> SmartPtr& rhs); <span class="comment">// 拷贝一个灵巧指针</span></div><div class="line"></div><div class="line">　　　~SmartPtr(); <span class="comment">// 释放灵巧指针</span></div><div class="line"></div><div class="line">　　　<span class="comment">// make an assignment to a smart ptr</span></div><div class="line">　　　SmartPtr& <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr& rhs);</div><div class="line"></div><div class="line">　　　T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>; <span class="comment">// dereference一个灵巧指针</span></div><div class="line">　　　                    <span class="comment">// 以访问所指对象的成员</span></div><div class="line"></div><div class="line">　　　T& <span class="keyword">operator</span>*() <span class="keyword">const</span>; <span class="comment">// dereference 灵巧指针</span></div><div class="line"></div><div class="line">　　<span class="keyword">private</span>:</div><div class="line">　　　T *pointee; <span class="comment">// 灵巧指针所指的对象</span></div><div class="line">　　};</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h2 id="《Effective_C++》条款07：为多态基类声明virtual析构函数">《Effective C++》条款07：为多态基类声明virtual析构函数</h2>
<p>这样做主要是为了防止内存泄漏，见我hexo博客。</p>
<blockquote>
<p><a href="http://liaoxl.github.io/blog/20131205/virtual-destructor/" target="_blank" rel="external">C++的虚析构函数</a></p>
</blockquote>
<h2 id="《Effective_C++》条款11：在operator=中处理“自我赋值”">《Effective C++》条款11：在operator=中处理“自我赋值”</h2>
<p>“自我赋值”发生在对象赋值给自己时：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Widget { <span class="keyword">...</span> }</div><div class="line">Widget w;</div><div class="line"><span class="keyword">...</span></div><div class="line">w=w;</div></pre></td></tr></table></figure>

]]></summary>
    
      <category term="C++" scheme="http://liaoxl.github.io/tags/C/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++的黑科技]]></title>
    <link href="http://liaoxl.github.io/blog/20140822/cppbt/"/>
    <id>http://liaoxl.github.io/blog/20140822/cppbt/</id>
    <published>2014-08-22T02:23:56.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>周二面了腾讯，之前只投了TST内推，貌似就是TST面试了</p>
<p>其中有一个问题，<strong>“如何产生一个不能被继承的类”</strong>，这道题我反反复复只想到，将父类的构造函数私有，让子类不能调用，最后归结出一个单例模式，但面试官说，单例模式作为此题的解答不够灵活，后来面试官提示说，可以用友元+虚继承，可以完美实现这样一个类</p>
<p>当然那时我还不太明白，友元与虚继承我都极少接触过，只是知道有这些东西，回头搜了一下<strong>“不能被继承的类”</strong>的做法，具体如下：</p>
<a id="more"></a>


<blockquote>
<p>1，声明一个类，CNoHeritance，构造函数为private，并声明友元类CParent；<br>2，让CParent虚继承CNoHeritance<br>这样CParent就成为一个可以被正常实例化，但又不能被继承的类</p>
</blockquote>
<p>吴总当时评价说，<strong>“呵呵，虚继承，感觉完全是黑科技啊”</strong></p>
<p>这个<strong>黑科技</strong>真是戳中我笑点，但想到C++经常有些奇妙的东西，现在想总结一下</p>
<h2 id="1，C++构造函数的黑科技">1，C++构造函数的黑科技</h2>
<p>对于阅读过进阶C++书籍的都该知道，编译器会在<strong>“需要”</strong>的时候，那么什么是需要的时候呢？四种情况：</p>
<ul>
<li>1，“带有Default Constructor”的Member Class Object</li>
<li>2，“带有Default Constructor”的Base Class</li>
<li>3，“带有至少一个Virtual Function”的Class</li>
<li>4，“带有一个Virtual Base Class”的Class</li>
</ul>
<p>自动合成的构造函数往往都是public，在派生类中，它的构造函数是可以被使用的，即派生类不会因此受到限制。</p>
<p>那么，<strong>如何能使派生类不能使用基类的函数或成员呢？</strong></p>
<ul>
<li>private：只能由：1，该类中的函数；2，其友元函数访问</li>
<li>protected：可以被：1，该类中的函数；2，其友元函数；3，派生类（子类）的函数访问</li>
<li>public：可以被：1，该类中的函数；2，其友元函数；3，子类的函数；4，该类的对象访问</li>
</ul>
<p>如果一个类的构造函数声明为private，则其派生类甚至该类的对象都不能访问，意味着两点：</p>
<ul>
<li>1，该类不能被继承</li>
<li>2，该类不能由系统实例化，即它实例化的对象不会在栈内存上</li>
</ul>
<p>那么怎么使用该类呢？一般而言，会通过该类的函数来创建</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="title">A</span>(){}</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A& <span class="title">createA</span>()</div><div class="line">    {</div><div class="line">        A* p=<span class="keyword">new</span> A();</div><div class="line">        <span class="keyword">return</span> *p;</div><div class="line">    }</div><div class="line">};</div></pre></td></tr></table></figure>

<p>然而，这样又引申一个问题：类没有实例化，如何能使用其成员函数呢？</p>
<p>答案是将该成员函数声明为static，这样不需要实例化即可访问，即将上述改为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="title">A</span>(){}</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> A& <span class="title">createA</span>()</div><div class="line">    {</div><div class="line">        A* p=<span class="keyword">new</span> A();</div><div class="line">        <span class="keyword">return</span> *p;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">A Object=A::createA();</div></pre></td></tr></table></figure>

<p>很明显，上面的实例化过程很不方便，简直是艰辛呀，单例模式的其中一种实现就是如此，在此先不讲。这样实现的类，不能被继承，但自己也不好过</p>
<p>so，如果用友元来实现，是怎么实现的呢？</p>
<p>声明一个类，及其友元</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    A(){}</div><div class="line"></div><div class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>那么B是可以调用A的private的构造函数的，那么让B虚继承A会发生什么事呢？</p>
<p>由《深度探索C++对象模型》看到，B内存中将有一份A类的实体，调用A的构造函数构造的，这对于友元类B是可行的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    A(){}</div><div class="line"></div><div class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">virtual</span> <span class="title">A</span></span></div><div class="line">{</div><div class="line">};</div></pre></td></tr></table></figure>

<p>那么这样的B能不能被继承呢？假设有个类继承了B，如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    A(){}</div><div class="line"></div><div class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">virtual</span> <span class="title">A</span></span></div><div class="line">{</div><div class="line">};</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="title">B</span></span></div><div class="line">{</div><div class="line">};</div></pre></td></tr></table></figure>

<p>考虑到虚继承的特性，C也将调用A的构造函数构造出一个A，但！！C并不是A的友元类，所以根本不能执行A私有的构造函数，这段程序，如果不实例化C，编译器不会报错，但一旦实例化C，则将报错。</p>
<p>而B是可以正常实例化的一个类，这样就完美实现了一个<strong>不能被继承的类</strong>：B</p>
<h2 id="2，C++构造函数初始化列表的黑科技">2，C++构造函数初始化列表的黑科技</h2>
<p>相比于构造函数的各种trick，C++的初始化列表就显得很容易了，只有那么一点要注意：</p>
<blockquote>
<p>C++的初始化列表的赋值顺序，是与C++类里面成员变量的声明顺序相关，与初始化列表里的顺序无关</p>
</blockquote>
<p>举个例子，以下就会出现莫名错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="title">A</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y):<span class="title">y</span>(_y), <span class="title">x</span>(y){}</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>根据声明顺序，在初始化列表中，是先完成<code>x(y)</code>这个步骤，但此时<code>y</code>并没有被赋值，所以得到的x是个随机的值。</p>
<h2 id="3，C++虚函数的黑科技">3，C++虚函数的黑科技</h2>
<p>C++虚函数的问题，几乎是面试必问，实际上需要了解的东西也挺多，我自己在前几次面试，都有些理解有误的地方，或者理解不够完善</p>
<p>这里总结几点吧（以下类都是针对有虚函数的类）：</p>
<ul>
<li>1，每个类都有虚函数表，这个虚函数表是在编译阶段构建，在代码段产生一个vtbl</li>
<li>2，每次实例化的时候，构造函数在前几个字节，产生一个指向虚函数表的指针，指向代码段的那个虚函数表</li>
<li>3，虚函数的实现与调整，是通过移动或变换虚函数表的指针来实现的。</li>
<li>4，纯虚函数是指只声明，但未被实现的虚函数，具有纯虚函数的类不能被实例化，为抽象类</li>
</ul>
<h2 id="4，C++拷贝构造函数的黑科技">4，C++拷贝构造函数的黑科技</h2>
<p>C++的拷贝构造函数是C++默认的四个函数之一：<strong>构造函数、析构函数、赋值函数、拷贝构造函数</strong></p>
<p>拷贝构造函数是一种特别的构造函数，在《深度探索C++对象模型》书中说，有三种情况，会导致拷贝构造函数被触发：</p>
<ul>
<li>1，以一个object的内容作为另一个class object的初始值</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class X <span class="decorator">{...}</span></div><div class="line">X x;</div><div class="line">X xx=x;</div></pre></td></tr></table></figure>

<ul>
<li>2，当object被当作参数传递给某个函数时</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void <span class="function">foo</span>(X x);</div><div class="line">X xx;</div><div class="line"><span class="function">foo</span>(xx);</div></pre></td></tr></table></figure>

<ul>
<li>3，函数传回一个class object的时候</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">X foo_bar()</div><div class="line">{</div><div class="line">  X xx;</div><div class="line">  // <span class="keyword">...</span></div><div class="line">  <span class="keyword">return</span> xx;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一般情况下，如果没有提供<strong>explicit copy constructor</strong>时，会发生什么呢？</p>
<blockquote>
<p>一个良好的编译器可以为大部分class objects产生bitwise copies，因为它们有bitwise semantics…</p>
</blockquote>
<p>这里说的很神奇，好像我们不需要自己写copy constructor也没问题一样，实际上，<strong>bitwise copies</strong>在有些情况下是非常不推崇的</p>
<p>首先解释下什么是<strong>bitwise copies</strong>：这是指，在拷贝过来的时候，把class的内存直接位拷贝过来，即可以看成是内存拷贝（对应的有值拷贝）</p>
<p>位拷贝有很多问题，典型的一个，如果class里面含有分配内存的指针，那么它会将指针指向的地址直接拷贝过来：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> *p;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">    A a1;</div><div class="line">    a1.p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">    A a2=a1;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a1.p &lt;&lt; endl;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a2.p &lt;&lt; endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里可以发现，<code>a1.p</code>的地址与<code>a2.p</code>的地址是一样的，那么，我分配的内存，该由哪个释放呢？我释放了，另一个怎么办呢？</p>
<p>实际上，这种拷贝方式在STL的<code>string</code>里面肯定是要重写的，不能用位拷贝。</p>
<p>《深度探索C++对象模型》中，说class不展现出“bitwise copy semantics”有四种情况：</p>
<ul>
<li>1，当class含有member object并且后者有一个copy constructor（声明或合成）</li>
<li>2，当class继承一个base class 而后者存在一个copy constructor的时候</li>
<li>3，当class声明了一个或多个virtual functions时</li>
<li>4，当class派生自一个继承串链，其中有一个或多个virtual base classes时</li>
</ul>
<p><strong>其实主要都是担心，指针在bitwise semantics下，随便复制可能会导致不可预料的错误</strong></p>
<p>在这里说一下<strong>赋值函数</strong>与<strong>拷贝构造函数</strong>在触发上的区别：</p>
<blockquote>
<p>当一个object从无到有时，触发的一定是拷贝构造函数，赋值函数只会在已有的object赋值时，才会触发</p>
</blockquote>
<h2 id="5，C++虚继承的黑科技">5，C++虚继承的黑科技</h2>
<p>针对虚继承，可以坦承的一点就是</p>
<blockquote>
<p>所有简单的东西，遇到虚继承，似乎都要单独拿出来讨论</p>
</blockquote>
<p><em>待续</em></p>
]]></content>
    <summary type="html"><![CDATA[<p>周二面了腾讯，之前只投了TST内推，貌似就是TST面试了</p>
<p>其中有一个问题，<strong>“如何产生一个不能被继承的类”</strong>，这道题我反反复复只想到，将父类的构造函数私有，让子类不能调用，最后归结出一个单例模式，但面试官说，单例模式作为此题的解答不够灵活，后来面试官提示说，可以用友元+虚继承，可以完美实现这样一个类</p>
<p>当然那时我还不太明白，友元与虚继承我都极少接触过，只是知道有这些东西，回头搜了一下<strong>“不能被继承的类”</strong>的做法，具体如下：</p>
]]></summary>
    
      <category term="C++" scheme="http://liaoxl.github.io/tags/C/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[转载 linux下打开windows txt文件中文乱码问题]]></title>
    <link href="http://liaoxl.github.io/blog/20140728/utf8/"/>
    <id>http://liaoxl.github.io/blog/20140728/utf8/</id>
    <published>2014-07-28T07:21:38.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/imyang2007/article/details/7448177" target="_blank" rel="external">原文链接</a></p>
<p>在linux操作系统下，我们有时打开在windows下的txt文件，发现在windows下能正常显示的txt文件出现了中文乱码。</p>
<p>出现这种情况的原因为两种操作系统的中文压缩方式不同，在windows环境中中文压缩一般为gbk，而在linux环境中为utf8，这就导致了在windows下能正常显示<br>txt文件在linux环境下打开呈现了乱码状态。</p>
<p>解决方法：在linux用iconv命令，如乱码文件名为shujujiegou.txt，那么在终端输入如下命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iconv -f gbk -t utf8 shujujiegou.txt &gt; shujujiegou.txt.utf8</div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="linux" scheme="http://liaoxl.github.io/tags/linux/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[访问Google及Gmail的host IP]]></title>
    <link href="http://liaoxl.github.io/blog/20140716/google/"/>
    <id>http://liaoxl.github.io/blog/20140716/google/</id>
    <published>2014-07-16T07:18:31.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>目前测试能用的host IP</p>
<p>截止2014-07-16</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">173.194</span><span class="number">.64</span><span class="number">.84</span> accounts.google.com</div><div class="line"><span class="number">173.194</span><span class="number">.64</span><span class="number">.84</span> www.google.com</div><div class="line"><span class="number">173.194</span><span class="number">.64</span><span class="number">.84</span> mail.google.com</div><div class="line"><span class="number">173.194</span><span class="number">.64</span><span class="number">.84</span> www.google.com.hk</div><div class="line"><span class="number">173.194</span><span class="number">.64</span><span class="number">.84</span> www.l.google.com</div><div class="line"><span class="number">173.194</span><span class="number">.64</span><span class="number">.84</span> accounts.google.com.hk</div><div class="line"><span class="number">74.125</span><span class="number">.224</span><span class="number">.197</span> adwords.google.com</div><div class="line"><span class="number">209.116</span><span class="number">.186</span><span class="number">.221</span> plus.google.com</div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="Google" scheme="http://liaoxl.github.io/tags/Google/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的研二]]></title>
    <link href="http://liaoxl.github.io/blog/20140626/yaner/"/>
    <id>http://liaoxl.github.io/blog/20140626/yaner/</id>
    <published>2014-06-26T07:16:09.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>再过几天，就是学校校历上的学期末了，研究生阶段，一晃过了两年</p>
<p>去年暑假放假后，在天梯奋战了半个多月，一直在1200~1300左右的水平不再上去，回校后开始了我的研二</p>
<p>按从远至近的回忆，研二就是这样度过的：</p>
<h2 id="2013年9月">2013年9月</h2>
<p>我暑假在ICCV2011的文章“Distributed Cosegmentation via Submodular Optimization on Anisotropic Diffusion”基础上，做了一些改进，并进行了实验，得到较为良好的结果，于是那个9月，我在寻找合适的数据集，补充实验，并撰写论文。</p>
<a id="more"></a>

<h2 id="2013年10月">2013年10月</h2>
<p>我笔试了一次百度，未通过让我很不开心，怒刷leetcode，同时兼并着做实验，到了月底几近把leetcode刷完，很多时候想想，笔试面试与刷题很有关系，那一段时间状态好几乎可以秒杀很多题，但这样的笔试面试真的合理吗？</p>
<h2 id="2013年11月">2013年11月</h2>
<p>论文初稿成型，开始投递论文，并按照很多要求修改</p>
<h2 id="2013年12月">2013年12月</h2>
<p>论文投递出去，想投一个快速想中的，结果被不符合杂志内容被拒了，后来将内容加长，准备再投；月底老板跟我说，有篇文章投递了Signal Processing，要求修改，需要补充很多实验，之前实现这个算法的人只做了一部分，无法按照要求进行修改，而且人也已经毕业了，无法再做，“你如果实现这个程序，并且完成补充实验，给你一作”，其实我没得选，程序的工作量很大，修改时间很快就要截止了，于是这个事情贯穿了我寒假之前的所有时间。</p>
<h2 id="2014年1月">2014年1月</h2>
<p>我自己的论文投递到 IEEE Trans. Multimedia 杂志，我主要在实现Signal Processing文章，费了好久了解思路，所有重头开始，无任何已有代码，然后我实现完了这篇文章算法，并写好批处理程序不分昼夜的进行跑实验数据，放假前终于搞定，投递出去。</p>
<h2 id="2014年2月">2014年2月</h2>
<p>放假在家，与老友聚一聚，在家总容易忘记很多学习相关的事，大脑像是装了双系统，在家用的是一个娱乐系统；初十左右回到学校，发现老板已经在等我，一个是项目问题需要咨询我，另外我投的IEEE Trans. Multimedia被拒，要我按要求修改。月底，<a href="#">吴总</a>跟我说，阿里内推快开始了。</p>
<h2 id="2014年3月">2014年3月</h2>
<p>我首先先做了一份自己的简历，从此在博客上更新了自己状态，并让吴总内推到阿里巴巴，内推不能选部门让我隐隐感到不安，接下来的时间在按要求修改文章，然后调试项目相关问题，3月2日在阿里上面注册简历，并将简历投递过去，3月18日收到投Signal Processing的文章要继续小修的reply，所以继续按要求修改；3月26日 阿里突然一个电话过来，说面试我，聊了十几分钟，回来发现是 应聘通过，后来就没投腾讯，后来状态继续变成 终面通过，再变成 面试已完成。3月底，将Signal Processing的文章按要求修改后，返回过去。</p>
<h2 id="2014年4月">2014年4月</h2>
<p>4月上旬及中旬，准备一些面试知识，期间再投了那个拒我的IEEE Trans. Multimedia，耐不住寂寞投了百度的深度学习研究院，后来百度HR跟我check时间，说至少三个月，我跟她说byebye，4月下旬，编程之美初赛，少有的能在一次比赛中A掉两题，可惜未进复赛。4月24日，阿里现场面试，内推直接终面，hr+技术官2对1，对我大脑狂轰乱炸，不习惯这种面试方式，不喜欢回答非技术问题诸如最大的挫折，最有成就的东西xxx。。出来后，依旧是 面试已完成，叫我等一周至两周，据说面挂了的当场就能发现自己挂了，所以觉着还不错。4月底，投B的文章中了，第一次看见ACCEPT还是很开心，这篇文章经历周期快1年了，听老板说我已经可以博士毕业感觉不错，虽然我只是硕士</p>
<h2 id="2014年5月">2014年5月</h2>
<p>5月1~2，基友结婚，回家，这次回家真赶，买票迟站回去，在家睡一个晚上就坐回来，那个晚上还喝醉吐了，回来后人感觉虚脱，5月4日，去某研究所出差，解决一些bug，并在那吃中饭，感觉不错，很向往工作后的生活，5月5日至今，很期待阿里的通知，结果一直不给我信，也不知什么原因，后来发现好多人跟我一样不上不下，让我等这久，感觉好累。。遂沉迷于dota，不能自已，无节制的打了半个多月的dota，按照自己观察的最快冲分方式进行冲击，结果停滞在1300左右，累了，不再打。5月底，阿里电话过来与我说，通过阿里的面试，但部门安排原因（婉拒？）不能安排实习，但秋季可以直接绿色通道到终面，问我愿不愿意到子公司实习，我当时以为是子部门，我说好，但我暑期只有一个月。月底报名驾校，博格驾校4K大洋。</p>
<h2 id="2014年6月">2014年6月</h2>
<p>之前的项目问题已基本解决，某研究所要与我老板合作，然后我负责代码、文档的所有工作。这一段时间，签协议、送资料、写文档变为我的主题。在我即将要把阿里巴巴遗忘的时候，6月11日，号称阿里子公司的“神马搜索”HR向我了解基本情况，我说我暑假只有一个月时间，可能去不了实习，但她表示可以商量，6月12日，面试官直接与我约定第二天面试，6月13日，我先代表我实验室在某研究所答辩，然后急忙赶回宿舍参加面试，面试感觉中规中矩，<a href="http://www.cnblogs.com/moondark/p/3791851.html" target="_blank" rel="external">面试内容</a>。然后面完没消息很久。与研究所签订合同，那时候世界杯都开始了，几乎没时间看，后来补充资料文档，不断奔波，甚至有一晚上通宵写文档，共200+页，感觉似乎像一次毕设一样。而后，准备了一下科目一并满分通过。6月25日，北京一个号码给我电话，问我愿不愿去阿里UC事业群实习，我说暑假没有时间了，面试官很迅速的挂掉电话，让我心里隐隐不安。我对阿里的好感在这次招聘几乎消磨殆尽，拖沓+混乱，我想，我应该换个目标了。在之后的一段时间内，我将按照项目合同内容，为某研究所服务一阵，想必暑假真的是没有时间的，希望尽快了结，了结完我在实验室的活。我要好好准备秋招，进行下一段路程。</p>
<hr>
<p>时间真的很快，这一年比研一的经历丰富不少，也有不少收获，行百里者半九十，剩下的研三也必须努力。</p>
<p>我期待的秋招很快就开始了，我为自己加油。</p>
]]></content>
    <summary type="html"><![CDATA[<p>再过几天，就是学校校历上的学期末了，研究生阶段，一晃过了两年</p>
<p>去年暑假放假后，在天梯奋战了半个多月，一直在1200~1300左右的水平不再上去，回校后开始了我的研二</p>
<p>按从远至近的回忆，研二就是这样度过的：</p>
<h2 id="2013年9月">2013年9月</h2>
<p>我暑假在ICCV2011的文章“Distributed Cosegmentation via Submodular Optimization on Anisotropic Diffusion”基础上，做了一些改进，并进行了实验，得到较为良好的结果，于是那个9月，我在寻找合适的数据集，补充实验，并撰写论文。</p>
]]></summary>
    
      <category term="胡言乱语" scheme="http://liaoxl.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
      <category term="生活" scheme="http://liaoxl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[神马搜索 面试小结]]></title>
    <link href="http://liaoxl.github.io/blog/20140616/uc-sm/"/>
    <id>http://liaoxl.github.io/blog/20140616/uc-sm/</id>
    <published>2014-06-16T07:11:58.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>在阿里把我当备胎后，考虑到我寒碜的一个月实习时间，我就不打算再投其它公司，也并未打算暑假出去实习了</p>
<p>然而阿里把我简历推向了它的一个“子公司”（我不知道这么称呼是否合适）——神马搜索</p>
<p>我之前在微博上听说过这公司，后来也还是搜索了一下这公司的信息——阿里/UC合资，阿里3成，UC 7成</p>
<a id="more"></a>

<h3 id="6月11日">6月11日</h3>
<p>说到正题，神马搜索的HR打电话问我情况——HR声音很好听，点个赞——HR跟我说，我通过了阿里巴巴的面试，这边想要我去实习，问我什么打算，我抱着暑假不出去实习的心态，跟她说，我暑假只有一个月时间，恐怕不能出去实习。她说，好的，她跟公司核实一下，如果足够优秀，也可以不局限于暑期实习——我开始以为那是一句客套话。</p>
<h3 id="6月12日">6月12日</h3>
<p>一天后，面试官打电话给我，说约个时间面试吧，明天行不行？我这几天恰好事都挤一堆了，明天上午有个结题答辩，为老板给某研究所做的项目。我说，明天上午不行，明天下午如何？面试官跟我说，那明天中午13：30吧——原来昨天HR说的不是客套话。</p>
<h3 id="6月13日">6月13日</h3>
<p>我忙文档前一晚很晚才睡，早上7点起来，坐公交去研究所，跟老板汇合时候，老板居然问我看世界杯没——我只能说你给我布置任务，还这样问我不合适吧？</p>
<p>我做主讲人，答辩时间比我想象中短，OK，我心里想可以赶回来在寝室等电话了</p>
<p>回来吃饭完毕，就已经12点了，花了一点时间温习了下自我介绍，并写好——电话面试可以被利用的点——然后洗了个头，让自己清醒清醒，毫无准备，状态真是比较差。</p>
<h4 id="13：30">13：30</h4>
<p>很准时，面试官电话过来，我完成自我介绍。</p>
<p>面试官对我本科做过爬虫很感兴趣——毕竟做搜索的嘛——让我详细介绍，虽然时隔久远，但我还是大致说出了我做爬虫的思路与方法，这只是一个很简陋的爬虫，只能针对我校白云黄鹤BBS帖子内容进行爬取。</p>
<p>然后，问我对分布式了解多少，我就我看过的The Google File System(GFS)跟他讲了讲我的理解，幸好我曾经看得还算仔细，所以大致都讲的可以——让一个图像专业的学生一直讲分布式我总感觉不合适吧——后来他提到我的专业，图像分割是做什么？我大致讲了一下，他似乎不太感兴趣，然后就over，问我懂deep learning不？我说听说过，但没做过相应的。我做的研究，发的paper似乎对我找工作无任何实质性的帮助——只能一声叹息。</p>
<p>接下来就是面试中经常见得 出题——答题 环节了，总共四道题，我答了三道（貌似答对了），放弃了一道。</p>
<p>1 O(1)时间获取栈的最小值——很常见的题，加一个辅助栈，然后面试官问了一些更深入的问题，当然我有思考过，也不难。</p>
<p>2 中序遍历为1,2,3,…,n，问可能的不同二叉树的个数——我当时放弃了，我推了一下，觉得需要一直分两部分相乘，然后把所有结果相加，即<a href="http://baike.baidu.com/view/2499752.htm" target="_blank" rel="external">卡特兰数</a>的原始形态——我是后来与同学讨论发现是卡特兰数——但我推不出通项公式，我觉得推下去要冷场，所以放弃了。。其实当时状态不好，听面试官说中序遍历，都忘了中序遍历的先后遍历顺序是怎样的了，囧。</p>
<p>3 一个概率题，a与b投硬币，每次投出现正面a加一分，反面b加一分，每次投出现正反概率相同，如果现在a得了6分，b得了7分，终止游戏，请问b获胜的概率有多大？——疲惫状态算数比较差，我第一遍思路错了，跟面试官说思路的时候，发现了，然后马上更正思路，最终分四种情况累加算得概率21/32。</p>
<p>4 给字符串s1: abcde, s2: abedcbde，如何判断s1的每个字符，是否顺序的在s2中出现过——哇塞，我当时理解题意理解了好久，第一反应是设个字符统计数组，累计s1上每个字符出现的个数，然后再遍历s2递减相应的字符统计数，检查最终是否为0——这个思路我甚至都还没说完，我心里就说，这样做错了，然后我就在与面试官核对，什么叫做“顺序的在s2中出现过”，我当时理解有点偏差，然后我依稀感觉可以考虑求LCS，面试官直接说这样错了，我一想，的确是。然后我说出正确的解法，设两个索引l1，l2，分别从s1,s2起点开始，然后每次从s2[l2]开始检查s1[l1]是否出现过，出现了，则l1++,同时更新l2为当前位置，否则一直到遍历结束。我说完之后，觉得我表述的不是很清晰，我说“举个例子”，面试官说，“不用举了，我明白你的解法”</p>
<p>然后问题结束，面试官问我是什么时候毕业，我说明年六月份，问我什么时候能有空，我说7月底才能忙完手头事，8月份以及整个研三时间会相对充裕，然后他表示面试结束了，我鼓起勇气，向他要号码，结果被拒了——“你可以打HR给你电话的座机”——太囧了，我努力提高自己要电话能力的想法第一次就失败了。</p>
<h3 id="总之">总之</h3>
<p>又攒了一个面试经验。总觉得自己在面试的时候有力发不出来，面试官通常都对我专业不感兴趣，真是没办法，面试题回答能力也不算突出吧——每次面完我的感觉是，我这几年的专业知识白学了。</p>
<p>暑假得好好思索下，如何在面试中能有机会展现自己的专业能力，或者让面试官对其感兴趣，不要白白浪费我的paper</p>
]]></content>
    <summary type="html"><![CDATA[<p>在阿里把我当备胎后，考虑到我寒碜的一个月实习时间，我就不打算再投其它公司，也并未打算暑假出去实习了</p>
<p>然而阿里把我简历推向了它的一个“子公司”（我不知道这么称呼是否合适）——神马搜索</p>
<p>我之前在微博上听说过这公司，后来也还是搜索了一下这公司的信息——阿里/UC合资，阿里3成，UC 7成</p>
]]></summary>
    
      <category term="胡言乱语" scheme="http://liaoxl.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
      <category term="求职面试" scheme="http://liaoxl.github.io/tags/%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95/"/>
    
      <category term="生活" scheme="http://liaoxl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的第一篇paper]]></title>
    <link href="http://liaoxl.github.io/blog/20140522/first-paper/"/>
    <id>http://liaoxl.github.io/blog/20140522/first-paper/</id>
    <published>2014-05-22T02:34:52.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>找实习虽然只为自己争取到一个秋季的绿色通道，但可喜的是，我投的几篇paper，终于中了一篇。</p>
<p>现在可以在英文数据库或google scholar上面搜索到自己名字，感觉很nice，研究生的心愿算是完成了一部分，至于剩下的中不中，都不那么重要了，已经留下了自己在科研道路上的足迹。</p>
<p>投递的杂志是<strong>Signal Processing</strong>，是一个很不错的杂志，从<strong>ACCEPT</strong>到文章上线速度很快，在我校的评级是<strong>B类</strong>期刊，发表一篇达到学校博士毕业的基本要求（一篇B或者2篇C），审稿周期算是中等吧，这篇文章的周期大约是<strong>7个月</strong>。</p>
<a id="more"></a>

<p><a href="http://www.sciencedirect.com/science/article/pii/S0165168414002163" target="_blank" rel="external">Science Direct</a></p>
<p><a href="http://scholar.google.com.hk/scholar?q=Xiangli+Liao&amp;btnG=&amp;hl=zh-CN&amp;as_sdt=0%2C5&amp;as_ylo=2014" target="_blank" rel="external">Google Scholar</a></p>
<h2 id="Automatic_image_segmentation_using_salient_key_point_extraction_and_star_shape_prior">Automatic image segmentation using salient key point extraction and star shape prior</h2>
<blockquote>
<p><strong>Xiangli Liao</strong>, Hongbo Xu, Yicong Zhou, Kunqian Li, Wenbing Tao, Qiuju Guo, Liman Liu</p>
</blockquote>
<h3 id="ARTICLE_INFO"><strong>ARTICLE INFO</strong></h3>
<div class="cnblogs_code"><br><pre><br>Article history:<br>Received 27 September 2013<br>Received in revised form<br>28 March 2014<br>Accepted 29 April 2014<br></pre><br></div>

<blockquote>
<p>Please cite this article as: X. Liao, et al., Automatic image segmentation using salient key point extraction and star<br>shape prior, Signal Processing (2014)</p>
</blockquote>
<h3 id="ABSTRACT"><strong>ABSTRACT</strong></h3>
<blockquote>
<p>In this paper, a new unsupervised segmentation method is proposed. The method integrates the star shape prior of the image object with salient point detection algorithm. In the proposed method, the Harris salient point detection is first applied to the color image to obtain the initial salient points. A regional contrast based saliency extraction method is then used to select rough object regions in the image. To restrict the distribution of salient points, an adaptive threshold segmentation is applied to the saliency map to get the saliency mask. And then the salient region points can be obtained by placing the saliency mask on the initial Harris salient points. In order to make sure the salient points which we get are inside the image object thus the star shape constraint can be applied to the graph cuts segmentation, the Affinity Propagation (AP) clustering is employed to find the salient key points among the salient region points. Finally, these salient key points are regarded as foreground seeds and the star shape prior is introduced to graph cuts segmentation framework to extract the foreground object. Extensive experiments and comparisons on public database are provided to demonstrate the good performance of the proposed method.</p>
<p>&amp;2014 Published by Elsevier B.V.</p>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<p>找实习虽然只为自己争取到一个秋季的绿色通道，但可喜的是，我投的几篇paper，终于中了一篇。</p>
<p>现在可以在英文数据库或google scholar上面搜索到自己名字，感觉很nice，研究生的心愿算是完成了一部分，至于剩下的中不中，都不那么重要了，已经留下了自己在科研道路上的足迹。</p>
<p>投递的杂志是<strong>Signal Processing</strong>，是一个很不错的杂志，从<strong>ACCEPT</strong>到文章上线速度很快，在我校的评级是<strong>B类</strong>期刊，发表一篇达到学校博士毕业的基本要求（一篇B或者2篇C），审稿周期算是中等吧，这篇文章的周期大约是<strong>7个月</strong>。</p>
]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="图像处理" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[]]></title>
    <link href="http://liaoxl.github.io/blog/20140520/vim-ctrl-v/"/>
    <id>http://liaoxl.github.io/blog/20140520/vim-ctrl-v/</id>
    <published>2014-05-19T16:00:00.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>title: 转载 技巧: Vim 的纵向编辑模式<br>date: 2014-05-20 11:26:51<br>categories: 技术</p>
<h2 id="tags:_Vim">tags: Vim</h2>
<p>如果要我选一个Vim中让我觉得<strong>Life Changing</strong>功能的话，我一定会选<strong>Vim的块编辑功能</strong>，也就是<strong>Ctrl+V</strong>，虽然还有些别的编辑器也有这功能，但目前为止，我从中受益颇大</p>
<p>原文地址：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vimcolumn/" target="_blank" rel="external">技巧：Vim 的纵向编辑模式</a></p>
<p>Vim 的纵向编辑模式功能强大。本文介绍了 Vim 纵向编辑模式并结合 VisIncr 这个插件在开发测试场景中的应用，让读者更直观了解 Vim 的纵向编辑模式这一功能。</p>
<a id="more"></a>

<h2 id="开始之前">开始之前</h2>
<p>人类大脑对文字的处理是平面式的，所以我们浏览文章、查找资料或者重构代码，要么是横向读，要么是纵向读，要么使用搜索功能，将文字作为一个平面整体。而在编辑文字、编写代码的时候则不是横向就是纵向。常规文本编辑器都是横向编辑，而纵向编辑也常被作为特色功能。比如 Vim、EditPlus、UltraEdit 这些编辑器都有纵向编辑模式，或者称为列模式。像日常文字处理工具 MicroSoft Word、OpenOffice Writer 也可以通过按下功能键 ALT，实现纵向选中文本，然后对文本进行操作。纵向编辑不仅是编辑器的一种功能，更是人们思考问题的一种方式，项目符号、段落编号，都是纵向编辑的体现。</p>
<p>Vim 的纵向编辑模式启动方便，使用灵活，还可以配合上插件实现很实用的高级功能。</p>
<h2 id="启动方法">启动方法</h2>
<p>在 Vim 命令模式下，移动游标定位于某一个位置，键入 ctrl-v后状态栏上出现 VISUAL BLOCK 字样，即进入纵向编辑模式。移动游标以按需选择待编辑的区域。注意：在 Windows 版本的 Vim 中，键组合 ctrl-v通常被映射为文本粘贴，所以 Window 版的 Vim 的纵向编辑模式由 ctrl-q启动。当然灵活的 Vim 也可以由用户自行定义组合键。</p>
<h3 id="示例_1：纵向编辑在批量修改代码的应用演示"><strong>示例 1：纵向编辑在批量修改代码的应用演示</strong></h3>
<p>将数列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">10.1</span><span class="number">.5</span><span class="number">.214</span> </div><div class="line"><span class="number">10.1</span><span class="number">.5</span><span class="number">.212</span> </div><div class="line"><span class="number">10.1</span><span class="number">.5</span><span class="number">.210</span></div></pre></td></tr></table></figure>

<p>编辑成序列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> &gt;&gt; result0 </div><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> &gt;&gt; result0 </div><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span> &gt;&gt; result0</div></pre></td></tr></table></figure>

<p>这是一个将 IP 数列修改成可执行的 ping 命令序列的过程。</p>
<h3 id="第一步：修改"><strong>第一步：修改</strong></h3>
<p>将 IP 数列中第二段所有数字“1” 修改为“5”：</p>
<p>将游标定位第一个行 IP 地址第二段的“1”</p>
<p>ctrl-v 进入纵向编辑模式</p>
<p>G 移动游标到最后一行，可视块覆盖所要修改的列</p>
<p>r 进入修改模式</p>
<p>5 输入数字“5”</p>
<p>ESC 退出纵向编辑模式，同时所有被选中的数字都被改成了“5”，并回到命令模式</p>
<p>结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> </div><div class="line"><span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> </div><div class="line"><span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span></div></pre></td></tr></table></figure>

<h3 id="第二步：前添加"><strong>第二步：前添加</strong></h3>
<p>在所有行之前添加“ping – c 4 ”：</p>
<p>将游标定位到第一行第一列</p>
<p>ctrl-v 进入纵向编辑模式</p>
<p>G 移动游标到最后一行第一列，可视块覆盖了第一列</p>
<p>I 进入行首插入模式</p>
<p>ping -c 4 输入所要求字符“ping – c 4 ”</p>
<p>ESC 退出纵向编辑模式的同时所有选中的字符前都添加了“ping – c 4 ”，回到命令模式</p>
<p>结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> </div><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> </div><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span></div></pre></td></tr></table></figure>

<h3 id="第三步：后添加"><strong>第三步：后添加</strong></h3>
<p>在所有行之后添加“&gt;&gt; result0”：</p>
<p>将游标定位到第一行最后一列</p>
<p>ctrl-v 进入纵向编辑模式</p>
<p>G 移动游标到最后一行最后一列，VISUAL 　 BLOCK 　覆盖了最后一列</p>
<p>A 进入行尾插入模式</p>
<p>>> result    输入所要求字符“>> result0”</p>
<p>ESC 退出纵向编辑模式的同时所有选中的字符后都添加了“ &gt;&gt; result0”，回到命令模式</p>
<p>结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> &gt;&gt; result0 </div><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> &gt;&gt; result0 </div><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span> &gt;&gt; result0</div></pre></td></tr></table></figure>

<p>以上三个步骤有一个共同特点，就是都纵向为编辑方向。以上由三行代码为例的方法同样也可以适用于更多的行。</p>
<h2 id="VisIncr_安装与操作">VisIncr 安装与操作</h2>
<p>以上例子中所演示的对代码的纵向编辑，通过一般的代码重构功能或者结合正则表达式的查找替换也可以实现。然而 Vim 的纵向编辑模式还可以通过插件 VisIncr 的扩展，实现更丰富的功能，如纵向的生成数列。</p>
<p>从 Vim 的官方网站上搜索找到 VisIncr 插件的安装文件，并下载到 Vim 工作目录。执行以下命令即可安装该插件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim visincr.vba.gz </div><div class="line">:so % </div><div class="line">:q</div></pre></td></tr></table></figure>

<p>操作方法以示例 1 的代码为例：</p>
<p>使用 ctrl-v和移动光标选择最后都为数字“0”的一列</p>
<p>:键入冒号触发 Vim 进入命令行模式</p>
<p>:I以第一个数字为出发点，纵向生成增量数列，幅度为 1</p>
<p>ENTER    键入驾车键执行命令</p>
<p>结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span> &gt;&gt; result0 </div><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span> &gt;&gt; result1 </div><div class="line">ping -c <span class="number">4</span> <span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span> &gt;&gt; result2</div></pre></td></tr></table></figure>

<h3 id="示例_2：VisIncr_在生成测试数据的应用演示"><strong>示例 2：VisIncr 在生成测试数据的应用演示</strong></h3>
<p>在应用程序开发过程中经常要生成一个简单有规律的测试数据。比如对一张表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testTable (”ipaddr” ,”filename”, ”owner”)</div></pre></td></tr></table></figure>

<p>生成如下 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="string">"10.5.5.214”,”result0”,”testa”); </span></span></div><div class="line">insert into test values(”10.5.5.212”,”result1”,”testb”); </div><div class="line">insert into test values(”10.5.5.210”,”result2”,”testc”);</div></pre></td></tr></table></figure>

<p>这个纵向有规律的语句序列，可以借助 VinIncr 应用纵向编辑功能来构造。</p>
<h3 id="第一步：准备"><strong>第一步：准备</strong></h3>
<p>打开一个新的 Vim 编辑页面，在命令模式下先输入一个“3”，然后键入“i”进入编辑模式。数字“3”代表本次输入的内容会重复输 3 遍。</p>
<p>在 VIM 中先输入第一行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span></div></pre></td></tr></table></figure>

<p>以回车结束行输入并新开一行，按 ESC 键退出编辑模式。</p>
<p>如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> </div><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> </div><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span></div></pre></td></tr></table></figure>

<h3 id="第二步：构造递减数列"><strong>第二步：构造递减数列</strong></h3>
<p>对于 ipaddr 列，使用 ctrl-v和移动光标选择 IP 地址最后一段以 2 为幅度递减的部分：</p>
<p>: 键入冒号触发 Vim 进入命令行模式\</p>
<p>:I -2 以第一个数字为出发点，纵向生成递减数列，幅度为 2</p>
<p>ENTER 键入驾车键执行命令</p>
<p>结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> </div><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span>”,”result0”,”testa”);</span> </div><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span>”,”result0”,”testa”);</span></div></pre></td></tr></table></figure>

<h3 id="第三步：构造递增数列"><strong>第三步：构造递增数列</strong></h3>
<p>对于 filename 列，使用上一节介绍的方式，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> </div><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span>”,”result1”,”testa”);</span> </div><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span>”,”result2”,”testa”);</span></div></pre></td></tr></table></figure>

<h3 id="第四步：构造字母递增数列"><strong>第四步：构造字母递增数列</strong></h3>
<p>对于 owner 列，使用 ctrl-v和移动光标选择英文字母将要递增的部分。</p>
<p>: 键入冒号触发 Vim 进入命令行模式</p>
<p>:IA 以第一个字母为出发点，纵向生成按字母表排序的序列</p>
<p>ENTER 键入回车键执行命令</p>
<p>结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.214</span>”,”result0”,”testa”);</span> </div><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.212</span>”,”result1”,”testb”);</span> </div><div class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(”<span class="number">10.5</span><span class="number">.5</span><span class="number">.210</span>”,”result2”,”testc”);</span></div></pre></td></tr></table></figure>

<p>以上步骤即演示了借助 Vim 插件 VisIncr 对代码的纵向编辑，生成在纵向有逻辑规律的数列。</p>
<h2 id="总结">总结</h2>
<p>Vim 不仅是一个编辑工具还是一套思考方法，Vim 有很多引导思维方向的技巧，让 Vim 在这个各种编辑器层出不穷的时候历久弥新。本文从纵向编辑为切入点，结合 VisIncr 演示了开发、测试过程中可以使用的实例</p>
]]></content>
    <summary type="html"><![CDATA[<p>title: 转载 技巧: Vim 的纵向编辑模式<br>date: 2014-05-20 11:26:51<br>categories: 技术</p>
<h2 id="tags:_Vim">tags: Vim</h2>
<p>如果要我选一个Vim中让我觉得<strong>Life Changing</strong>功能的话，我一定会选<strong>Vim的块编辑功能</strong>，也就是<strong>Ctrl+V</strong>，虽然还有些别的编辑器也有这功能，但目前为止，我从中受益颇大</p>
<p>原文地址：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vimcolumn/" target="_blank" rel="external">技巧：Vim 的纵向编辑模式</a></p>
<p>Vim 的纵向编辑模式功能强大。本文介绍了 Vim 纵向编辑模式并结合 VisIncr 这个插件在开发测试场景中的应用，让读者更直观了解 Vim 的纵向编辑模式这一功能。</p>
]]></summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[实习求职小结]]></title>
    <link href="http://liaoxl.github.io/blog/20140515/intern/"/>
    <id>http://liaoxl.github.io/blog/20140515/intern/</id>
    <published>2014-05-15T08:20:02.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>今年找实习不够顺利，以过去为镜，总结一下自己的一些不足</p>
<p>在简历投递中，我主要是考虑BAT这三家，AT都有熟人可以内推，但A家号称可以实习一个月，而T家一向都是3个月左右，Baidu需要的实习时间就更长了，我只能保证一个月的实习。去年听闻有些师兄乱拿实习offer，然后秋招进入一些公司的黑名单，故我慎之又慎，宁可错过实习，只投了A家。</p>
<a id="more"></a>

<h2 id="阿里巴巴">阿里巴巴</h2>
<p>我对阿里巴巴的期待很大，<a href="#">吴总</a>也知道这点，2月份HR跟他说可以内推的时候，他就第一时间跟我说，然后我赶紧把简历做好，并发给了他。</p>
<p>3.2号 我在阿里巴巴实习校招官网注册了简历，简历状态处于“新投递”一段时间</p>
<p>3月中旬，我听闻很多内推的被电话面试了，但自己并没有，也有些忐忑，以为简历太搓，被看不上。</p>
<p>3.26号，距离阿里巴巴正式笔试还有三天，那段时间可能已经快通知笔试了。那天下午正在调试一个项目的bug，苦苦思索中，一个电话过来，我看是杭州的，以为是通知我笔试的。<br>聊了几句后，发现这是个面试电话，我当时就感觉很紧张了，大脑还处于调bug状态正在切换。</p>
<p>面试官还是很nice的，叫我简单介绍一下我研究生阶段的主要工作，我说，在研究生阶段，我一方面是从事图像分割领域的研究工作，目前已经有两篇成果投递在业内顶级期刊，另一方面是负责实验室一个手绘识别项目的开发。</p>
<p>面试官应该是并不了解图像分割，而是对另外一个手绘识别项目比较感兴趣，然后就问我，“主要是识别什么图形”，我回答说“是对规则几何图形的识别，如矩形、三角形及圆，同时在识别这些基本图形的基础上，对由这些基本图形组成的复杂图形进行识别”。</p>
<p>然后他就问我，“如何识别矩形、三角形及圆”，我说，“对于这些基本图形的识别，我们通过阅读文献知道一个点集的最小凸包、最大内接三角形、最大内接四边形、最小外接矩形可以用来识别规则的几何图形，比如对于直线，其最小外接矩形的长比宽会趋于无限大，三角形的最大内接三角形与最小凸包的面积比趋于1等等，在以前的文献中，是用一种叫做FuzzyLogic的理论进行识别，在编程实现中即类似与if…else…的语句。但我们为了灵活方便，将SVM分类器训练结合起来，对于每一个点集，我们将这些比例特征提取出来，并构成一个向量，并送入到分类器进行训练，从而得到一个识别分类器，对于要识别的每一个点集，提取相应的特征，并将其送入到分类器中即可得到识别结果”</p>
<p>面试官说“OK，那你对技术有没什么倾向，比如对偏业务的技术与纯技术，对哪种更感兴趣？”我问，“怎么界定哪些叫做偏业务的技术与纯技术”，面试官“比如google的搜索就是纯技术，而像淘宝这样属于偏业务的技术”，我当时第一反应就是对后者有兴趣——前者像是研究，像我现在做的事，我研究生几年做研究，觉得研究过程中，将准确率提升几个百分点，实在不够cool，之前看到网上有人评价百度的搜索，“将搜索准确率提高几个百分点，用户基本感觉不到，但在技术上却需要很大的改善”，我很同意这种观点，我希望以后能做一些别人能够直接感受到的事——所以我跟面试官说，与业务相关的技术，是非常cool的。</p>
<p>接下来面试官问我，“以后有没有读博打算，以及工作地点选择”，我回答说，我不打算读博，工作地点主要以杭州、深圳为主，杭州想去阿里，深圳想去腾讯，并表示阿里是我的第一选择，他很有兴趣问“为什么”，我说一个是阿里的文化很吸引我，生活上的武侠文化，以及技术上对开源的态度，顺便提到了自己也喜欢开源，有github项目并贡献了一些代码（面试官说已提前看过我的github），二是阿里通过技术改变了行业，做的事比较cool，面试官听着也很开心。然后就基本上结束了，结尾面试官跟我说，“后续还会有一到两次面试，具体看HR安排”，后来叫我问问题，我问了一个是实习生能否选择部门，面试官说可以，然后我对阿里云感兴趣，就问了一下阿里云的情况，面试官也给我介绍了一下。这里我居然忘记问面试官的花名以及联系方式，真是经验欠缺呀。</p>
<p>电话完回去看简历状态是“应聘中”，到了晚上变为“应聘通过”，当时感觉还是挺不错的。</p>
<p>后来3.29号的笔试就不用参加，然后等消息。</p>
<p>没想到这一等就要等到4.24号</p>
<p>4.24号，现场面试</p>
<p>技术面试官+HR，通知我9:45面试，但我前面的一个人似乎面试了好久，我在外头等了有近1个小时吧，与现场工作人员（前程无忧）聊了一会。</p>
<p>进去之后，感觉2对1压力还是很大，首先自我介绍，然后面试官依旧对手绘识别项目感兴趣，然后我就重新再画框图加讲解，面试官看起来很累，不怎么多说话，只是用“嗯哼”来回应我，但听得还比较认真，对一些关键问题问得很到位——这一点不得不说，我很喜欢与这样能把握重点的人交流，可以少废话，说出自己在核心问题上的处理方式——但后来出现一些分歧，他问我在这些问题上的核心创新，我一一讲出来。</p>
<p>后来就聊到我的研究成果——两篇paper，他要我用一句简洁的话来介绍我的研究，说实在话，我的确没想过这个问题，我是做图像分割的，我不知道他对这个领域了解有多少，沉默了一会，我问他说，“不知道你用过美图秀秀或PhotoShop的抠图没有，就是需要自己稍微标注一下要分割的前景与背景”，他沉默，我不知他用过没，然后我继续说，“我的方法就是将这种交互式的分割转化为自动分割，通过预测目标所在的位置，自动完成图像的分割”，然后他就问，“怎么预测目标所在的位置呢？”我就说，“近年来图像方面有个比较热门的，叫做显著性，不知道在其它领域可有类似的术语，大概就是指人眼看一幅图像，眼睛容易注意的一些目标位置，人眼注意图像都是有规律的，比如图像中心比图像边缘更吸引注意，对比度高的地方比对比度低的地方更吸引注意，当把这些东西量化之后，就能得到每一点的显著性值，这样整幅图像显著性高的地方可以作为是目标所在的地方，而低的地方可以认为是背景，这样就完成了自动标记，然后再通过图割模型分割”，至于我文章中所用的“星形先验”的形状约束，我就没提了，我想他未必能懂——我经常有这样的想法，或许是我的一个大缺点</p>
<p>然后他问我经常逛哪些论坛或社区，我说“我主要在github、stackoverflow、v2ex以及知乎还有些开源社区”，他似乎不太满意，“我想问，你如何获取一些研究信息，比如你做研究会不会关注哪些大牛或者实验室”，说实话，我并未关注，“我主要是通过最新的会议文章了解到最新的研究动向，很少关注具体某个人，真正要说常看的可能是伯克利大学的计算机视觉组，还有牛津大学的机器学习组，至于具体的人，我没有怎么关注，而且国外人的名字我也记不太住，这里也不好列举”，他似乎有点失望——事实上，我的确是这样做的，我主要看的是看每年计算机视觉最顶级的会议文章，从www.cvpapers.com上面看，每一届的CVPR、ICCV、ECCV以及其它的我都以地毯式搜索的方式进行阅读，第一遍从标题找到自己感兴趣的文章，然后进行深入阅读，会议文章往往代表这当前领域最新的方向、最好的成果以及最天马行空的idea——每个人的学习研究方式都不一样，所以孰优孰劣不能一概而论，我知道很多大牛都有相互follow的习惯，尤其是工作人士或者已成名的大牛，在某些领域某些社交网络高谈阔论，但我不是这种，我更像是以一个程序员的角度，对研究问题慢慢琢磨。</p>
<p>后来他问我，“堆和栈的区别？”，我愣了一下，觉得这问的特别突兀，然后回答说“栈是系统分配、释放的内存，堆是程序员动态分配释放的内存”，然后他问我，“还有呢？”我几乎重复了一遍，然后实在想不出，然后说我不知道了——应该还有堆内存以栈内存分配方式的区别——然后叫我写一个二分查找，很简单，但很可惜我当时并未写好，我想以一种很新颖的方式写出来——不需要除法、比较次数最少、找寻不到时候返回插入位置——当时心理就这个想法，写出新颖的解法，然后最快速提交给他——我真的写的很快——但边界问题出现，我回过头后想了一下有点问题，不知他当场看出来了没</p>
<p>接下来就是HR的问话时间——忘了先后顺序了，总之觉得我不擅长在这类问题上表现——“你能说说目前图像处理在哪些公司有较好的应用，或者说哪些公司在用？”，我回答说“图像搜索是一个大公司会用的领域，google的图片搜索做的已经很不错了，百度的做了好几年好像没什么起色，另外有一家最近比较有名的小公司叫face++，在做人脸识别API比较有名，其它的都是一些小公司在做”</p>
<p>“看到你简历上有提高班，能简单的介绍一下吗？”这绝对是我第一次碰到对“提高班”三个字感兴趣的HR，“提高班是我们在刚入学的时候，通过考试在全校进行选拔，总共选拔出60位同学组成这样一个提高班”——我轻描淡写其实是不对滴，我该说前身是华科少年班，全英文教学，以前出过一个理工科榜样式的牛人——<a href="#">李一男</a>，然后再吹嘘一下——“你觉得哪个项目你最有成就感？”我是说的我发paper的那个，“因为在时间较短的情况下，我完成了很多工作量，是非常有挑战的”——“你觉得哪个项目最牛？”，我依然说是那篇paper的——从编程还是从它的地位，的确是它，我就是这么实在——HR觉得不太好问这些了，就问“看你简历，本科在提高班，研究生是保研，请问你觉得最大的挫折是什么？”——这里我很诚实的回答，近些年来，让我念念不忘的失败，大约就是本科面试BAT均以失败告终——我不知道我这么回答会不会有问题，但后来觉得还是有些不妥，有些失败该隐藏起来的，三年前的学习主要以课程为主，现在你可以通过博客看到我的技术发展历程，可以访问我的github看到我的开源项目，甚至不久的将来，可以通过google scholar搜索到我的出版物，这些，都是三年前未曾有的，我想这就是我的提高吧。</p>
<p>“你觉得你读研这几年可有哪些进步？”，我说，“在我读研之后，甚至说从我大四的时候保研开始，我就一直很努力的在改变，一直坚持增加阅读量增加代码量，使得自己有更大的提高，我很相信‘坚持’这种态度，很多事只要坚持下去一定能有所收获”，HR“那你觉得现在有多大的提高？”我“我想已经有了很大的提高吧”，HR“你学的技术中，有没有哪种是你自己自发性的去学习的？”，我“有很多呀，我很喜欢折腾，而且喜欢一些cool的东西”，“举个例子”，“我与一些工作的同学交流，他们说工作环境中文本编辑是用vim，然后我就努力把vim学好，然后我知道很多公司用git作为版本管理工具，我自己也用github，我就对git进行了学习，然后自己写博客，觉得用markdown很效率，我又去熟悉markdown的写作方式，同时我尝试很多脚本语言如ruby/python/nodejs等的开发，但平时不常用，所以并不熟悉，但我对新技术经常都很感兴趣，平时关注热门的开源项目，比如hadoop，spark之类的”——这时候技术官问我，“你关注hadoop，那你能不能说一下它的优缺点？”——其实我并不太了解，只是关注哪些公司在用——我回答说，“它的优点是将大数据处理转化为一种可以用mapreduce模型进行处理，为大数据的处理提供了一种有效可行的方式，它的缺点是速度慢，因为我知道spark是号称100倍快于hadoop，所以速度应该是hadoop处理的一个大问题”，面试官继续说，“还有呢？”我就回答说不知道了。HR对我前面的一句话很感兴趣，说“你经常与工作的同学交流，你这些同学都在哪些公司工作？”，我说“在阿里和腾讯”，然后她又问我“在阿里是在哪个部门？”我回答说，“在阿里云部门”。</p>
<p>接下来就是问他们问题，我大概就问了与电话面试类似的问题。</p>
<p>总结起来，感觉现场面试中，尤其是HR面试部分，我回答的比较乱，没有章理，有很多问题事先我都没有好好准备，没有展现自己的能力，没有亮点，遂后面沦为备胎。</p>
<p>然后就一直在等，阿里的招聘效率实在很渣，等过了五一，等到了5.9号，好像很有一部分人有了offer通知，但那天收到一条“继续等待”的短信。</p>
<p>5.14号，收到电话拒信，告知“部门协调原因，不能安排实习，秋季保留绿色通道，直接终面”，这里得提一下，我在第一次电话面试表达想去阿里云，在主观题上明确写了最想去阿里云部门，却不知居然是给我分配的是菜鸟网络部门。</p>
<p>很失望，真的很失望，很多时候努力的动力，无非是让自己变得更牛逼，去一个想去的公司，以及想要我的公司，二者缺一不可。</p>
<p>后来<a href="#">吴总</a>说再给我推，推阿里云或者一淘，我想了想，觉得阿里流程太乱，很拖+实习最终留下的因素不可控，而且我只能实习一个月，不如好好准备笔试面试，秋季多投几家，不能把鸡蛋放在一个篮子里，跟吴总说，算了吧。</p>
<h2 id="百度">百度</h2>
<p>本科大三时候，百度几乎算是最巅峰的时候，迄今为止，去百度的同学也很牛。</p>
<p>在等阿里的时候投了百度，岗位是“实习计算机视觉算法研发工程师”，申请后一段时间，简历变为“筛选未通过”，我当时觉得很奇怪，后来不久又变成“筛选中”</p>
<p>不久后，百度HR给我打电话，确认我是否能有三个月及以上的实习时间保证，我说不能，然后就没然后了。。也是那个电话，发现我投的居然是百度深度学习研究院。</p>
<p>能通过百度深度学习研究院的简历筛选，感觉还是不错的，谢谢百度。</p>
<h2 id="腾讯">腾讯</h2>
<p>简历未投</p>
<p>本科时候最想去的公司，小斌今年入职，说老大找他要简历，我考虑到实习时间不够，而且当时阿里面试是“应聘通过”，所以没投，现在想来，甚是后悔。</p>
]]></content>
    <summary type="html"><![CDATA[<p>今年找实习不够顺利，以过去为镜，总结一下自己的一些不足</p>
<p>在简历投递中，我主要是考虑BAT这三家，AT都有熟人可以内推，但A家号称可以实习一个月，而T家一向都是3个月左右，Baidu需要的实习时间就更长了，我只能保证一个月的实习。去年听闻有些师兄乱拿实习offer，然后秋招进入一些公司的黑名单，故我慎之又慎，宁可错过实习，只投了A家。</p>
]]></summary>
    
      <category term="胡言乱语" scheme="http://liaoxl.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
      <category term="求职面试" scheme="http://liaoxl.github.io/tags/%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95/"/>
    
      <category term="生活" scheme="http://liaoxl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello, Hexo! Goodbye, Octopress!]]></title>
    <link href="http://liaoxl.github.io/blog/20140315/hello-world/"/>
    <id>http://liaoxl.github.io/blog/20140315/hello-world/</id>
    <published>2014-03-15T07:45:08.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>最终，从<a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>迁移到<a href="http://zespia.tw/hexo/" target="_blank" rel="external">Hexo</a></p>
<p><a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>有些缺点，让我一直很难以忍受，虽然感觉很<code>Geek</code>，但内心里一直想找个可以代替它的，这些所谓的缺点，事实上大部分都是由于前端引起的，我不是个前端程序员，我不会设计漂亮的前端页面，但我也有自己的品味，不想将就。</p>
<p>先说说我对<a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>的不满：</p>
<ul>
<li><p>字体太大，仿佛所有用<a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>框架的，字体都不小，虽然可以调，但调完后在这个框架里又没那么好看了</p>
</li>
<li><p>Tags或Tag Cloud都太丑，我只能勉强看懂这些CSS，这是从<code>github</code>上面用的其它开源插件</p>
</li>
<li><p>所有第三方<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes" target="_blank" rel="external">主题</a>，我都认真看了一遍，我居然没有找到一款符合我口味的。</p>
</li>
<li><p>右边的<code>SideBar</code>太难看</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><code>code</code>的CSS不好看，超链接不好看……</p>
</li>
<li><p>以上综合，就是看着不舒服</p>
</li>
<li><p>排在最后的，才是为人诟病的生成速度，我并不怎么在乎这点，完全可以泡壶茶慢慢等</p>
</li>
</ul>
<p>如果我是一个优秀的前端程序员，可能我就直接大刀阔斧的往上面修改了，然后继续沿用<a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>，可惜我不是。<br>我曾在这上面改过，经常的问题就是：好不容易某部分好看了，结果发现与整体的框架不符，显得特别突兀。最终我放弃了修改。</p>
<p>很久之前，我就看到了<a href="http://zespia.tw/hexo/" target="_blank" rel="external">Hexo</a>，那个时候我再看网易开源公开课，正在尝试用用<code>Nodejs</code>，当时不换的原因就是还是没有哪个样式让我觉得特别舒服，直到前一阵子看到<a href="http://zespia.tw/hexo/" target="_blank" rel="external">Hexo</a>的<a href="http://hexo.io/docs/" target="_blank" rel="external">官网</a>，我觉得官网是很好看的，后来再仔细看了下<a href="http://zespia.tw/hexo/" target="_blank" rel="external">Hexo</a>的<a href="#">github</a>，发现这个博客框架发展很快，居然多了这么多的主题样式，而且看着让我觉得很舒服。</p>
<p>于是抽个周末，就迁移博客了。</p>
<p>从<a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>迁移到<a href="http://zespia.tw/hexo/" target="_blank" rel="external">Hexo</a>是很容易的事，<a href="http://hexo.io/docs/migration.html" target="_blank" rel="external">官网</a>就有相应的介绍，事实上，<a href="http://zespia.tw/hexo/" target="_blank" rel="external">Hexo</a>本来就是很简单实用的博客框架，非常值得称赞。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最终，从<a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>迁移到<a href="http://zespia.tw/hexo/" target="_blank" rel="external">Hexo</a></p>
<p><a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>有些缺点，让我一直很难以忍受，虽然感觉很<code>Geek</code>，但内心里一直想找个可以代替它的，这些所谓的缺点，事实上大部分都是由于前端引起的，我不是个前端程序员，我不会设计漂亮的前端页面，但我也有自己的品味，不想将就。</p>
<p>先说说我对<a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>的不满：</p>
<ul>
<li><p>字体太大，仿佛所有用<a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>框架的，字体都不小，虽然可以调，但调完后在这个框架里又没那么好看了</p>
</li>
<li><p>Tags或Tag Cloud都太丑，我只能勉强看懂这些CSS，这是从<code>github</code>上面用的其它开源插件</p>
</li>
<li><p>所有第三方<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes" target="_blank" rel="external">主题</a>，我都认真看了一遍，我居然没有找到一款符合我口味的。</p>
</li>
<li><p>右边的<code>SideBar</code>太难看</p>
</li>
</ul>
]]></summary>
    
      <category term="Hexo" scheme="http://liaoxl.github.io/tags/Hexo/"/>
    
      <category term="Octopress" scheme="http://liaoxl.github.io/tags/Octopress/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二分查找]]></title>
    <link href="http://liaoxl.github.io/blog/20140220/binary-search/"/>
    <id>http://liaoxl.github.io/blog/20140220/binary-search/</id>
    <published>2014-02-20T15:09:00.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>在微博上看到一篇文章，关于二分查找：<a href="http://my.oschina.net/fullofbull/blog/199693" target="_blank" rel="external">当我写二分查找时，我想些什么</a></p>
<p>于是想到刚看过的《编程珠玑》上的一句话，“90%的人无法正确写出二分查找”</p>
<p>自己动手：</p>
<pre><code><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> n, <span class="built_in">int</span> target)
{
    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>, <span class="built_in">right</span>=n-<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[<span class="built_in">mid</span>] == target) return <span class="built_in">mid</span>;
        <span class="keyword">if</span>(target &gt; A[<span class="built_in">mid</span>]) <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><p>写完了后，去看这篇文章的答案，发现有很多问题，果然也属于那“90%”。<br><a id="more"></a></p>
<p>问题1, 需要对n进行判断，这个属于编程严谨性的问题；第二个问题，程序可以“优化”。</p>
<blockquote>

<p>我们先来考虑循环的执行步骤。假设我们有一个有着 n 个元素的数组（此处n是一个很大的数值），那么从该数组中第一次找到目标的概率为 1/n（一个很小的数值），下一次（经过一次二分）的概率则是 1/(n/2)——仍然不是很大——以此类推下去。事实上，只有当元素的个数减少到了 10 到 20 的时候，一次找到目标的概率才变得有意义，而对于10 到 20 个元素进行查找需要的只是大概 4 次循环。当查找失败时（在大多数的应用中很普遍），那些额外的测试就将变成纯粹的额外开销。</p>
<p>我们也可以来计算一下，在什么时候找到目标值的概率能接近 50%，但请你扪心自问：在一个复杂度为 O(log2N) 的算法中，对于它的每一步都增添一个额外的复杂计算，而目的仅仅是为了减少最后的几次计算，这样做有意义吗？</p>
</blockquote>


<p>这段话什么意思呢？归根到底就一个意思，如果一个很大的数组中没有我们想要的目标，那么条件判断 if (A[mid] == target) 完全是一个不必要的开销（分支跳转）。实际上，这种条件只要一次就够了，那就是循环终止并判断最终目标的时候。</p>
<p>代码可以改为： </p>
<pre><code><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> n, <span class="built_in">int</span> target)
{
    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>, <span class="built_in">right</span>=n-<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(target &gt; A[<span class="built_in">mid</span>]) <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;
    }
    <span class="keyword">if</span>(<span class="built_in">left</span>&gt;=n || A[<span class="built_in">left</span>]!=target) return -<span class="built_in">left</span>-<span class="number">1</span>;
    return <span class="built_in">left</span>;
}
</code></pre><p>这里注意上面的<code>return -left-1</code>，这行代码在找不到目标时，将目标合适的插入位置输出了，可谓一举两得。</p>
]]></content>
    <summary type="html"><![CDATA[<p>在微博上看到一篇文章，关于二分查找：<a href="http://my.oschina.net/fullofbull/blog/199693" target="_blank" rel="external">当我写二分查找时，我想些什么</a></p>
<p>于是想到刚看过的《编程珠玑》上的一句话，“90%的人无法正确写出二分查找”</p>
<p>自己动手：</p>
<pre><code><span class="built_in">int</span> BinarySearch(<span class="built_in">int</span> A[], <span class="built_in">int</span> n, <span class="built_in">int</span> target)
{
    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>, <span class="built_in">right</span>=n-<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[<span class="built_in">mid</span>] == target) return <span class="built_in">mid</span>;
        <span class="keyword">if</span>(target &gt; A[<span class="built_in">mid</span>]) <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><p>写完了后，去看这篇文章的答案，发现有很多问题，果然也属于那“90%”。<br>]]></summary>
    
      <category term="算法/数据结构" scheme="http://liaoxl.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[点集的一些几何特征]]></title>
    <link href="http://liaoxl.github.io/blog/20140219/dian-ji/"/>
    <id>http://liaoxl.github.io/blog/20140219/dian-ji/</id>
    <published>2014-02-18T16:10:00.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>点集有很多特征，这里提到的有：最小凸包，最小外接矩形，最大内接三角形，最大内接四边形。</p>
<p>编程里面，如何求取点集的这些特征呢？</p>
<h3 id="预处理知识">预处理知识</h3>
<ul>
<li>对于三个点，p0,p1,p2，如何判断以p0为中心，p0p1到p0p2是顺时针还是逆时针？</li>
</ul>
<p>求向量p0p2与p0p1的叉积，若大于0,则说明是p0p2在p0p1的顺时针方向，若小于0，则说明p0p2在p0p1的逆时针方向。</p>
<a id="more"></a>


<h3 id="最小凸包">最小凸包</h3>
<h4 id="Graham栈扫描法。">Graham栈扫描法。</h4>
<p>这里有一篇<a href="http://blog.csdn.net/suwei19870312/article/details/5422818" target="_blank" rel="external">博客</a>对此有比较详细的讨论，并给出比较好的伪代码，这里借鉴一下。</p>
<p>平面上有n个点p0,p1,p2,p3,…,pn，求其最小凸包</p>
<pre><code><span class="function">GRAHAM-SCAN</span>(<span class="tag">Q</span>)
{
     1. 取出所有点钟y坐标最小的点作为初始点p0（如果有y坐标相同的，选择x坐标最小的）
     2. 之后对于所有其他点，以p0为中心，点集中的所有点按关于p0的极角逆时针排序,形成p1,p2,.<span class="class">.pn-1</span>（如果有极角重合，保存最远的点）
     3. <span class="function">push</span>(p0,S) 
     4. <span class="function">push</span>(p1,S)
     5. <span class="function">push</span>(P2<span class="class">.S</span>)
     <span class="function">for</span>(<span class="tag">i</span><span class="value">: <span class="number">3</span>-&gt;m)
     {     
           px = <span class="function">nexttoTop</span>(S)
           py = <span class="function">Top</span>(S) 
           do while (如果(py-&gt;pi向量)相对于(px-&gt;py向量)是顺时针的)
                     <span class="function">pop</span>(S)
                     px = <span class="function">nextotTop</span>(S)
                     py = <span class="function">Top</span>(S)
           <span class="function">push</span>(pi, S);</span>
     }
     return S;
}
</code></pre><h3 id="最小外接矩形">最小外接矩形</h3>
<p>在上述最小凸包的基础上，进行求取，最小外接矩形</p>
<p>这里就是开始<em>旋转卡壳</em>思想的应用。</p>
<p>首先有一个前提，也是可以证明的，<em>凸包的最小外接矩形，至少有一条边与凸包的一条边重合</em>，这点是可以证明的，但过程比较复杂。</p>
<p>在这个前提下，就可以通过下列为代码进行求解了：</p>
<pre><code><span class="constant">MinRec</span>(<span class="constant">Q</span>)
{
    <span class="constant">Rec</span>=<span class="constant">MAXINT</span>
    <span class="keyword">for</span> i=<span class="number">0</span><span class="symbol">:n</span>
        <span class="constant">Pick</span> pipi+<span class="number">1</span> 作为矩形的一条边
        依次找投影在这条边上最左边/最右边以及距此边最远的点，作出矩形
        计算面积<span class="constant">Si_i</span>+<span class="number">1</span>,如果<span class="constant">Si_i</span>+<span class="number">1</span>&lt;<span class="constant">Rec</span>，则 <span class="constant">Rec</span>=<span class="constant">Si_i</span>+<span class="number">1</span>，并记录该边与另外三点
    <span class="keyword">end</span>
}
</code></pre><p>上述求解过程，还可以优化。</p>
<p>在找 最左边/最右边/最远 的三点时，对于固定一条边pipi+1而言，从点pi+2逆时针一直找到pi-1，点到边的距离都是先增大，再减小，在该边上最左边/最右边的投影也是先增大后减小的。所以，保存这三点后，下一次计算，找最左边/最右边/最远 的三点时，就可以分别以上次找到的三点为起点，进行寻找。这里可以减去很多计算。</p>
<h3 id="最大内接三角形">最大内接三角形</h3>
<p>最大内接三角形 同样应用 <em>旋转卡壳</em> 的思想</p>
<pre><code>MaxTrangle(Q)
{
    选p0,p1,p2三点，构成三角形；
    <span class="number">1</span>, 固定p0,p1，移动p2，找到能构成的最大三角形p0p1p2<span class="string">'；
    2, 固定p0p2'</span>，移动p1，找到能构成的最大三角形p0p1<span class="string">'p2'</span>；
    <span class="number">3</span>, 固定p1<span class="string">'p2'</span>，移动p0,找到能构成的最大三角形p0<span class="string">'p1'</span>p2<span class="string">'；
    重复1～3，直至三角形面积不再增大
}</span>
</code></pre><h3 id="最大内接四边形">最大内接四边形</h3>
<p>最大内接四边形， 同样应用 <em>旋转卡壳</em> 的思想</p>
<pre><code>MaxSquare(Q)
{
    选p0,p1,p2,p3三点，构成三角形；
    <span class="number">1</span>, 固定p0,p1,p2，移动p3，找到能构成的最大四边形p0p1p2p3<span class="string">'；
    2, 固定p0,p1,p3'</span>，移动p2，找到能构成的最大四边形p0p1p2<span class="string">'p3'</span>；
    <span class="number">3</span>, 固定p0,p2<span class="string">',p3'</span>，移动p1,找到能构成的最大四边形p0p1<span class="string">'p2'</span>p3<span class="string">'；
    4, 固定p1'</span>,p2<span class="string">',p3'</span>，移动p0,找到能构成的最大四边形p0<span class="string">'p1'</span>p2<span class="string">'p3'</span>；
    重复<span class="number">1</span>～<span class="number">4</span>，直至四边形面积不再增大
}
</code></pre><p>旋转卡壳的思想在求点集的集合特征上有较为广泛的应用，在求得凸包的基础上，可以方便的求取最小外接矩形/最大内接三角形/最大内接四边形。</p>
<p>当然，以上都是伪代码，具体实现，还有一些边界条件得注意。</p>
]]></content>
    <summary type="html"><![CDATA[<p>点集有很多特征，这里提到的有：最小凸包，最小外接矩形，最大内接三角形，最大内接四边形。</p>
<p>编程里面，如何求取点集的这些特征呢？</p>
<h3 id="预处理知识">预处理知识</h3>
<ul>
<li>对于三个点，p0,p1,p2，如何判断以p0为中心，p0p1到p0p2是顺时针还是逆时针？</li>
</ul>
<p>求向量p0p2与p0p1的叉积，若大于0,则说明是p0p2在p0p1的顺时针方向，若小于0，则说明p0p2在p0p1的逆时针方向。</p>
]]></summary>
    
      <category term="算法/数据结构" scheme="http://liaoxl.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[马年——祝自己顺利]]></title>
    <link href="http://liaoxl.github.io/blog/20140201/ma-nian/"/>
    <id>http://liaoxl.github.io/blog/20140201/ma-nian/</id>
    <published>2014-01-31T21:58:00.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>我是个拖延症患者，原本想在除夕晚上写点什么，后来拖到初一，再后来到了今天</p>
<p>今天起得很早，向来年初二都是要早起，然后去 <a href="#">敬神</a>，也就是祭拜祖宗</p>
<p>今年是重要的一年，我常用的邮箱<a href="#">liaoxl2012@gmail.com</a>后面加的2012，本意就是想指我2012年毕业，那是我大三找实习时候开始用的一个邮箱。没想到后来读研了，今年又是这样的一年，我应该换成2015了。</p>
<p>昨儿出去，见了<a href="#">小斌</a>, <a href="#">水哥</a>, <a href="#">黄鹏</a>,<a href="#">国平</a>, 水哥是多年挚交，但所学是医学，专业方面交集倒是并不多，小斌，黄鹏，国平分别签了腾讯，网易游戏，阿里云，都是国内一等一的工作offer了，着实让人佩服。</p>
<a id="more"></a>

<p>今年是我找工作的一年，虽然去年看到他们找工作或者学习上的一些难熬时刻，但毕竟都已经过去了。而我，正在等待这些的来临，我向来运气不太好，往往越想实现的，哪怕自己很努力，但终归会缺点运气，以至最终失之交臂，或需曲折蜿蜒才能得到。</p>
<p>时间过得真快，蛇年转眼即过。我特地看了一下日历，大约2.10号是蛇年的初一，现在是1.31号是马年的初一，而羊年的初一将是2.19号。算是过了一个相对短一点的一年，迎来了一个长的年。</p>
<p>研究生的两个目标，一个是发文章，另一个是找个好工作，都看今年了</p>
<p>祝自己马年顺利吧！</p>
]]></content>
    <summary type="html"><![CDATA[<p>我是个拖延症患者，原本想在除夕晚上写点什么，后来拖到初一，再后来到了今天</p>
<p>今天起得很早，向来年初二都是要早起，然后去 <a href="#">敬神</a>，也就是祭拜祖宗</p>
<p>今年是重要的一年，我常用的邮箱<a href="#">liaoxl2012@gmail.com</a>后面加的2012，本意就是想指我2012年毕业，那是我大三找实习时候开始用的一个邮箱。没想到后来读研了，今年又是这样的一年，我应该换成2015了。</p>
<p>昨儿出去，见了<a href="#">小斌</a>, <a href="#">水哥</a>, <a href="#">黄鹏</a>,<a href="#">国平</a>, 水哥是多年挚交，但所学是医学，专业方面交集倒是并不多，小斌，黄鹏，国平分别签了腾讯，网易游戏，阿里云，都是国内一等一的工作offer了，着实让人佩服。</p>
]]></summary>
    
      <category term="胡言乱语" scheme="http://liaoxl.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
      <category term="生活" scheme="http://liaoxl.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++的虚析构函数]]></title>
    <link href="http://liaoxl.github.io/blog/20131205/virtual-destructor/"/>
    <id>http://liaoxl.github.io/blog/20131205/virtual-destructor/</id>
    <published>2013-12-05T11:16:00.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>C++是门神奇的语言，总是有一些不能以我们“程序员”编写它的角度去理解的问题，究其根本，大多都是C++编译器在“适当”的时候，会自动为我们的程序增加或删除一些东西，如果其编译器所做的改动，与我们预期的结果并不相关，自然我们也能得到较好理解的运行结果，然而，深入学习C++之后，就会发现，其中很多特性，必须要掌握，必须要知道编译器做了哪些东西，才能保证程序的正确执行。</p>
<p>C++类的构造，析构函数是C++编译器在编译的过程中，所作“适当”修改的主要场所</p>
<a id="more"></a>

<p>不扯远，在类继承中，一般类的析构函数都要被定义成虚函数，或者必须要定义成虚函数，这是为什么呢？</p>
<p>看如下两个类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Point2d</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2) {}</div><div class="line">        ~Point2d(){}</div><div class="line"></div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">};</div><div class="line"></div><div class="line">class Point3d : <span class="keyword">public</span> Point2d</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="title">Point3d</span>():<span class="title">z</span>(3){}</div><div class="line">        ~Point3d(){}</div><div class="line"></div><div class="line">        <span class="keyword">int</span> z;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>这上面<code>Point3d</code>是由基类<code>Point2d</code>派生出来的，C++有个特点，可以用基类的指针指向派生类，即派生类可以用基类指针<code>new</code>出来</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Point2d* pt2d</span>=<span class="string">new Point3d();</span></div></pre></td></tr></table></figure>

<p>至于为什么能这样<code>new</code>，我想应该是<code>new</code>出来的空间比基类指针所能访问到的空间更大，所以认为是“安全”的，基于这个理念，派生类指针是不能<code>new</code>基类的，因为会产生“不安全”的访问。</p>
<p>通过看了《深度探索C++对象模型》，来解释一下上述一行式子中，编译器究竟做了什么事：</p>
<p>1,产生一个指向<code>Point2d</code>的指针，<code>pt2d</code>;<br>2,生成一个<code>Point3d</code>的类；<br>3,将<code>Point3d</code>产生的地址赋值给一个指向<code>Point2d</code>的指针</p>
<p>以上的解释比较直白，甚至可以说是“无用”的</p>
<p>将它们细化，第一步没什么好说的，第二步中，生成一个<code>Point3d</code>的类，派生类中的构造函数是如何执行呢？分为以下几步：</p>
<p>1）先调用基类的构造函数，其实在编译器中，是将基类的构造函数嵌入到派生类的构造函数中；</p>
<p>2）如果有虚函数表，将虚函数表重新绑定；</p>
<p>3）执行当前的构造函数，产生一个派生类。</p>
<p>为了验证这一过程，可以在构造函数写出输出函数，看是否这样，如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * con_des.cpp</div><div class="line"> * Copyright (C) 2013 moondark &lt;liaoxl2012@gmail.com&gt;</div><div class="line"> *</div><div class="line"> * Distributed under terms of the MIT license.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Point2d</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Point2d():x(<span class="number">1</span>),y(<span class="number">2</span>)</div><div class="line">        {</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Point2d Constructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        ~Point2d(){}</div><div class="line"></div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class</span> Point3d : <span class="keyword">public</span> Point2d</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Point3d():z(<span class="number">3</span>)</div><div class="line">        {</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Point3d Constructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">        ~Point3d(){}</div><div class="line"></div><div class="line">        <span class="keyword">int</span> z;</div><div class="line">}; </div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</div><div class="line">{</div><div class="line">    </div><div class="line">    Point2d* pt2d=<span class="keyword">new</span> Point3d();</div><div class="line">    <span class="keyword">delete</span> pt2d;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可见，输出是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Point2d <span class="function"><span class="keyword">Constructor</span>!</span></div><div class="line"><span class="title">Point3d</span> <span class="title">Constructor</span>!</div></pre></td></tr></table></figure>

<p>将第二步分解了，那么它又是如何执行第三步呢？</p>
<p>由第二步知道，在派生类中，包含着一个已经构造出来的基类，这个基类在原来的基础上，只是虚函数表做了更改，重新绑定了派生类的函数。而这个<code>Point2d</code>的指针，就是指向派生类的基类实体。</p>
<p>如本文标题所写，要讨论的是为什么是虚析构函数？</p>
<p>在上文中的那段完整可执行代码中，如果你在析构函数也添加打印信息，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Point2d</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2)</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="string">"Point2d Constructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        ~Point2d()</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="string">"Point2d Destructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">};</div><div class="line"></div><div class="line">class Point3d : <span class="keyword">public</span> Point2d</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="title">Point3d</span>():<span class="title">z</span>(3)</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="string">"Point3d Constructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">        ~Point3d()</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="string">"Point3d Destructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">int</span> z;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>重新运行上述代码，则发现<code>delete</code>操作只促发了基类的的析构函数，并未调用派生类的析构函数，于是就产生了问题！</p>
<p>众所周知，析构函数的作用，就是在销毁对象时“合适”的处理一些信息，其实说白了就是擦屁股。</p>
<p>而虚函数的作用，就是可以动态绑定，比如我在基类定义了一个虚函数<code>virtual show()</code>，那么如果我在派生类重写了这个函数，则这时用上述基类指针<code>new</code>出派生类来之后，<code>pt2d</code>访问<code>show</code>函数，实际是派生类的，为何？因为在构造的时候进行重新绑定，按照这个思想，我们应该对基类的析构函数定义为虚函数，这样<code>delete</code>的时候，就是调用派生类的析构函数了。</p>
<p>于是，理所当然，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Point2d</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="title">Point2d</span>():<span class="title">x</span>(1),<span class="title">y</span>(2)</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="string">"Point2d Constructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">virtual</span> ~Point2d()</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="string">"Point2d Destructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">};</div><div class="line"></div><div class="line">class Point3d : <span class="keyword">public</span> Point2d</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="title">Point3d</span>():<span class="title">z</span>(3)</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="string">"Point3d Constructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line">        ~Point3d()</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="string">"Point3d Destructor!"</span> &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">int</span> z;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Point2d <span class="function"><span class="keyword">Constructor</span>!</span></div><div class="line"><span class="title">Point3d</span> <span class="title">Constructor</span>!</div><div class="line"><span class="title">Point3d</span> <span class="title">Destructor</span>!</div><div class="line"><span class="title">Point2d</span> <span class="title">Destructor</span>!</div></pre></td></tr></table></figure>

<p>哇，它正常先调用了派生类的析构函数，再调用基类的析构函数，完全销毁了对象，没有内存泄漏之类的问题诶！</p>
<p>但是，我当时就思考一个问题，如果是虚函数，一般情况下，派生类重写了虚函数，则它只调用派生类的虚函数，而不调用基类的虚函数，但这里却调用了基类的虚函数，这是为什么呢？</p>
<p>记得前面讲了构造函数的生成对象的3个主要步骤，通过阅读《深度探索C++对象模型》就能够了解到，析构函数的行为，在顺序上，是与构造函数相反的，即：</p>
<p>1）执行当前析构函数;</p>
<p>2）重新解绑定虚函数表；</p>
<p>3）调用基类的析构函数</p>
<p>这里最重要的是2，它重新解绑定了虚函数表，这样派生类的析构函数才能找到基类的析构函数，从而能够正确完成程序的功能！</p>
<p>听起来很奇妙！</p>
<p>实际中，基类（如果有派生类）的析构函数往往都定义成虚函数。</p>
<p>接下来就还有个小问题：为何构造函数不能定义为虚函数呢？</p>
<p>前面提到过，构造函数有个过程是绑定虚函数表，如果构造函数定义为虚函数，这个虚函数表该如何生成？如何绑定？对象还没完成构造，如何动态绑定虚函数表！</p>
<p>以上是个人觉得对虚析构函数机制的深入了解。</p>
]]></content>
    <summary type="html"><![CDATA[<p>C++是门神奇的语言，总是有一些不能以我们“程序员”编写它的角度去理解的问题，究其根本，大多都是C++编译器在“适当”的时候，会自动为我们的程序增加或删除一些东西，如果其编译器所做的改动，与我们预期的结果并不相关，自然我们也能得到较好理解的运行结果，然而，深入学习C++之后，就会发现，其中很多特性，必须要掌握，必须要知道编译器做了哪些东西，才能保证程序的正确执行。</p>
<p>C++类的构造，析构函数是C++编译器在编译的过程中，所作“适当”修改的主要场所</p>
]]></summary>
    
      <category term="C/C++" scheme="http://liaoxl.github.io/tags/C-C/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Image Cosegmentation by Co-Diffusion]]></title>
    <link href="http://liaoxl.github.io/blog/20131204/coseg/"/>
    <id>http://liaoxl.github.io/blog/20131204/coseg/</id>
    <published>2013-12-04T15:51:00.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>这算是大半年来的结果吧，从今年4月份一直做到10月份，有很多很多的尝试，虽然最终在理论上并未有很大的创新，实验结果却比较给力。</p>
<p>协同分割，即不仅要完成分割，而且要将不同图像的分割结果进行“归类”行为</p>
<p>写出了一篇像模像样的paper，正在赶投各种Journal，不知终归何处</p>
<p>看看实验的效果图吧，最好的肯定是我做出来的，哈哈</p>
<a id="more"></a>

<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_co-contra1_%e5%89%af%e6%9c%ac.png" alt="co-contra1"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_co-contrao2-4_%e5%89%af%e6%9c%ac.png" alt="co-contra2"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_co-contraw2-4_%e5%89%af%e6%9c%ac.png" alt="co-contra3"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_cows_%e5%89%af%e6%9c%ac.jpg" alt="cows"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_flowers_%e5%89%af%e6%9c%ac.png" alt="flowers"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_Kendo-EKC4_%e5%89%af%e6%9c%ac.png" alt="kendo-ekc"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/moondark/537886/o_skating1_%e5%89%af%e6%9c%ac.png" alt="skating"></p>
<p>当然，所得到的方法还有很多短板，需要改进，不过暂时没有太多的思路。</p>
]]></content>
    <summary type="html"><![CDATA[<p>这算是大半年来的结果吧，从今年4月份一直做到10月份，有很多很多的尝试，虽然最终在理论上并未有很大的创新，实验结果却比较给力。</p>
<p>协同分割，即不仅要完成分割，而且要将不同图像的分割结果进行“归类”行为</p>
<p>写出了一篇像模像样的paper，正在赶投各种Journal，不知终归何处</p>
<p>看看实验的效果图吧，最好的肯定是我做出来的，哈哈</p>
]]></summary>
    
      <category term="图像分割" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
      <category term="图像处理" scheme="http://liaoxl.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Cosegmentation" scheme="http://liaoxl.github.io/tags/Cosegmentation/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[尝试hadoop的单机环境搭建]]></title>
    <link href="http://liaoxl.github.io/blog/20131201/hadoop/"/>
    <id>http://liaoxl.github.io/blog/20131201/hadoop/</id>
    <published>2013-12-01T11:34:00.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>近来关注大数据，云计算等相关技术，把Google的三大论文看了一遍，作为非计算机科班的同学，看得有点云里雾里，看了不少书才略微理清楚现在这些流行的大数据框架之间的关系。</p>
<p>Hadoop便是其中一个非常吸引我的框架，打算对其环境进行配置，其中走了不少弯路，想写点记录一下。</p>
<a id="more"></a>

<p>首先，要讨论的是OpenJDK与SunJDK，网上的大堆教程基本都是清一色的要安装SunJDK，为何呢？因为JDK的开源版在1.6.0版本之前，与SunJDK还有一些不同，不能很好的支持hadoop，但在1.6.0版本之后，就可以很好的支持了。</p>
<p>为何要提到这个呢？因为很多系统默认装的就是OpenJDK，如果换成SunJDK，可能会麻烦很多，当然，你可以在有OpenJDK的情况下依旧装上SunJDK，用<a href="#">alternative</a>命令来设置版本，显然这样麻烦许多。比如我对我的linux分盘不够大，我不希望资源被浪费，所以我只愿意安装其中一种。</p>
<p>这里提一下我所走的弯路，我首先卸载了OpenJDK（用不考虑依赖关系的命令），装上SunJDK之后，我又知道了其实OpenJDK不影响，于是我删了SunJDK，重新装了OpenJDK （我是不是太折腾了）</p>
<p>其次，要设置好Java的环境变量，<code>vim /etc/profile</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># SET JAVA Environment OpenJDK</span></div><div class="line"><span class="constant">JAVA_HOME</span>=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">1.7</span>.<span class="number">0</span>-openjdk/</div><div class="line"><span class="constant">JRE_HOME</span>=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">1.7</span>.<span class="number">0</span>-openjdk/</div><div class="line"><span class="constant">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:</span><span class="variable">$JAVA_HOME</span>/<span class="symbol">bin:</span><span class="variable">$JRE_HOME</span>/bin</div><div class="line"><span class="constant">CLASSPATH</span>=.<span class="symbol">:</span><span class="variable">$JAVA_HOME</span>/lib/dt.<span class="symbol">jar:</span><span class="variable">$JAVA_HOME</span>/lib/tools.<span class="symbol">jar:</span><span class="variable">$JRE_HOME</span>/lib</div><div class="line">export <span class="constant">JAVA_HOME</span> <span class="constant">JRE_HOME</span> <span class="constant">PATH</span> <span class="constant">CLASSPATH</span></div></pre></td></tr></table></figure>

<p>然后，ssh，其实这个我早就安装了。SSH有什么作用呢？一般我们相互访问，都需要输入口令，而SSH则产生一个钥匙，这个钥匙可以自动作为具有访问权限的标识，我们就不需要再去手动的输入命令了，然程序自动调用这个钥匙去开锁吧（这样解释应该是对的吧）</p>
<p>最后，就是hadoop了，可分为几个步骤来讲解</p>
<p>1）添加组和用户：其实这个步骤未必一定需要，但为了计算产生的各种数据不要“污染”你自个的用户区，就建一个账户专门来处理吧。而且，如果是集群的，为了更好编号什么的，一般创建一个易于管理识别的账户。</p>
<p>账户和组的创建可以自己探索了，ubuntu和fedora是不一样的，但都比较容易，注意要添加sudo权限</p>
<p>2）解压hadoop的包，假设创建的用户为<code>hadoop</code>，解压至<code>/home/hadoop/hadoop</code>文件夹下，然后设置hadoop的环境变量，同样<code>vim /etc/profile</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># SET For HADOOP</span></div><div class="line"><span class="keyword">export</span> HADOOP_DEV_HOME=/home/hadoop/hadoop</div><div class="line"><span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_DEV_HOME</span>/bin</div><div class="line"><span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_DEV_HOME</span>/sbin</div><div class="line"><span class="keyword">export</span> HADOOP_MAPARED_HOME=<span class="variable">${HADOOP_DEV_HOME}</span></div><div class="line"><span class="keyword">export</span> HADOOP_COMMON_HOME=<span class="variable">${HADOOP_DEV_HOME}</span></div><div class="line"><span class="keyword">export</span> HADOOP_HDFS_HOME=<span class="variable">${HADOOP_DEV_HOME}</span></div><div class="line"><span class="keyword">export</span> YARN_HOME=<span class="variable">${HADOOP_DEV_HOME}</span></div><div class="line"><span class="keyword">export</span> HADOOP_CONF_DIR=<span class="variable">${HADOOP_DEV_HOME}</span>/etc/hadoop</div></pre></td></tr></table></figure>

<p>记住这里改完，应该以hadoop用户身份，进行source，才会生效</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">source</span> /etc/<span class="keyword">profile</span></div></pre></td></tr></table></figure>

<p>3）配置xml文件<br>需要配置的xml文件包括：<code>core-site.xml</code>, <code>hdfs-site.xml</code>, <code>mapred-site.xml</code>(这个好似没有这个文件，有个文件叫做mapred-site.xml.template吧，拷贝一个并命名为mapred-site.xml), <code>yarn-site.xml</code><br>这四个xml的作用目前我还不是特别清楚，看起来像是部署数据存取的位置以及node的命名，如下配置：（注：上面类似：file:/home/hadoop/dfs/name的目录我都手动创建了，不知运行时它会否自动创建）</p>
<p>core-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://localhost:8020<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">description</span>&gt;</span> The name of the default file system<span class="tag">&lt;/<span class="title">description</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">final</span>&gt;</span>true<span class="tag">&lt;/<span class="title">final</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></div></pre></td></tr></table></figure>

<p>hdfs-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;<span class="keyword">property</span>&gt;</div><div class="line">        &lt;<span class="property">name</span>&gt;dfs.namenode.<span class="property">name</span>.dir&lt;/<span class="property">name</span>&gt;</div><div class="line">        &lt;value&gt;<span class="type">file</span>:/home/hadoop/dfs/<span class="property">name</span>&lt;/value&gt;</div><div class="line">        &lt;description&gt;Determines <span class="keyword">where</span> <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> <span class="keyword">local</span> filesystem <span class="keyword">the</span> DFS <span class="property">name</span> node should store <span class="keyword">the</span> <span class="property">name</span> table. If this <span class="keyword">is</span> a comma-delimited <span class="type">list</span> <span class="keyword">of</span> directories <span class="keyword">then</span> <span class="keyword">the</span> <span class="property">name</span> table <span class="keyword">is</span> replicated <span class="keyword">in</span> all <span class="keyword">of</span> <span class="keyword">the</span> directories, <span class="keyword">for</span> redundancy. &lt;/description&gt;</div><div class="line">        &lt;final&gt;<span class="constant">true</span>&lt;/final&gt;</div><div class="line">    &lt;/<span class="keyword">property</span>&gt;</div><div class="line"></div><div class="line">    &lt;<span class="keyword">property</span>&gt;</div><div class="line">        &lt;<span class="property">name</span>&gt;dfs.datanode.data.dir&lt;/<span class="property">name</span>&gt;</div><div class="line">        &lt;value&gt;<span class="type">file</span>:/home/hadoop/dfs/data&lt;/value&gt;</div><div class="line">        &lt;description&gt;Determines <span class="keyword">where</span> <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> <span class="keyword">local</span> filesystem an DFS data node should store <span class="keyword">its</span> blocks. If this <span class="keyword">is</span> a comma-delimited <span class="type">list</span> <span class="keyword">of</span> directories, <span class="keyword">then</span> data will be stored <span class="keyword">in</span> all named directories, typically <span class="function_start"><span class="keyword">on</span></span> different devices.Directories <span class="keyword">that</span> do <span class="keyword">not</span> exist are ignored</div><div class="line">        &lt;/description&gt;</div><div class="line">        &lt;final&gt;<span class="constant">true</span>&lt;/final&gt;</div><div class="line">    &lt;/<span class="keyword">property</span>&gt;</div><div class="line"></div><div class="line">    &lt;<span class="keyword">property</span>&gt;</div><div class="line">        &lt;<span class="property">name</span>&gt;dfs.replication&lt;/<span class="property">name</span>&gt;</div><div class="line">        &lt;value&gt;<span class="number">1</span>&lt;/value&gt;</div><div class="line">    &lt;/<span class="keyword">property</span>&gt;</div><div class="line"></div><div class="line">    &lt;<span class="keyword">property</span>&gt;</div><div class="line">        &lt;<span class="property">name</span>&gt;dfs.permissions&lt;/<span class="property">name</span>&gt;</div><div class="line">        &lt;value&gt;<span class="constant">false</span>&lt;/value&gt;</div><div class="line">    &lt;/<span class="keyword">property</span>&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>

<p>mapred-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.system.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:/home/hadoop/mapred/system<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">final</span>&gt;</span>true<span class="tag">&lt;/<span class="title">final</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.local.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:/home/hadoop/mapred/local<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">final</span>&gt;</span>true<span class="tag">&lt;/<span class="title">final</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></div></pre></td></tr></table></figure>

<p>yarn-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="title">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="title">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span>org.apache.hadoop.mapred ShuffleHandler<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></div></pre></td></tr></table></figure>

<p>4）修改hadoop-env.sh, <code>vim /home/hadoop/hadoop/etc/hadoop/hadoop-env.sh</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># export JAVA_HOME=${JAVA_HOME}</span></div><div class="line">export <span class="constant">JAVA_HOME</span>=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">1.7</span>.<span class="number">0</span>-openjdk/</div></pre></td></tr></table></figure>

<p>5）测试</p>
<p>格式化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hdfs namenode -<span class="built_in">format</span></div></pre></td></tr></table></figure>

<p>如果出现<code>EXIT 0</code>，说明（应该）成功了</p>
<p>启动DFS</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hadoop-daemon.<span class="keyword">sh</span> start namenode</div><div class="line">hadoop-daemon.<span class="keyword">sh</span> start datanode</div></pre></td></tr></table></figure>

<p>使用jps查看进程是否启动（会显示namenode和datanode）<br>jps类似于一个进程查看器，即查看JVM中的当前进程，这些进程的启动都会有log，可以直接去看log看有否启动成功。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jps</div></pre></td></tr></table></figure>

<p>可以访问这个网页</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//localhost:50070/dfshealth.jsp</span></div></pre></td></tr></table></figure>

<p>关闭DFS</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hadoop-daemon.<span class="keyword">sh</span> <span class="keyword">stop</span> namenode</div><div class="line">hadoop-daemon.<span class="keyword">sh</span> <span class="keyword">stop</span> datanode</div></pre></td></tr></table></figure>

<hr>
<h3 id="EOF">EOF</h3>
<p>关于对hadoop的尝试先就到这吧</p>
]]></content>
    <summary type="html"><![CDATA[<p>近来关注大数据，云计算等相关技术，把Google的三大论文看了一遍，作为非计算机科班的同学，看得有点云里雾里，看了不少书才略微理清楚现在这些流行的大数据框架之间的关系。</p>
<p>Hadoop便是其中一个非常吸引我的框架，打算对其环境进行配置，其中走了不少弯路，想写点记录一下。</p>
]]></summary>
    
      <category term="hadoop" scheme="http://liaoxl.github.io/tags/hadoop/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 与 系统剪贴板clipboard]]></title>
    <link href="http://liaoxl.github.io/blog/20131117/vim-clipboard/"/>
    <id>http://liaoxl.github.io/blog/20131117/vim-clipboard/</id>
    <published>2013-11-17T06:41:00.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>在fedora 17下，刚开始不太习惯vim的时候，也没发现默认装的vim不能使用系统剪贴板这个问题，后来用多了，发现居然不能从vim复制到系统剪贴板，刚开始我还以为我快捷键使用的不对，但试过多次，均不成功。于是乎，在vim中想复制就必须用gedit打开，然后用鼠标类似windows的操作来完成复制操作，对于常用文件夹可能还不觉得有多么烦，但有些路径深的，那就实在是非常不爽！！</p>
<p>命令那么简单，怎么会搞错呢？后来我才发现，原来系统自带的（我的要么是一安装就有，要么就是我用yum安装的）是不具备这个功能的，即<code>&quot;+y</code>不适应。怎样查看自己的vim版本是否支持系统剪贴板呢？通过以下命令，如果<code>clipboard</code>前面是个减号，则说明系统编译时候未加入clipboard这个选项</p>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[moondark@Moondark ~]$ <span class="keyword">vim</span> --<span class="keyword">version</span>|<span class="keyword">grep</span> clipboard</div><div class="line">-clipboard       +<span class="built_in">iconv</span>           +path_extra      -toolbar</div><div class="line">+<span class="built_in">eval</span>            +mouse_dec       +startuptime     -xterm_clipboard</div></pre></td></tr></table></figure>

<p>很显然解决这个问题有个很直接的方法：<strong>重编译支持系统剪贴板的Vim</strong></p>
<p>然而我就觉得很不爽，想找个不重新编译就能解决的方法，这个时候我想到了我之前试过的一个命令行复制工具<code>xclip</code>，用它配合vim就能够实现使用系统剪贴板了。在网上看到有人说<code>xclip</code>会因为<code>detach</code>在关闭vim后失效，用<code>xsel</code>会更好，我目前还没接触到，所以就先使用这个先吧，具体命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">" \c                  复制至公共剪贴板</div><div class="line">vmap <span class="tag">&lt;<span class="title">leader</span>&gt;</span>c :!xclip -selection clipboard<span class="tag">&lt;<span class="title">CR</span>&gt;</span>u</div></pre></td></tr></table></figure>

<p>我是将复制命令映射到<code>\c</code>上了，这个可以自定义，目前用着还觉得挺方便的。</p>
<p>更多关于我的vim配置，可见我的<a href="https://github.com/liaoxl/dotfiles" target="_blank" rel="external">dotfiles</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>在fedora 17下，刚开始不太习惯vim的时候，也没发现默认装的vim不能使用系统剪贴板这个问题，后来用多了，发现居然不能从vim复制到系统剪贴板，刚开始我还以为我快捷键使用的不对，但试过多次，均不成功。于是乎，在vim中想复制就必须用gedit打开，然后用鼠标类似windows的操作来完成复制操作，对于常用文件夹可能还不觉得有多么烦，但有些路径深的，那就实在是非常不爽！！</p>
<p>命令那么简单，怎么会搞错呢？后来我才发现，原来系统自带的（我的要么是一安装就有，要么就是我用yum安装的）是不具备这个功能的，即<code>&quot;+y</code>不适应。怎样查看自己的vim版本是否支持系统剪贴板呢？通过以下命令，如果<code>clipboard</code>前面是个减号，则说明系统编译时候未加入clipboard这个选项</p>
]]></summary>
    
      <category term="Vim" scheme="http://liaoxl.github.io/tags/Vim/"/>
    
      <category term="Xclip" scheme="http://liaoxl.github.io/tags/Xclip/"/>
    
      <category term="技术" scheme="http://liaoxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Graphcuts 与 Kmeans]]></title>
    <link href="http://liaoxl.github.io/blog/20131116/graphcuts-kmeans/"/>
    <id>http://liaoxl.github.io/blog/20131116/graphcuts-kmeans/</id>
    <published>2013-11-16T10:30:00.000Z</published>
    <updated>2014-11-15T07:09:30.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    
    
      <category term="最大流" scheme="http://liaoxl.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="Kmeans" scheme="http://liaoxl.github.io/tags/Kmeans/"/>
    
      <category term="研究" scheme="http://liaoxl.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
</feed>
